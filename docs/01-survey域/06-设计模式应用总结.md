# 11-04-06 设计模式应用总结

> **版本**：V3.0  
> **最后更新**：2025-11-26  
> **状态**：✅ 已实现并验证  
> **所属系列**：[Survey 子域设计系列](./11-04-Survey子域设计系列.md)

---

## 1. 设计模式全景图

Survey 子域运用了 7 种核心设计模式，形成了一个高内聚、低耦合、易扩展的架构体系。

### 1.1 模式分布图

```text
┌─────────────────────────────────────────────────────────────────┐
│                     Survey 子域架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │         Questionnaire 聚合（复杂设计）                   │   │
│  │                                                          │   │
│  │  1️⃣ 注册器模式        Question 类型注册                 │   │
│  │  2️⃣ 工厂模式          统一创建入口 NewQuestion          │   │
│  │  3️⃣ 参数容器模式      QuestionParams 收集参数           │   │
│  │  4️⃣ 函数式选项模式    15+ With* 函数灵活配置            │   │
│  │  5️⃣ 领域服务模式      5个领域服务分离职责              │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │         AnswerSheet 聚合（简单设计）                     │   │
│  │                                                          │   │
│  │  2️⃣ 简单工厂模式      CreateAnswerValueFromRaw         │   │
│  │  6️⃣ 适配器模式        AnswerValueAdapter 连接 Validation│   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │         Validation 子域（策略设计）                      │   │
│  │                                                          │   │
│  │  7️⃣ 策略模式          8种 ValidationStrategy           │   │
│  │  1️⃣ 注册器模式        策略自动注册                     │   │
│  │  5️⃣ 领域服务模式      Validator 协调策略               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 模式概览表

| 模式 | 应用位置 | 解决问题 | 核心价值 |
|-----|---------|---------|---------|
| **1️⃣ 注册器模式** | Question 题型<br>Validation 策略 | 如何管理多种类型的工厂/策略 | 开闭原则：新增类型无需修改现有代码 |
| **2️⃣ 工厂模式** | Question 创建<br>AnswerValue 创建 | 如何创建复杂对象 | 封装创建逻辑，统一创建入口 |
| **3️⃣ 参数容器模式** | QuestionParams | 如何收集和传递多个参数 | 职责分离：参数收集 vs 对象创建 |
| **4️⃣ 函数式选项模式** | WithCode, WithStem... | 如何灵活配置对象 | 可读性、可扩展性、向后兼容 |
| **5️⃣ 领域服务模式** | Lifecycle, Validator... | 如何避免聚合根臃肿 | 单一职责：复杂逻辑独立为服务 |
| **6️⃣ 适配器模式** | AnswerValueAdapter | 如何连接不兼容的接口 | 解耦：不同子域通过接口通信 |
| **7️⃣ 策略模式** | ValidationStrategy | 如何实现可扩展的算法族 | 开闭原则：算法独立变化 |

---

## 2. 注册器模式（Registry Pattern）

### 2.1 设计思想

**核心问题**：如何在运行时动态管理多种类型的创建逻辑？

**传统方案的问题**：

```go
// ❌ 传统方式：硬编码 switch-case
func CreateQuestion(qType string, params Params) Question {
    switch qType {
    case "radio":
        return &RadioQuestion{...}
    case "checkbox":
        return &CheckboxQuestion{...}
    // ... 新增题型需要修改这里 ❌
    default:
        return nil
    }
}
```

**问题**：

* ❌ 违反开闭原则：新增题型需修改此函数
* ❌ 所有题型耦合在一起
* ❌ 难以单独测试某个题型

### 2.2 注册器模式方案

```text
┌──────────────────────────────────────────────────┐
│           注册器模式架构图                        │
└──────────────────────────────────────────────────┘

    1️⃣ 定义工厂函数类型
         │
         ↓
    ┌─────────────────────────────┐
    │ type QuestionFactory         │
    │   func(Params) Question     │
    └─────────────────────────────┘
         │
         ↓
    2️⃣ 创建注册表
         │
         ↓
    ┌─────────────────────────────┐
    │ var questionRegistry =       │
    │   map[Type]Factory{}        │
    └─────────────────────────────┘
         │
         ↓
    3️⃣ 各题型在 init() 中自动注册
         │
    ┌────┴────┬────┬────┬────┐
    ↓         ↓    ↓    ↓    ↓
  Radio   Checkbox Text ...  
  init()   init()  init()
    │        │       │
    └────────┴───────┴──────────────┐
                                    ↓
                        RegisterQuestionFactory()
                                    │
                                    ↓
                            questionRegistry
                                    │
                                    ↓
    4️⃣ 统一创建入口从注册表查找
         │
         ↓
    ┌─────────────────────────────┐
    │ func NewQuestion()           │
    │   factory := registry[type] │
    │   return factory(params)    │
    └─────────────────────────────┘
```

### 2.3 实现要点

***步骤 1：定义工厂函数类型***

```go
// 工厂函数签名（伪代码）
type QuestionFactory func(params *QuestionParams) (Question, error)
```

***步骤 2：创建全局注册表***

```go
// 全局注册表（伪代码）
var questionRegistry = map[QuestionType]QuestionFactory{}

// 注册函数
func RegisterQuestionFactory(qType QuestionType, factory QuestionFactory) {
    questionRegistry[qType] = factory
}
```

***步骤 3：各题型自动注册***

```go
// radio_question.go（伪代码）
func init() {
    RegisterQuestionFactory(TypeRadio, func(params *QuestionParams) (Question, error) {
        return &RadioQuestion{
            code:    params.GetCode(),
            stem:    params.GetStem(),
            options: params.GetOptions(),
            // ...
        }, nil
    })
}
```

***步骤 4：统一创建入口***

```go
// 统一创建函数（伪代码）
func NewQuestion(qType QuestionType, options ...QuestionOption) (Question, error) {
    params := NewQuestionParams()
    for _, opt := range options {
        opt(params)  // 应用函数式选项
    }
    
    factory, ok := questionRegistry[qType]  // 从注册表查找
    if !ok {
        return nil, errors.New("unknown question type")
    }
    
    return factory(params)  // 调用工厂函数
}
```

> **查看完整实现**：[internal/apiserver/domain/survey/questionnaire/factory.go](../../internal/apiserver/domain/survey/questionnaire/factory.go)

### 2.4 模式价值

**✅ 开闭原则**：新增题型只需 3 步

1. 实现 Question 接口
2. 在 init() 中注册工厂
3. 无需修改任何现有代码

**✅ 解耦**：每个题型独立在自己的文件中

**✅ 自动化**：编译时通过 init() 自动注册

**应用场景对比**：

| 场景 | 是否使用注册器 | 原因 |
|-----|--------------|------|
| **Question 题型** | ✅ 使用 | 6种类型，可能扩展 |
| **ValidationStrategy** | ✅ 使用 | 8种策略，可能扩展 |
| **AnswerValue** | ❌ 不使用 | 4种类型，映射简单，用 switch-case |

---

## 3. 工厂模式 + 参数容器模式

### 3.1 设计思想

**核心问题**：Question 创建需要 10+ 个参数，如何优雅传递？

**方案对比**：

```go
// ❌ 方案1：多参数函数（不推荐）
func NewRadioQuestion(
    code Code,
    stem string,
    required bool,
    options []Option,
    validationRules []Rule,
    calculationRules []Rule,
    displayOrder int,
    helpText string,
    // ... 更多参数
) Question {
    // 参数顺序容易出错
    // 新增参数破坏向后兼容
}

// ❌ 方案2：配置结构体（稍好）
type QuestionConfig struct {
    Code       Code
    Stem       string
    Required   bool
    Options    []Option
    // ...
}
func NewRadioQuestion(config QuestionConfig) Question

// ✅ 方案3：参数容器 + 函数式选项（推荐）
func NewQuestion(qType QuestionType, options ...QuestionOption) Question
```

### 3.2 参数容器模式

**设计目标**：

* 收集所有创建参数
* 提供默认值
* 与工厂方法解耦

```text
┌───────────────────────────────────────────────────┐
│          参数容器模式架构图                        │
└───────────────────────────────────────────────────┘

    参数容器只负责收集参数
         │
         ↓
    ┌─────────────────────────────┐
    │   QuestionParams            │
    │                             │
    │   - code: Code              │
    │   - stem: string            │
    │   - required: bool          │
    │   - options: []Option       │
    │   - validationRules: []Rule │
    │   ... 10+ 字段               │
    │                             │
    │   + GetCode() Code          │
    │   + GetStem() string        │
    │   ... Getter 方法            │
    └─────────────────────────────┘
         ↑
         │ 通过函数式选项填充
         │
    ┌────┴─────────────────────────┐
    │                              │
  WithCode()  WithStem()  WithRequired()
  WithOptions()  ... 15+ 函数
```

**伪代码**：

```go
// 参数容器（伪代码）
type QuestionParams struct {
    code             Code
    stem             string
    required         bool
    options          []Option
    validationRules  []Rule
    // ... 更多字段
}

// 提供 Getter 方法（工厂函数使用）
func (p *QuestionParams) GetCode() Code { return p.code }
func (p *QuestionParams) GetStem() string { return p.stem }
// ...
```

> **查看完整实现**：[internal/apiserver/domain/survey/questionnaire/factory.go](../../internal/apiserver/domain/survey/questionnaire/factory.go)

### 3.3 职责分离

```text
┌─────────────────────────────────────────────────┐
│        参数容器 vs 工厂方法的职责分离            │
└─────────────────────────────────────────────────┘

QuestionParams                  QuestionFactory
    │                               │
    │ 职责：收集参数                 │ 职责：创建对象
    │                               │
    ├─ 定义所有字段                 ├─ 读取参数
    ├─ 提供默认值                   ├─ 校验参数
    ├─ 提供 Getter                  ├─ 实例化对象
    └─ 无业务逻辑                   └─ 执行业务逻辑
         │                               │
         └───────────────┬───────────────┘
                         │
                    互不干扰，独立变化
```

**价值**：

* ✅ QuestionParams 变化不影响工厂方法
* ✅ 工厂方法变化不影响参数容器
* ✅ 单一职责：各司其职

---

## 4. 函数式选项模式（Functional Options Pattern）

### 4.1 设计思想

**核心问题**：如何提供灵活、可读、向后兼容的配置方式？

**Go 语言中的常见模式**：

```go
// Go 标准库中的应用
grpc.Dial(target,
    grpc.WithInsecure(),
    grpc.WithBlock(),
    grpc.WithTimeout(5*time.Second),
)

http.Server{
    Addr: ":8080",
    // 只配置需要的字段
}
```

### 4.2 实现原理

```text
┌───────────────────────────────────────────────────┐
│        函数式选项模式执行流程                      │
└───────────────────────────────────────────────────┘

1️⃣ 定义选项函数类型
    │
    ↓
   type QuestionOption func(*QuestionParams)

2️⃣ 创建配置函数（返回选项函数）
    │
    ↓
   func WithCode(code Code) QuestionOption {
       return func(p *QuestionParams) {
           p.code = code  // 闭包捕获参数
       }
   }

3️⃣ 调用时传入多个选项
    │
    ↓
   NewQuestion(TypeRadio,
       WithCode("Q1"),        // 每个都是一个函数
       WithStem("问题1"),
       WithRequired(true),
   )

4️⃣ 内部依次应用选项
    │
    ↓
   params := NewQuestionParams()
   for _, opt := range options {
       opt(params)  // 执行函数，修改 params
   }
```

### 4.3 配置函数示例

```go
// 基础配置（伪代码）
func WithCode(code Code) QuestionOption {
    return func(p *QuestionParams) { p.code = code }
}

func WithStem(stem string) QuestionOption {
    return func(p *QuestionParams) { p.stem = stem }
}

func WithRequired(required bool) QuestionOption {
    return func(p *QuestionParams) { p.required = required }
}

// 复杂配置
func WithOptions(options []Option) QuestionOption {
    return func(p *QuestionParams) { p.options = options }
}

func WithValidationRules(rules []ValidationRule) QuestionOption {
    return func(p *QuestionParams) { p.validationRules = rules }
}
```

> **查看完整实现**：[internal/apiserver/domain/survey/questionnaire/factory.go](../../internal/apiserver/domain/survey/questionnaire/factory.go)

### 4.4 模式价值

**✅ 可读性**：自解释的配置

```go
// 清晰表达意图
question, _ := NewQuestion(TypeRadio,
    WithCode(meta.NewCode("Q1")),
    WithStem("您的性别？"),
    WithRequired(true),
    WithOptions([]Option{
        NewOption("M", "男", 0),
        NewOption("F", "女", 0),
    }),
)
```

**✅ 灵活性**：只配置需要的

```go
// 最小配置
question1, _ := NewQuestion(TypeText,
    WithCode(meta.NewCode("name")),
    WithStem("姓名"),
)

// 完整配置
question2, _ := NewQuestion(TypeText,
    WithCode(meta.NewCode("name")),
    WithStem("姓名"),
    WithRequired(true),
    WithValidationRules([]ValidationRule{
        NewMinLengthRule(2),
        NewMaxLengthRule(20),
    }),
    WithHelpText("请输入真实姓名"),
)
```

**✅ 向后兼容**：新增配置不破坏现有代码

```go
// 新增 WithDescription() 配置函数
func WithDescription(desc string) QuestionOption {
    return func(p *QuestionParams) { p.description = desc }
}

// 旧代码无需修改，继续工作
question, _ := NewQuestion(TypeRadio,
    WithCode("Q1"),
    WithStem("问题1"),
)

// 新代码可以使用新配置
question, _ := NewQuestion(TypeRadio,
    WithCode("Q1"),
    WithStem("问题1"),
    WithDescription("新增的描述"),  // 新增
)
```

**对比其他语言**：

| 语言 | 常用模式 | 示例 |
|-----|---------|------|
| **Java** | Builder 模式 | `Question.builder().code("Q1").stem("问题").build()` |
| **Python** | 关键字参数 | `Question(code="Q1", stem="问题", required=True)` |
| **Go** | 函数式选项 | `NewQuestion(TypeRadio, WithCode("Q1"), WithStem("问题"))` |

---

## 5. 领域服务模式（Domain Service Pattern）

### 5.1 设计思想

**核心问题**：如何避免聚合根臃肿？

***反模式：胖聚合根***

```go
// ❌ 所有逻辑都在聚合根中
type Questionnaire struct {
    // ... 字段
}

// 生命周期管理
func (q *Questionnaire) Publish() error { /* 50行代码 */ }
func (q *Questionnaire) Unpublish() error { /* 40行代码 */ }
func (q *Questionnaire) Archive() error { /* 30行代码 */ }

// 版本管理
func (q *Questionnaire) IncrementMajorVersion() { /* 20行代码 */ }
func (q *Questionnaire) IncrementMinorVersion() { /* 20行代码 */ }
func (q *Questionnaire) IncrementPatchVersion() { /* 20行代码 */ }

// 问题管理
func (q *Questionnaire) AddQuestion(...) error { /* 30行代码 */ }
func (q *Questionnaire) RemoveQuestion(...) error { /* 25行代码 */ }
func (q *Questionnaire) ReplaceQuestions(...) error { /* 40行代码 */ }

// 验证
func (q *Questionnaire) ValidateForPublish() error { /* 60行代码 */ }

// 结果：聚合根 500+ 行，难以维护 ❌
```

### 5.2 领域服务方案

```text
┌───────────────────────────────────────────────────┐
│        领域服务模式架构图                          │
└───────────────────────────────────────────────────┘

      Questionnaire 聚合根（轻量）
            │
            │ 只保留基本属性和简单方法
            │
    ┌───────┴───────────────────────────┐
    │                                   │
    ↓                                   ↓
领域对象               复杂业务逻辑独立为领域服务
    │                                   │
    ├─ 属性                             ├─ LifecycleService
    ├─ 基本 Getter                      │   (生命周期管理)
    ├─ 简单验证                         │
    └─ 无状态行为                       ├─ VersioningService
                                       │   (版本管理)
                                       │
                                       ├─ QuestionManagerService
                                       │   (问题管理)
                                       │
                                       ├─ BaseInfoService
                                       │   (基础信息管理)
                                       │
                                       └─ ValidatorService
                                           (发布前验证)

              每个服务 100-150 行，职责清晰 ✅
```

### 5.3 五大领域服务

#### 5.3.1 LifecycleService（生命周期服务）

**职责**：管理问卷的状态转换

```go
// 生命周期服务（伪代码）
type LifecycleService struct{}

func (s *LifecycleService) Publish(q *Questionnaire) error {
    // 1. 检查当前状态
    if q.status == StatusPublished {
        return errors.New("already published")
    }
    
    // 2. 状态转换
    q.status = StatusPublished
    q.publishedAt = time.Now()
    
    // 3. 发布领域事件
    q.AddDomainEvent(QuestionnairePublishedEvent{...})
    return nil
}

func (s *LifecycleService) Unpublish(q *Questionnaire) error { ... }
func (s *LifecycleService) Archive(q *Questionnaire) error { ... }
```

> **查看完整实现**：[internal/apiserver/domain/survey/questionnaire/lifecycle.go](../../internal/apiserver/domain/survey/questionnaire/lifecycle.go)

#### 5.3.2 VersioningService（版本服务）

**职责**：管理语义化版本（x.y.z）

```go
// 版本服务（伪代码）
type VersioningService struct{}

func (s *VersioningService) IncrementMajorVersion(q *Questionnaire) {
    // 1.0.0 → 2.0.0
    q.version.major++
    q.version.minor = 0
    q.version.patch = 0
}

func (s *VersioningService) IncrementMinorVersion(q *Questionnaire) {
    // 1.0.0 → 1.1.0
    q.version.minor++
    q.version.patch = 0
}

func (s *VersioningService) IncrementPatchVersion(q *Questionnaire) {
    // 1.0.0 → 1.0.1
    q.version.patch++
}
```

> **查看完整实现**：[internal/apiserver/domain/survey/questionnaire/versioning.go](../../internal/apiserver/domain/survey/questionnaire/versioning.go)

#### 5.3.3 其他领域服务

| 服务 | 职责 | 主要方法 |
|-----|------|---------|
| **QuestionManagerService** | 问题管理 | AddQuestion()<br>RemoveQuestion()<br>ReplaceQuestions() |
| **BaseInfoService** | 基础信息 | UpdateTitle()<br>UpdateDescription()<br>UpdateCoverImage() |
| **ValidatorService** | 业务验证 | ValidateForPublish()<br>ValidateQuestions() |

### 5.4 模式价值

**✅ 单一职责**：每个服务专注一个方面

**✅ 可测试性**：服务可以独立测试

```go
// 测试生命周期服务
func TestLifecycleService_Publish(t *testing.T) {
    service := NewLifecycleService()
    q := createTestQuestionnaire()
    
    err := service.Publish(q)
    
    assert.NoError(t, err)
    assert.Equal(t, StatusPublished, q.GetStatus())
}
```

**✅ 复用性**：服务可以在不同场景复用

```go
// 在应用服务中使用
func (app *PublishService) Publish(ctx context.Context, code string) error {
    q := app.repo.FindByCode(ctx, code)
    
    // 复用领域服务
    app.validator.ValidateForPublish(q)      // 验证
    app.lifecycleService.Publish(q)          // 发布
    app.versioningService.IncrementMinorVersion(q)  // 版本+1
    
    return app.repo.Update(ctx, q)
}
```

**领域服务 vs 应用服务对比**：

| 特性 | 领域服务 | 应用服务 |
|-----|---------|---------|
| **位置** | Domain Layer | Application Layer |
| **职责** | 业务逻辑 | 编排 + DTO 转换 + 事务 |
| **依赖** | 只依赖领域对象 | 依赖领域层 + 基础设施层 |
| **状态** | 无状态（纯函数） | 无状态 |
| **示例** | Lifecycle, Versioning | QuestionnaireCreationService |

---

## 6. 适配器模式（Adapter Pattern）

### 6.1 设计思想

**核心问题**：如何让 Validation 子域校验 AnswerSheet 的答案，但又不让两者直接依赖？

**问题分析**：

```text
❌ 直接依赖的问题：

┌────────────────┐         ┌─────────────────┐
│  Validation    │ ◀────── │  AnswerSheet    │
│  子域          │  依赖   │  聚合           │
│                │         │                 │
│  需要校验 ──────────────▶ │  AnswerValue    │
│  AnswerValue   │         │  接口           │
└────────────────┘         └─────────────────┘

问题：
1. Validation 依赖 AnswerSheet → 耦合 ❌
2. Validation 无法用于其他场景 ❌
3. 测试困难（需要构造完整的 AnswerSheet）❌
```

### 6.2 适配器方案

```text
✅ 适配器模式解决方案：

┌────────────────────────────────────────────────────┐
│            Validation 子域                         │
│                                                    │
│  定义接口                                          │
│  ValidatableValue {                               │
│    IsEmpty() bool                                 │
│    AsString() string                              │
│    AsNumber() (float64, error)                   │
│    AsArray() []string                            │
│  }                                                │
└────────────────┬───────────────────────────────────┘
                 │ 需要实现
                 │
    ┌────────────┴──────────────┐
    │                           │
    ↓                           ↓
┌─────────────────┐   ┌──────────────────┐
│AnswerSheet 聚合 │   │ 其他需要校验的    │
│                 │   │ 聚合（未来）      │
│AnswerValue      │   │                  │
│接口             │   │                  │
└────────┬────────┘   └──────────────────┘
         │
         │ 通过适配器实现 ValidatableValue
         ↓
┌──────────────────────────────┐
│  AnswerValueAdapter          │
│                              │
│  - answerValue: AnswerValue  │
│                              │
│  + IsEmpty() bool            │
│  + AsString() string         │
│  + AsNumber() float64        │
│  + AsArray() []string        │
└──────────────────────────────┘
```

### 6.3 适配器实现

```go
// 适配器（伪代码）
type AnswerValueAdapter struct {
    answerValue AnswerValue  // 持有被适配对象
}

// 实现 ValidatableValue 接口
func (a *AnswerValueAdapter) IsEmpty() bool {
    raw := a.answerValue.Raw()
    // 根据类型判断是否为空
    switch v := raw.(type) {
    case string:
        return v == ""
    case []string:
        return len(v) == 0
    default:
        return raw == nil
    }
}

func (a *AnswerValueAdapter) AsString() string {
    raw := a.answerValue.Raw()
    // 类型转换逻辑
    return fmt.Sprintf("%v", raw)
}

func (a *AnswerValueAdapter) AsNumber() (float64, error) {
    raw := a.answerValue.Raw()
    // 类型转换逻辑
    if num, ok := raw.(float64); ok {
        return num, nil
    }
    return 0, errors.New("not a number")
}

func (a *AnswerValueAdapter) AsArray() []string {
    raw := a.answerValue.Raw()
    // 类型转换逻辑
    if arr, ok := raw.([]string); ok {
        return arr
    }
    return []string{}
}
```

> **查看完整实现**：[internal/apiserver/domain/survey/answersheet/validation_adapter.go](../../internal/apiserver/domain/survey/answersheet/validation_adapter.go)

### 6.4 使用流程

```text
┌──────────────────────────────────────────────────┐
│        适配器模式使用流程                         │
└──────────────────────────────────────────────────┘

1️⃣ 创建答案
    │
    ↓
  answerValue := NewStringValue("张三")
  answer := NewAnswer(..., answerValue, ...)

2️⃣ 通过适配器包装
    │
    ↓
  validatableValue := NewAnswerValueAdapter(answer.Value())

3️⃣ 传给 Validation 子域校验
    │
    ↓
  validator := NewDefaultValidator()
  result := validator.ValidateValue(
      validatableValue,  // Validation 只看到接口
      question.GetValidationRules(),
  )

4️⃣ 处理校验结果
    │
    ↓
  if !result.IsValid() {
      // 处理错误
  }
```

### 6.5 模式价值

**✅ 解耦**：Validation 不知道 AnswerValue 的存在

**✅ 复用**：Validation 可以校验任何实现 ValidatableValue 的类型

```go
// 未来可以校验其他聚合
type OtherValueAdapter struct {
    value OtherValue
}

func (a *OtherValueAdapter) IsEmpty() bool { ... }
// 实现 ValidatableValue 接口

// 使用同一个 Validator
validator.ValidateValue(NewOtherValueAdapter(otherValue), rules)
```

**✅ 单向依赖**：

```text
AnswerSheet ───依赖───▶ Validation
   (通过接口)

Validation ─✗─不依赖─✗─▶ AnswerSheet
```

---

## 7. 策略模式（Strategy Pattern）

### 7.1 设计思想

**核心问题**：如何实现可扩展的校验规则？

**传统方案的问题**：

```go
// ❌ 传统方式：所有逻辑在一个函数中
func Validate(value string, rule ValidationRule) error {
    switch rule.Type {
    case "required":
        if value == "" {
            return errors.New("必填")
        }
    case "min_length":
        if utf8.RuneCountInString(value) < rule.Params.(int) {
            return errors.New("太短")
        }
    case "max_length":
        if utf8.RuneCountInString(value) > rule.Params.(int) {
            return errors.New("太长")
        }
    // ... 更多规则 → 函数越来越长 ❌
    default:
        return errors.New("unknown rule")
    }
}
```

### 7.2 策略模式方案

```text
┌───────────────────────────────────────────────────┐
│           策略模式架构图                           │
└───────────────────────────────────────────────────┘

    定义策略接口
         │
         ↓
    ┌─────────────────────────────┐
    │ ValidationStrategy 接口      │
    │                             │
    │ Validate(value, rule) error │
    └─────────────────────────────┘
         ↑
         │ 实现
         │
    ┌────┴────┬─────┬─────┬─────┬─────┐
    │         │     │     │     │     │
    ↓         ↓     ↓     ↓     ↓     ↓
Required  MinLength MaxLength MinValue MaxValue Pattern
Strategy  Strategy  Strategy  Strategy Strategy Strategy
  │         │         │         │         │        │
  │         │         │         │         │        │
  └─────────┴─────────┴─────────┴─────────┴────────┘
                      │
                      ↓
            Validator 领域服务
                 (使用策略)
                      │
                      ↓
          根据规则类型选择对应策略执行
```

### 7.3 实现要点

***步骤 1：定义策略接口***

```go
// 策略接口（伪代码）
type ValidationStrategy interface {
    Validate(value ValidatableValue, rule ValidationRule) error
}
```

***步骤 2：实现各个策略***

```go
// 必填策略（伪代码）
type RequiredStrategy struct{}

func (s *RequiredStrategy) Validate(value ValidatableValue, rule ValidationRule) error {
    if value.IsEmpty() {
        return errors.New("此项为必填项")
    }
    return nil
}

// 最小长度策略（伪代码）
type MinLengthStrategy struct{}

func (s *MinLengthStrategy) Validate(value ValidatableValue, rule ValidationRule) error {
    str := value.AsString()
    length := utf8.RuneCountInString(str)
    minLength := rule.GetParams().(int)
    
    if length < minLength {
        return fmt.Errorf("长度不能少于%d个字符", minLength)
    }
    return nil
}

// ... 其他策略
```

> **查看完整实现**：[internal/apiserver/domain/survey/validation/](../../internal/apiserver/domain/survey/validation/)

***步骤 3：注册策略***

```go
// 各策略在 init() 中自动注册（伪代码）
func init() {
    RegisterStrategy(RuleTypeRequired, &RequiredStrategy{})
    RegisterStrategy(RuleTypeMinLength, &MinLengthStrategy{})
    // ...
}
```

***步骤 4：Validator 使用策略***

```go
// Validator 领域服务（伪代码）
func (v *DefaultValidator) ValidateValue(
    value ValidatableValue,
    rules []ValidationRule,
) ValidationResult {
    errors := []ValidationError{}
    
    for _, rule := range rules {
        // 根据规则类型获取策略
        strategy, ok := GetStrategy(rule.GetType())
        if !ok {
            continue
        }
        
        // 执行策略
        if err := strategy.Validate(value, rule); err != nil {
            errors = append(errors, NewValidationError(rule.GetType(), err.Error()))
        }
    }
    
    return NewValidationResult(errors)
}
```

### 7.4 模式价值

**✅ 开闭原则**：新增策略只需 3 步

1. 实现 ValidationStrategy 接口
2. 在 init() 中注册
3. 定义规则类型和工厂方法

```go
// 新增日期范围策略（示例）
type DateRangeStrategy struct{}

func (s *DateRangeStrategy) Validate(value ValidatableValue, rule ValidationRule) error {
    // 校验逻辑
}

func init() {
    RegisterStrategy(RuleTypeDateRange, &DateRangeStrategy{})
}
```

**✅ 单一职责**：每个策略只负责一种校验

**✅ 可测试性**：可以单独测试每个策略

```go
func TestRequiredStrategy(t *testing.T) {
    strategy := &RequiredStrategy{}
    value := &MockValidatableValue{empty: true}
    rule := NewRequiredRule()
    
    err := strategy.Validate(value, rule)
    
    assert.Error(t, err)
}
```

---

## 8. 模式协作关系

### 8.1 Question 创建的完整流程

```text
┌─────────────────────────────────────────────────────────────┐
│     Question 创建流程：5种模式协作                           │
└─────────────────────────────────────────────────────────────┘

1️⃣ 函数式选项模式
    │
    ↓
  NewQuestion(TypeRadio,
      WithCode("Q1"),           ← 函数式选项
      WithStem("问题1"),
      WithRequired(true),
  )
    │
    ↓
2️⃣ 参数容器模式
    │
    ↓
  params := NewQuestionParams()
  for _, opt := range options {
      opt(params)  // 应用选项，填充参数容器
  }
    │
    ↓
3️⃣ 注册器模式
    │
    ↓
  factory := questionRegistry[TypeRadio]  // 从注册表查找工厂
    │
    ↓
4️⃣ 工厂模式
    │
    ↓
  question := factory(params)  // 工厂函数创建对象
    │
    ↓
5️⃣ 领域服务模式（创建后使用）
    │
    ↓
  validator.ValidateForPublish(questionnaire)  // 验证
  lifecycle.Publish(questionnaire)             // 发布
```

### 8.2 答案校验的完整流程

```text
┌─────────────────────────────────────────────────────────────┐
│     答案校验流程：3种模式协作                                 │
└─────────────────────────────────────────────────────────────┘

1️⃣ 工厂模式（简单工厂）
    │
    ↓
  answerValue := CreateAnswerValueFromRaw(TypeText, "张三")
    │
    ↓
2️⃣ 适配器模式
    │
    ↓
  validatableValue := NewAnswerValueAdapter(answerValue)
    │
    ↓
3️⃣ 策略模式
    │
    ↓
  validator.ValidateValue(validatableValue, rules)
    │
    ├─ 遍历规则
    │   └─ rule1: RuleTypeRequired
    │       └─ strategy1 := GetStrategy(RuleTypeRequired)
    │           └─ strategy1.Validate(value, rule1)
    │   └─ rule2: RuleTypeMinLength
    │       └─ strategy2 := GetStrategy(RuleTypeMinLength)
    │           └─ strategy2.Validate(value, rule2)
    │   └─ rule3: RuleTypePattern
    │       └─ strategy3 := GetStrategy(RuleTypePattern)
    │           └─ strategy3.Validate(value, rule3)
    ↓
  返回 ValidationResult
```

### 8.3 模式组合价值

**单个模式的局限性**：

* 只用工厂模式 → 创建逻辑简单，但无法灵活配置
* 只用策略模式 → 算法可扩展，但管理困难
* 只用适配器模式 → 接口解耦，但缺少创建和执行逻辑

**组合后的优势**：

* ✅ **创建灵活**：注册器 + 工厂 + 参数容器 + 函数式选项
* ✅ **逻辑清晰**：领域服务分离职责
* ✅ **易于扩展**：策略模式 + 注册器模式
* ✅ **松耦合**：适配器模式解耦子域

---

## 9. 设计原则体现

### 9.1 SOLID 原则

| 原则 | 体现位置 | 说明 |
|-----|---------|------|
| **S 单一职责** | 领域服务分离<br>Assembler 独立 | 每个类只有一个变化原因 |
| **O 开闭原则** | 注册器模式<br>策略模式 | 对扩展开放，对修改关闭<br>新增题型/策略无需修改现有代码 |
| **L 里氏替换** | Question 接口<br>ValidationStrategy 接口 | 子类可以替换父类 |
| **I 接口隔离** | ValidatableValue 接口 | 接口小而专注，不强迫实现不需要的方法 |
| **D 依赖倒置** | Validation 依赖接口<br>应用服务依赖 Repository 接口 | 依赖抽象而非具体实现 |

### 9.2 DDD 设计原则

| 原则 | 体现位置 | 说明 |
|-----|---------|------|
| **聚合边界** | Questionnaire 聚合<br>AnswerSheet 聚合 | 一致性边界明确 |
| **领域服务** | Lifecycle, Validator... | 无状态的领域逻辑 |
| **值对象** | Code, Version, ValidationRule | 不可变，可替换 |
| **子域划分** | Survey 子域<br>Validation 子域 | 按业务能力划分 |

### 9.3 Clean Architecture 原则

```text
┌──────────────────────────────────────────────┐
│         依赖方向（由外向内）                  │
└──────────────────────────────────────────────┘

Interface Layer (HTTP/gRPC)
    │ 依赖
    ↓
Application Layer (应用服务)
    │ 依赖
    ↓
Domain Layer (领域对象 + 领域服务)
    │ 依赖接口
    ↓
Infrastructure Layer (Repository 实现)
```

**价值**：

* ✅ 领域层独立，不依赖框架和数据库
* ✅ 测试友好，可以 Mock 基础设施层
* ✅ 业务逻辑集中在领域层

---

## 10. 模式选择指南

### 10.1 何时使用注册器模式？

**✅ 使用场景**：

* 有多种类型需要管理（5+ 种）
* 类型可能扩展
* 每种类型的创建逻辑不同

**❌ 不使用场景**：

* 类型固定且少（≤ 3 种）
* 简单的类型映射（用 switch-case 更直观）

**示例**：

* ✅ Question 题型（6 种，可能增加）
* ✅ ValidationStrategy（8 种，可能增加）
* ❌ AnswerValue（4 种，固定，用简单工厂）

### 10.2 何时使用领域服务？

**✅ 使用场景**：

* 逻辑涉及多个实体
* 逻辑不属于某个实体
* 聚合根方法超过 300 行

**❌ 不使用场景**：

* 简单的实体操作
* 无状态计算（用值对象方法）

**示例**：

* ✅ Questionnaire 的发布验证（涉及多个问题）
* ✅ 版本管理（复杂逻辑）
* ❌ Answer 的简单操作（直接在聚合根）

### 10.3 何时使用适配器模式？

**✅ 使用场景**：

* 需要连接两个不兼容的接口
* 需要解耦两个子域
* 接口需要复用到多个场景

**❌ 不使用场景**：

* 接口已经兼容
* 只在一个地方使用

**示例**：

* ✅ AnswerValueAdapter（连接 AnswerSheet 和 Validation）
* ❌ DTO 转换（直接转换即可，无需适配器）

### 10.4 模式复杂度对比

| 模式 | 复杂度 | 学习成本 | 维护成本 | 扩展性 |
|-----|-------|---------|---------|-------|
| 注册器模式 | ⭐⭐⭐ | 中 | 低 | ⭐⭐⭐⭐⭐ |
| 工厂模式 | ⭐⭐ | 低 | 低 | ⭐⭐⭐ |
| 参数容器 | ⭐⭐ | 低 | 低 | ⭐⭐⭐⭐ |
| 函数式选项 | ⭐⭐⭐ | 中 | 低 | ⭐⭐⭐⭐⭐ |
| 领域服务 | ⭐⭐ | 低 | 低 | ⭐⭐⭐⭐ |
| 适配器模式 | ⭐⭐⭐ | 中 | 中 | ⭐⭐⭐⭐ |
| 策略模式 | ⭐⭐⭐ | 中 | 低 | ⭐⭐⭐⭐⭐ |

---

## 11. 总结

### 11.1 核心设计理念

Survey 子域的设计遵循以下核心理念：

1. **简单优先**：AnswerSheet 用简单工厂，Questionnaire 用注册器
2. **按需设计**：根据复杂度选择合适的模式
3. **开闭原则**：通过注册器和策略模式实现
4. **解耦**：通过接口和适配器实现子域独立
5. **可测试**：每个组件都可以独立测试

### 11.2 模式应用总结图

```text
┌───────────────────────────────────────────────────────────┐
│            Survey 子域设计模式总结                         │
└───────────────────────────────────────────────────────────┘

                    架构分层
                       │
        ┌──────────────┼──────────────┐
        │              │              │
   Interface      Application      Domain
    Layer           Layer          Layer
        │              │              │
        │              │              ↓
        │              │      ┌───────────────┐
        │              │      │ Questionnaire │
        │              │      │  (复杂设计)   │
        │              │      │               │
        │              │      │ • 注册器      │
        │              │      │ • 工厂        │
        │              │      │ • 参数容器    │
        │              │      │ • 函数式选项  │
        │              │      │ • 领域服务    │
        │              │      └───────────────┘
        │              │              │
        │              │              ↓
        │              │      ┌───────────────┐
        │              │      │ AnswerSheet   │
        │              │      │  (简单设计)   │
        │              │      │               │
        │              │      │ • 简单工厂    │
        │              │      │ • 适配器      │
        │              │      └───────────────┘
        │              │              │
        │              │              ↓
        │              │      ┌───────────────┐
        │              │      │  Validation   │
        │              │      │  (策略设计)   │
        │              │      │               │
        │              │      │ • 策略模式    │
        │              │      │ • 注册器      │
        │              │      │ • 领域服务    │
        │              │      └───────────────┘
        │              │
        └──────────────┴──────────────┘
                       │
                  统一原则
                       │
            SOLID + DDD + Clean
```

### 11.3 关键价值

通过这 7 种设计模式的组合应用，Survey 子域实现了：

* ✅ **高扩展性**：新增题型、答案类型、校验策略都非常简单
* ✅ **低耦合**：各个子域通过接口解耦
* ✅ **高内聚**：每个模块职责清晰
* ✅ **易测试**：每个组件都可以独立测试
* ✅ **可维护**：代码结构清晰，易于理解和修改

---

## 12. 下一步阅读

* **[11-04-07 扩展指南](./11-04-07-扩展指南.md)** - 完整的题型扩展实战示例

---

> **相关文档**：
>
> * [Survey 子域设计系列](./11-04-Survey子域设计系列.md) - 系列文档索引
> * [11-04-01 Survey 子域架构总览](./11-04-01-Survey子域架构总览.md) - 架构设计
> * [11-04-02 Questionnaire 聚合设计](./11-04-02-Questionnaire聚合设计.md) - 题型设计
> * [11-04-03 AnswerSheet 聚合设计](./11-04-03-AnswerSheet聚合设计.md) - 答案设计
> * [11-04-04 Validation 子域设计](./11-04-04-Validation子域设计.md) - 校验设计
> * [11-04-05 应用服务层设计](./11-04-05-应用服务层设计.md) - 应用服务层
