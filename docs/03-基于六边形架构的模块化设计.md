# ğŸ”· åŸºäºå…­è¾¹å½¢æ¶æ„çš„æ¨¡å—åŒ–è®¾è®¡

## ğŸ“‹ ç›®å½•

- [å…­è¾¹å½¢æ¶æ„æ¦‚è¿°](#hexagonal-architecture-overview)
- [ç«¯å£ä¸é€‚é…å™¨è®¾è®¡](#ports-adapters-design)
- [é¢†åŸŸå±‚è®¾è®¡](#domain-layer-design)
- [åº”ç”¨æœåŠ¡å±‚è®¾è®¡](#application-service-design)
- [æ¨¡å—åŒ–ç³»ç»Ÿè®¾è®¡](#modular-system-design)
- [ä¾èµ–æ³¨å…¥å®¹å™¨](#dependency-injection-container)

## ğŸ¯ å…­è¾¹å½¢æ¶æ„æ¦‚è¿° {#hexagonal-architecture-overview}

æœ¬ç³»ç»Ÿé‡‡ç”¨å…­è¾¹å½¢æ¶æ„ï¼ˆHexagonal Architectureï¼‰ï¼Œä¹Ÿç§°ä¸ºç«¯å£å’Œé€‚é…å™¨æ¶æ„ï¼ˆPorts and Adaptersï¼‰ï¼Œå®ç°äº†ä¸šåŠ¡é€»è¾‘ä¸å¤–éƒ¨ä¾èµ–çš„å®Œå…¨è§£è€¦ã€‚

### ğŸ—ï¸ æ¶æ„å±‚æ¬¡å›¾

```mermaid
graph TB
    subgraph "å¤–éƒ¨ä¸–ç•Œ External World"
        REST[REST å®¢æˆ·ç«¯]
        CLI[CLI å·¥å…·]
        DB[(æ•°æ®åº“)]
        CACHE[(ç¼“å­˜)]
        MSG[æ¶ˆæ¯é˜Ÿåˆ—]
    end
    
    subgraph "é€‚é…å™¨å±‚ Adapters"
        subgraph "å…¥ç«™é€‚é…å™¨ Driving Adapters"
            RESTADP[REST Handler<br/>internal/apiserver/adapters/driving/restful]
            CLIADP[CLI Handler]
        end
        
        subgraph "å‡ºç«™é€‚é…å™¨ Driven Adapters"
            MYSQLADP[MySQL Repository<br/>internal/apiserver/adapters/driven/mysql]
            MONGOADP[MongoDB Repository]
            REDISADP[Redis Adapter]
        end
    end
    
    subgraph "ç«¯å£å±‚ Ports"
        subgraph "å…¥ç«™ç«¯å£ Driving Ports"
            USERPORT[User Service Port<br/>internal/apiserver/domain/user/port]
            AUTHPORT[Auth Service Port]
        end
        
        subgraph "å‡ºç«™ç«¯å£ Driven Ports"
            REPOPORT[Repository Port<br/>internal/apiserver/domain/user/port/repository.go]
            CACHEPORT[Cache Port]
        end
    end
    
    subgraph "æ ¸å¿ƒä¸šåŠ¡å±‚ Core Business"
        subgraph "åº”ç”¨æœåŠ¡å±‚ Application"
            USERAPP[User Application Services<br/>internal/apiserver/application/user]
            AUTHAPP[Auth Application Services]
        end
        
        subgraph "é¢†åŸŸå±‚ Domain"
            USERDOMAIN[User Domain<br/>internal/apiserver/domain/user]
            AUTHDOMAIN[Auth Domain]
        end
    end
    
    %% å¤–éƒ¨åˆ°å…¥ç«™é€‚é…å™¨
    REST --> RESTADP
    CLI --> CLIADP
    
    %% å…¥ç«™é€‚é…å™¨åˆ°å…¥ç«™ç«¯å£
    RESTADP --> USERPORT
    RESTADP --> AUTHPORT
    CLIADP --> USERPORT
    
    %% å…¥ç«™ç«¯å£åˆ°åº”ç”¨æœåŠ¡
    USERPORT --> USERAPP
    AUTHPORT --> AUTHAPP
    
    %% åº”ç”¨æœåŠ¡åˆ°é¢†åŸŸ
    USERAPP --> USERDOMAIN
    AUTHAPP --> AUTHDOMAIN
    
    %% åº”ç”¨æœåŠ¡åˆ°å‡ºç«™ç«¯å£
    USERAPP --> REPOPORT
    AUTHAPP --> REPOPORT
    USERAPP --> CACHEPORT
    
    %% å‡ºç«™ç«¯å£åˆ°å‡ºç«™é€‚é…å™¨
    REPOPORT --> MYSQLADP
    REPOPORT --> MONGOADP
    CACHEPORT --> REDISADP
    
    %% å‡ºç«™é€‚é…å™¨åˆ°å¤–éƒ¨
    MYSQLADP --> DB
    MONGOADP --> DB
    REDISADP --> CACHE
    
    style USERDOMAIN fill:#e8f5e8
    style USERAPP fill:#e3f2fd
    style USERPORT fill:#fff3e0
    style RESTADP fill:#f3e5f5
```

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **ä¾èµ–å€’ç½®**: ä¸šåŠ¡é€»è¾‘ä¸ä¾èµ–å¤–éƒ¨æŠ€æœ¯å®ç°
2. **ç«¯å£æŠ½è±¡**: é€šè¿‡æ¥å£å®šä¹‰ä¸šåŠ¡è¾¹ç•Œ
3. **é€‚é…å™¨éš”ç¦»**: å¤–éƒ¨æŠ€æœ¯å˜åŒ–ä¸å½±å“ä¸šåŠ¡é€»è¾‘
4. **æµ‹è¯•å‹å¥½**: å¯ä»¥è½»æ¾æ›¿æ¢å¤–éƒ¨ä¾èµ–è¿›è¡Œæµ‹è¯•

## ğŸ”Œ ç«¯å£ä¸é€‚é…å™¨è®¾è®¡ {#ports-adapters-design}

### ğŸ“¥ å…¥ç«™ç«¯å£è®¾è®¡

å…¥ç«™ç«¯å£å®šä¹‰äº†å¤–éƒ¨ä¸–ç•Œè°ƒç”¨ä¸šåŠ¡é€»è¾‘çš„æ¥å£å¥‘çº¦ã€‚

#### 1. ç”¨æˆ·æœåŠ¡ç«¯å£

```go
// internal/apiserver/domain/user/port/service.go

// UserCreator ç”¨æˆ·åˆ›å»ºæ¥å£
type UserCreator interface {
    CreateUser(ctx context.Context, req UserCreateRequest) (*UserResponse, error)
}

// UserQueryer ç”¨æˆ·æŸ¥è¯¢æ¥å£
type UserQueryer interface {
    GetUser(ctx context.Context, req UserIDRequest) (*UserResponse, error)
    GetUserByUsername(ctx context.Context, username string) (*UserResponse, error)
    ListUsers(ctx context.Context, page, pageSize int) (*UserListResponse, error)
}

// UserEditor ç”¨æˆ·ç¼–è¾‘æ¥å£
type UserEditor interface {
    UpdateBasicInfo(ctx context.Context, req UserBasicInfoRequest) (*UserResponse, error)
    UpdateAvatar(ctx context.Context, req UserAvatarRequest) error
}

// PasswordChanger å¯†ç ç®¡ç†æ¥å£
type PasswordChanger interface {
    ChangePassword(ctx context.Context, req UserPasswordChangeRequest) error
}

// UserActivator ç”¨æˆ·çŠ¶æ€ç®¡ç†æ¥å£
type UserActivator interface {
    ActivateUser(ctx context.Context, req UserIDRequest) error
    BlockUser(ctx context.Context, req UserIDRequest) error
    DeactivateUser(ctx context.Context, req UserIDRequest) error
}
```

#### 2. è¯·æ±‚å“åº”æ•°æ®ä¼ è¾“å¯¹è±¡

```go
// UserCreateRequest åˆ›å»ºç”¨æˆ·è¯·æ±‚
type UserCreateRequest struct {
    Username     string `json:"username" valid:"required"`
    Password     string `json:"password" valid:"required,stringlength(6|50)"`
    Nickname     string `json:"nickname" valid:"required"`
    Email        string `json:"email" valid:"required,email"`
    Phone        string `json:"phone" valid:"required"`
    Introduction string `json:"introduction" valid:"optional"`
}

// UserResponse ç”¨æˆ·å“åº”
type UserResponse struct {
    ID           uint64 `json:"id"`
    Username     string `json:"username"`
    Nickname     string `json:"nickname"`
    Phone        string `json:"phone"`
    Avatar       string `json:"avatar"`
    Introduction string `json:"introduction"`
    Email        string `json:"email"`
    Status       string `json:"status"`
    CreatedAt    string `json:"created_at"`
    UpdatedAt    string `json:"updated_at"`
}
```

### ğŸ“¤ å‡ºç«™ç«¯å£è®¾è®¡

å‡ºç«™ç«¯å£å®šä¹‰äº†ä¸šåŠ¡é€»è¾‘å¯¹å¤–éƒ¨ä¾èµ–çš„æ¥å£éœ€æ±‚ã€‚

#### 1. ä»“å‚¨ç«¯å£

```go
// internal/apiserver/domain/user/port/repository.go

// UserRepository ç”¨æˆ·å­˜å‚¨åº“æ¥å£ï¼ˆå‡ºç«™ç«¯å£ï¼‰
type UserRepository interface {
    // åŸºç¡€ CRUD æ“ä½œ
    Save(ctx context.Context, user *user.User) error
    FindByID(ctx context.Context, id user.UserID) (*user.User, error)
    Update(ctx context.Context, user *user.User) error
    Remove(ctx context.Context, id user.UserID) error

    // æŸ¥è¯¢æ“ä½œ
    FindByUsername(ctx context.Context, username string) (*user.User, error)
    FindByPhone(ctx context.Context, phone string) (*user.User, error)
    FindByEmail(ctx context.Context, email string) (*user.User, error)
    FindAll(ctx context.Context, limit, offset int) ([]*user.User, error)

    // å­˜åœ¨æ€§æ£€æŸ¥
    ExistsByID(ctx context.Context, id user.UserID) bool
    ExistsByUsername(ctx context.Context, username string) bool
    ExistsByEmail(ctx context.Context, email string) bool
    ExistsByPhone(ctx context.Context, phone string) bool

    // ç»Ÿè®¡æ“ä½œ
    Count(ctx context.Context) (int64, error)
    CountByStatus(ctx context.Context, status user.Status) (int64, error)

    // æ‰¹é‡æ“ä½œ
    FindByIDs(ctx context.Context, ids []user.UserID) ([]*user.User, error)
    FindByStatus(ctx context.Context, status user.Status, limit, offset int) ([]*user.User, error)
}
```

### ğŸ”„ å…¥ç«™é€‚é…å™¨å®ç°

å…¥ç«™é€‚é…å™¨å°†å¤–éƒ¨è¯·æ±‚è½¬æ¢ä¸ºä¸šåŠ¡è°ƒç”¨ã€‚

#### 1. RESTé€‚é…å™¨

```go
// internal/apiserver/adapters/driving/restful/user/handler.go

// Handler ç”¨æˆ·HTTPå¤„ç†å™¨
type Handler struct {
    restful.BaseHandler
    userCreator         port.UserCreator
    userQueryer         port.UserQueryer
    userEditor          port.UserEditor
    userActivator       port.UserActivator
    userPasswordChanger port.PasswordChanger
}

// NewHandler åˆ›å»ºç”¨æˆ·å¤„ç†å™¨
func NewHandler(
    userCreator port.UserCreator,
    userQueryer port.UserQueryer,
    userEditor port.UserEditor,
    userActivator port.UserActivator,
    userPasswordChanger port.PasswordChanger,
) *Handler {
    return &Handler{
        userCreator:         userCreator,
        userQueryer:         userQueryer,
        userEditor:          userEditor,
        userActivator:       userActivator,
        userPasswordChanger: userPasswordChanger,
    }
}

// GetUser è·å–ç”¨æˆ·
func (h *Handler) GetUser(c *gin.Context) {
    var req port.UserIDRequest
    if err := h.BindQuery(c, &req); err != nil {
        h.ErrorResponse(c, err)
        return
    }

    userResponse, err := h.userQueryer.GetUser(c.Request.Context(), req)
    if err != nil {
        h.ErrorResponse(c, err)
        return
    }

    h.SuccessResponse(c, userResponse)
}
```

### ğŸ”§ å‡ºç«™é€‚é…å™¨å®ç°

å‡ºç«™é€‚é…å™¨å°†ä¸šåŠ¡è°ƒç”¨è½¬æ¢ä¸ºå¤–éƒ¨æœåŠ¡è°ƒç”¨ã€‚

#### 1. æ³›å‹åŸºç¡€ä»“å‚¨

```go
// internal/apiserver/adapters/driven/mysql/base.go

// æ³›å‹ç»“æ„ä½“ï¼Œæ”¯æŒä»»æ„å®ç°äº† Syncable çš„å®ä½“ç±»å‹
type BaseRepository[T Syncable] struct {
    db *gorm.DB
}

func NewBaseRepository[T Syncable](db *gorm.DB) BaseRepository[T] {
    return BaseRepository[T]{db: db}
}

// CreateAndSync å°†å®ä½“æ’å…¥æ•°æ®åº“ï¼Œå¹¶é€šè¿‡å›è°ƒå‡½æ•°åŒæ­¥å­—æ®µå› domain å±‚
func (r *BaseRepository[T]) CreateAndSync(ctx context.Context, entity T, sync func(T)) error {
    result := r.db.WithContext(ctx).Create(entity)
    if result.Error != nil {
        return result.Error
    }
    sync(entity)
    return nil
}

// UpdateAndSync æ›´æ–°å®ä½“å¹¶åŒæ­¥æ—¶é—´æˆ³ç­‰å­—æ®µ
func (r *BaseRepository[T]) UpdateAndSync(ctx context.Context, entity T, sync func(T)) error {
    result := r.db.WithContext(ctx).Save(entity)
    if result.Error != nil {
        return result.Error
    }
    sync(entity)
    return nil
}
```

#### 2. ç”¨æˆ·ä»“å‚¨å®ç°

```go
// internal/apiserver/adapters/driven/mysql/user/repo.go

// Repository ç”¨æˆ·å­˜å‚¨åº“å®ç°
type Repository struct {
    mysql.BaseRepository[*UserEntity]
    mapper *UserMapper
}

// NewRepository åˆ›å»ºç”¨æˆ·å­˜å‚¨åº“
func NewRepository(db *gorm.DB) port.UserRepository {
    return &Repository{
        BaseRepository: mysql.NewBaseRepository[*UserEntity](db),
        mapper:         NewUserMapper(),
    }
}

// Save ä¿å­˜ç”¨æˆ·
func (r *Repository) Save(ctx context.Context, userDomain *user.User) error {
    entity := r.mapper.ToEntity(userDomain)
    return r.CreateAndSync(ctx, entity, func(saved *UserEntity) {
        userDomain.SetID(user.NewUserID(saved.ID))
        userDomain.SetCreatedAt(saved.CreatedAt)
        userDomain.SetUpdatedAt(saved.UpdatedAt)
    })
}

// FindByUsername æ ¹æ®ç”¨æˆ·åæŸ¥è¯¢ç”¨æˆ·
func (r *Repository) FindByUsername(ctx context.Context, username string) (*user.User, error) {
    var entity UserEntity
    err := r.BaseRepository.FindByField(ctx, &entity, "username", username)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, pkgerrors.WithCode(code.ErrUserNotFound, "user not found: %s", username)
        }
        return nil, err
    }
    return r.mapper.ToDomain(&entity), nil
}
```

## ğŸ›ï¸ é¢†åŸŸå±‚è®¾è®¡ {#domain-layer-design}

é¢†åŸŸå±‚åŒ…å«ä¸šåŠ¡çš„æ ¸å¿ƒé€»è¾‘ï¼Œå®Œå…¨ç‹¬ç«‹äºå¤–éƒ¨æŠ€æœ¯å®ç°ã€‚

### ğŸ“Š é¢†åŸŸæ¨¡å‹

```go
// internal/apiserver/domain/user/model.go

// User ç”¨æˆ·èšåˆæ ¹
type User struct {
    id           UserID
    username     string
    password     string
    nickname     string
    avatar       string
    email        string
    phone        string
    introduction string
    status       Status
    createdAt    time.Time
    updatedAt    time.Time
}

// ä¸šåŠ¡æ–¹æ³•
func (u *User) ChangePassword(newPassword string) error {
    if len(newPassword) < 6 {
        return errors.WithCode(code.ErrUserBasicInfoInvalid, 
            "password must be at least 6 characters")
    }

    hashedPassword, err := auth.Encrypt(newPassword)
    if err != nil {
        return errors.WithCode(code.ErrEncrypt, "failed to encrypt password")
    }

    u.password = hashedPassword
    u.updatedAt = time.Now()
    return nil
}

func (u *User) ValidatePassword(password string) bool {
    err := auth.Compare(u.password, password)
    return err == nil
}

func (u *User) IsActive() bool {
    return u.status == StatusActive
}

func (u *User) Block() error {
    if u.status == StatusBlocked {
        return errors.WithCode(code.ErrUserStatusInvalid, "user is already blocked")
    }
    u.status = StatusBlocked
    return nil
}
```

### ğŸ—ï¸ å»ºé€ è€…æ¨¡å¼

```go
// internal/apiserver/domain/user/builder.go

// UserBuilder ç”¨æˆ·å»ºé€ è€…
type UserBuilder struct {
    user *User
}

// NewUserBuilder åˆ›å»ºç”¨æˆ·å»ºé€ è€…
func NewUserBuilder() *UserBuilder {
    return &UserBuilder{
        user: &User{
            status:    StatusInit,
            createdAt: time.Now(),
            updatedAt: time.Now(),
        },
    }
}

// WithUsername è®¾ç½®ç”¨æˆ·å
func (b *UserBuilder) WithUsername(username string) *UserBuilder {
    b.user.username = username
    return b
}

// WithPassword è®¾ç½®å¯†ç ï¼ˆè‡ªåŠ¨åŠ å¯†ï¼‰
func (b *UserBuilder) WithPassword(password string) *UserBuilder {
    hashedPassword, _ := auth.Encrypt(password)
    b.user.password = hashedPassword
    return b
}

// Build æ„å»ºç”¨æˆ·å¯¹è±¡
func (b *UserBuilder) Build() *User {
    return b.user
}
```

### ğŸ“‹ å€¼å¯¹è±¡

```go
// internal/apiserver/domain/user/vo.go

// UserID ç”¨æˆ·IDå€¼å¯¹è±¡
type UserID struct {
    value uint64
}

func NewUserID(value uint64) UserID {
    return UserID{value: value}
}

func (id UserID) Value() uint64 {
    return id.value
}

func (id UserID) IsZero() bool {
    return id.value == 0
}

// Status ç”¨æˆ·çŠ¶æ€å€¼å¯¹è±¡
type Status int

const (
    StatusInit Status = iota
    StatusActive
    StatusInactive
    StatusBlocked
)

func (s Status) String() string {
    switch s {
    case StatusInit:
        return "init"
    case StatusActive:
        return "active"
    case StatusInactive:
        return "inactive"
    case StatusBlocked:
        return "blocked"
    default:
        return "unknown"
    }
}
```

## ğŸ”§ åº”ç”¨æœåŠ¡å±‚è®¾è®¡ {#application-service-design}

åº”ç”¨æœåŠ¡å±‚åè°ƒé¢†åŸŸå¯¹è±¡å’Œå¤–éƒ¨ä¾èµ–ï¼Œå®ç°ç”¨ä¾‹é€»è¾‘ã€‚

### ğŸ­ ç”¨æˆ·åˆ›å»ºå™¨

```go
// internal/apiserver/application/user/creator.go

// UserCreator ç”¨æˆ·åˆ›å»ºå™¨
type UserCreator struct {
    userRepo port.UserRepository
}

// NewUserCreator åˆ›å»ºç”¨æˆ·åˆ›å»ºå™¨
func NewUserCreator(userRepo port.UserRepository) port.UserCreator {
    return &UserCreator{userRepo: userRepo}
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (c *UserCreator) CreateUser(ctx context.Context, req port.UserCreateRequest) (*port.UserResponse, error) {
    // 1. ä¸šåŠ¡è§„åˆ™éªŒè¯
    if c.usernameExists(ctx, req.Username) {
        return nil, errors.WithCode(code.ErrUserAlreadyExists, "username already exists")
    }
    if c.emailExists(ctx, req.Email) {
        return nil, errors.WithCode(code.ErrUserAlreadyExists, "email already exists")
    }
    if c.phoneExists(ctx, req.Phone) {
        return nil, errors.WithCode(code.ErrUserAlreadyExists, "phone already exists")
    }

    // 2. åˆ›å»ºé¢†åŸŸå¯¹è±¡
    user := user.NewUserBuilder().
        WithUsername(req.Username).
        WithPassword(req.Password).
        WithNickname(req.Nickname).
        WithEmail(req.Email).
        WithPhone(req.Phone).
        WithStatus(user.StatusInit).
        WithIntroduction(req.Introduction).
        Build()

    // 3. æŒä¹…åŒ–
    if err := c.userRepo.Save(ctx, user); err != nil {
        return nil, fmt.Errorf("failed to save user: %w", err)
    }

    // 4. è¿”å›å“åº”
    return &port.UserResponse{
        ID:           user.ID().Value(),
        Username:     user.Username(),
        Nickname:     user.Nickname(),
        Avatar:       user.Avatar(),
        Introduction: user.Introduction(),
        Email:        user.Email(),
        Phone:        user.Phone(),
        Status:       user.Status().String(),
        CreatedAt:    user.CreatedAt().Format(time.DateTime),
        UpdatedAt:    user.UpdatedAt().Format(time.DateTime),
    }, nil
}

// ç§æœ‰è¾…åŠ©æ–¹æ³•
func (c *UserCreator) usernameExists(ctx context.Context, username string) bool {
    return c.userRepo.ExistsByUsername(ctx, username)
}

func (c *UserCreator) emailExists(ctx context.Context, email string) bool {
    return c.userRepo.ExistsByEmail(ctx, email)
}

func (c *UserCreator) phoneExists(ctx context.Context, phone string) bool {
    return c.userRepo.ExistsByPhone(ctx, phone)
}
```

### ğŸ” åº”ç”¨æœåŠ¡ç‰¹ç‚¹

1. **è–„å±‚è®¾è®¡**: ä¸åŒ…å«ä¸šåŠ¡é€»è¾‘ï¼Œåªåè°ƒè°ƒç”¨
2. **äº‹åŠ¡ç®¡ç†**: å¤„ç†è·¨èšåˆçš„äº‹åŠ¡æ“ä½œ
3. **æ•°æ®è½¬æ¢**: åœ¨ç«¯å£æ•°æ®å’Œé¢†åŸŸå¯¹è±¡é—´è½¬æ¢
4. **å¼‚å¸¸å¤„ç†**: å°†é¢†åŸŸå¼‚å¸¸è½¬æ¢ä¸ºé€‚å½“çš„é”™è¯¯å“åº”

## ğŸ“¦ æ¨¡å—åŒ–ç³»ç»Ÿè®¾è®¡ {#modular-system-design}

### ğŸ—ï¸ æ¨¡å—æ¥å£

```go
// internal/apiserver/module/module.go

// Module æ¨¡å—æ¥å£
type Module interface {
    Initialize(params ...interface{}) error
    CheckHealth() error
    Cleanup() error
    ModuleInfo() ModuleInfo
}

// ModuleInfo æ¨¡å—ä¿¡æ¯
type ModuleInfo struct {
    Name        string
    Version     string
    Description string
}
```

### ğŸ‘¤ ç”¨æˆ·æ¨¡å—å®ç°

```go
// internal/apiserver/module/user/module.go

// Module ç”¨æˆ·æ¨¡å—
type Module struct {
    // repository å±‚
    UserRepo port.UserRepository

    // handler å±‚
    UserHandler *userAdapter.Handler

    // service å±‚
    UserCreator         port.UserCreator
    UserQueryer         port.UserQueryer
    UserEditor          port.UserEditor
    UserActivator       port.UserActivator
    UserPasswordChanger port.PasswordChanger
}

// Initialize åˆå§‹åŒ–æ¨¡å—
func (m *Module) Initialize(params ...interface{}) error {
    db := params[0].(*gorm.DB)
    if db == nil {
        return errors.WithCode(code.ErrModuleInitializationFailed, 
            "database connection is nil")
    }

    // åˆå§‹åŒ– repository å±‚
    m.UserRepo = userInfra.NewRepository(db)

    // åˆå§‹åŒ– service å±‚
    m.UserCreator = userApp.NewUserCreator(m.UserRepo)
    m.UserQueryer = userApp.NewUserQueryer(m.UserRepo)
    m.UserEditor = userApp.NewUserEditor(m.UserRepo)
    m.UserActivator = userApp.NewUserActivator(m.UserRepo)
    m.UserPasswordChanger = userApp.NewPasswordChanger(m.UserRepo)

    // åˆå§‹åŒ– handler å±‚
    m.UserHandler = userAdapter.NewHandler(
        m.UserCreator,
        m.UserQueryer,
        m.UserEditor,
        m.UserActivator,
        m.UserPasswordChanger,
    )

    return nil
}

// ModuleInfo è¿”å›æ¨¡å—ä¿¡æ¯
func (m *Module) ModuleInfo() module.ModuleInfo {
    return module.ModuleInfo{
        Name:        "user",
        Version:     "1.0.0",
        Description: "ç”¨æˆ·ç®¡ç†æ¨¡å—",
    }
}
```

### ğŸ”„ æ¨¡å—ç»„è£…æµç¨‹

```mermaid
sequenceDiagram
    participant Container as å®¹å™¨
    participant Module as ç”¨æˆ·æ¨¡å—
    participant Repo as ä»“å‚¨å±‚
    participant App as åº”ç”¨å±‚
    participant Handler as å¤„ç†å™¨å±‚
    
    Container->>Module: Initialize(db)
    Module->>Repo: NewRepository(db)
    Repo-->>Module: UserRepository
    
    Module->>App: NewUserCreator(repo)
    App-->>Module: UserCreator
    
    Module->>App: NewUserQueryer(repo)
    App-->>Module: UserQueryer
    
    Module->>Handler: NewHandler(services...)
    Handler-->>Module: UserHandler
    
    Module-->>Container: æ¨¡å—åˆå§‹åŒ–å®Œæˆ
```

## ğŸ›ï¸ ä¾èµ–æ³¨å…¥å®¹å™¨ {#dependency-injection-container}

### ğŸ“¦ å®¹å™¨ç»“æ„

```go
// internal/apiserver/container/container.go

// Container ä¸»å®¹å™¨
type Container struct {
    // åŸºç¡€è®¾æ–½
    mysqlDB     *gorm.DB
    mongoClient *mongo.Client
    mongoDB     string

    // ä¸šåŠ¡æ¨¡å—
    AuthModule *authModule.Module
    UserModule *userModule.Module

    // å®¹å™¨çŠ¶æ€
    initialized bool
}

// NewContainer åˆ›å»ºå®¹å™¨
func NewContainer(mysqlDB *gorm.DB, mongoClient *mongo.Client, mongoDB string) *Container {
    return &Container{
        mysqlDB:     mysqlDB,
        mongoClient: mongoClient,
        mongoDB:     mongoDB,
        initialized: false,
    }
}

// Initialize åˆå§‹åŒ–å®¹å™¨
func (c *Container) Initialize() error {
    if c.initialized {
        return nil
    }

    // åˆå§‹åŒ–ç”¨æˆ·æ¨¡å—
    if err := c.initUserModule(); err != nil {
        return fmt.Errorf("failed to initialize user module: %w", err)
    }

    // åˆå§‹åŒ–è®¤è¯æ¨¡å—
    if err := c.initAuthModule(); err != nil {
        return fmt.Errorf("failed to initialize auth module: %w", err)
    }

    c.initialized = true
    return nil
}
```

### ğŸ”§ æ¨¡å—åˆå§‹åŒ–

```go
// initUserModule åˆå§‹åŒ–ç”¨æˆ·æ¨¡å—
func (c *Container) initUserModule() error {
    userModule := userModule.NewModule()
    if err := userModule.Initialize(c.mysqlDB); err != nil {
        return fmt.Errorf("failed to initialize user module: %w", err)
    }

    c.UserModule = userModule
    return nil
}

// å¥åº·æ£€æŸ¥
func (c *Container) HealthCheck(ctx context.Context) error {
    // æ£€æŸ¥MySQLè¿æ¥
    if c.mysqlDB != nil {
        sqlDB, err := c.mysqlDB.DB()
        if err != nil {
            return fmt.Errorf("failed to get mysql db: %w", err)
        }
        if err := sqlDB.PingContext(ctx); err != nil {
            return fmt.Errorf("mysql ping failed: %w", err)
        }
    }

    return nil
}
```

## ğŸ¯ æ¶æ„ä¼˜åŠ¿æ€»ç»“

### 1. **ä¸šåŠ¡é€»è¾‘ä¿æŠ¤**

- æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ä¸å¤–éƒ¨æŠ€æœ¯å®Œå…¨éš”ç¦»
- é¢†åŸŸæ¨¡å‹ä¸“æ³¨äºä¸šåŠ¡è§„åˆ™è¡¨è¾¾
- æŠ€æœ¯æ ˆå˜æ›´ä¸å½±å“ä¸šåŠ¡é€»è¾‘

### 2. **é«˜åº¦å¯æµ‹è¯•æ€§**

```go
// é¢†åŸŸå±‚æµ‹è¯• - æ— éœ€å¤–éƒ¨ä¾èµ–
func TestUser_ChangePassword(t *testing.T) {
    user := user.NewUserBuilder().
        WithUsername("test").
        WithPassword("oldpass").
        Build()
    
    err := user.ChangePassword("newpass")
    assert.NoError(t, err)
}

// åº”ç”¨å±‚æµ‹è¯• - ä½¿ç”¨Mockä»“å‚¨
func TestUserCreator_CreateUser(t *testing.T) {
    mockRepo := &MockUserRepository{}
    creator := NewUserCreator(mockRepo)
    
    // æµ‹è¯•ä¸šåŠ¡é€»è¾‘
    resp, err := creator.CreateUser(ctx, req)
    assert.NoError(t, err)
}
```

### 3. **çµæ´»çš„æŠ€æœ¯é€‰æ‹©**

- æ•°æ®åº“å¯ä»¥ä»MySQLåˆ‡æ¢åˆ°PostgreSQL
- ç¼“å­˜å¯ä»¥ä»Redisåˆ‡æ¢åˆ°Memcached
- Webæ¡†æ¶å¯ä»¥ä»Ginåˆ‡æ¢åˆ°Echo

### 4. **æ¸…æ™°çš„ä¾èµ–æ–¹å‘**

```mermaid
graph LR
    ADAPTER[é€‚é…å™¨] --> PORT[ç«¯å£]
    PORT --> APP[åº”ç”¨æœåŠ¡]
    APP --> DOMAIN[é¢†åŸŸ]
    
    style DOMAIN fill:#e8f5e8
    style APP fill:#e3f2fd
    style PORT fill:#fff3e0
    style ADAPTER fill:#f3e5f5
```

ä¾èµ–æ–¹å‘å§‹ç»ˆæŒ‡å‘å†…éƒ¨ï¼Œå¤–å±‚ä¾èµ–å†…å±‚ï¼Œå†…å±‚ä¸ä¾èµ–å¤–å±‚ã€‚

### 5. **æ¨¡å—åŒ–æ‰©å±•**

- æ–°ä¸šåŠ¡åŠŸèƒ½ä»¥æ¨¡å—å½¢å¼æ·»åŠ 
- æ¨¡å—é—´é€šè¿‡æ˜ç¡®çš„æ¥å£äº¤äº’
- æ”¯æŒç‹¬ç«‹å¼€å‘å’Œæµ‹è¯•
