# 12-02 计分与解读规则设计（策略 + 职责链）（V2）

> 版本：V2.0
> 范围：scale 子域（量表计分与解读），assessment 子域部分（InterpretReport 生成）

---

## 1. 背景

量表评估通常包含：

1. 题目级计分；
2. 因子级聚合；
3. 总体解读（风险分级、结论、建议）；
4. 报告生成。

不同量表差异集中在“题目计分”和“因子聚合”规则上。
V2 采用：

* **策略模式**：题目计分、因子聚合；
* **职责链模式**：评估整体流程；
* **ReportFactory**：在 assessment 子域生成 InterpretReport。

---

## 2. 题目级计分策略

### 2.1 ScoringConfig

```go
type ScoreStrategyCode string

const (
    ScoreStrategyNone        ScoreStrategyCode = "none"
    ScoreStrategyOptionMap   ScoreStrategyCode = "option_map"
    ScoreStrategyNumberValue ScoreStrategyCode = "number_value"
)

type ScoringConfig struct {
    Strategy ScoreStrategyCode
    Params   map[string]string
}
```

### 2.2 策略接口

```go
type QuestionScoringStrategy interface {
    Code() survey.ScoreStrategyCode
    Score(q *survey.Question, item *survey.AnswerItem) (float64, error)
}
```

典型实现：

* OptionMapScoring：选项 → 分值映射；
* NumberValueScoring：数值题直接取值。

---

## 3. 因子级聚合策略

### 3.1 Factor 配置

```go
type FactorScoreStrategyCode string

const (
    FactorScoreStrategySum   FactorScoreStrategyCode = "sum"
    FactorScoreStrategyAvg   FactorScoreStrategyCode = "avg"
)

type Factor struct {
    Code        FactorCode
    Name        string
    QuestionIDs []survey.QuestionID
    Strategy    FactorScoreStrategyCode
    Params      map[string]string
}
```

### 3.2 策略接口

```go
type FactorScoringStrategy interface {
    Code() FactorScoreStrategyCode
    Aggregate(f Factor, itemScores map[survey.QuestionID]float64) (float64, error)
}
```

---

## 4. EvalContext 与职责链

### 4.1 EvalContext

```go
type EvalContext struct {
    Scale         *MedicalScale
    Questionnaire *survey.Questionnaire
    Sheet         *survey.AnswerSheet

    ItemScores   map[survey.QuestionID]float64
    TotalScore   float64
    FactorScores []FactorScore

    Result *EvaluationResult
}
```

### 4.2 EvalStep 与 ChainEvaluator

```go
type EvalStep interface {
    Name() string
    Handle(ctx context.Context, c *EvalContext) error
}

type ChainEvaluator struct {
    steps []EvalStep
}

func (e *ChainEvaluator) Evaluate(
    ctx context.Context,
    scale *MedicalScale,
    questionnaire *survey.Questionnaire,
    sheet *survey.AnswerSheet,
) (*EvaluationResult, error) {
    c := &EvalContext{
        Scale:         scale,
        Questionnaire: questionnaire,
        Sheet:         sheet,
        ItemScores:    make(map[survey.QuestionID]float64),
    }

    for _, step := range e.steps {
        if err := step.Handle(ctx, c); err != nil {
            return nil, err
        }
    }

    return c.Result, nil
}
```

---

## 5. 三个核心 Step

### 5.1 RawScoreStep：题目原始分

职责：

* 遍历问卷题目；
* 使用 QuestionScoringFactory 获取策略；
* 计算并填充 `ItemScores`、`TotalScore`。

### 5.2 FactorScoreStep：因子分

职责：

* 遍历 Scale 的 Factor；
* 使用 FactorScoringFactory 获取策略；
* 聚合 `ItemScores` 生成 `FactorScores` 列表；
* 可调用内部函数计算因子级风险。

### 5.3 OverallInterpretStep：总体解读

职责：

* 根据总分、因子分和 `MedicalScale.rules` 生成：

  * 总体风险等级；
  * 综合结论与建议文案；
* 填充 `EvaluationResult`。

---

## 6. InterpretReport 的生成

为避免耦合：

* `scale.Evaluator` **只负责输出 EvaluationResult**；
* `assessment.ReportFactory` 生成 InterpretReport：

```go
type ReportFactory interface {
    Build(ass *Assessment, sc *MedicalScale, result *EvaluationResult) *InterpretReport
}
```

ReportFactory 中组合：

* Assessment 的基本信息（时间、Testee、来源等）；
* MedicalScale 的名称、因子定义；
* EvaluationResult 的分数与解释。

---

## 7. 在 qs-worker 中的使用

消费 AssessmentSubmittedEvent 时：

1. 加载 Assessment / Questionnaire / AnswerSheet / MedicalScale；
2. 调用 Evaluator 得到 EvaluationResult；
3. 更新 Assessment（总分、风险、状态等）；
4. 写入 AssessmentScore；
5. 通过 ReportFactory 生成 InterpretReport；
6. 保存 InterpretReport；
7. 发布 AssessmentInterpretedEvent。

---

## 8. 总结

V2 的计分与解读设计要点：

1. 策略模式封装题目计分与因子聚合规则；
2. 职责链将“原始分 → 因子分 → 总体解读”串起来；
3. scale 专注算法与规则，assessment 专注结果持久化与报告对象；
4. qs-apiserver 与 qs-worker 共用同一套 Evaluator，实现行为一致。

这套设计足以支撑多种量表的差异化计分需求，同时保证代码结构清晰、易扩展。
