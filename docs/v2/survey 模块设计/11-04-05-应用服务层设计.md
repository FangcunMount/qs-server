# 11-04-05 应用服务层设计

> **版本**：V3.0  
> **最后更新**：2025-11-26  
> **状态**：✅ 已实现并验证  
> **所属系列**：[Survey 子域设计系列](./11-04-Survey子域设计系列.md)

---

## 1. 应用服务层概览

### 1.1 应用服务层的职责

在 DDD 分层架构中，应用服务层（Application Layer）承担以下职责：

```text
┌─────────────────────────────────────────┐
│          Interface Layer                │  ← HTTP/gRPC 接口
│     (Controller/Handler/gRPC Service)   │
└──────────────┬──────────────────────────┘
               │ DTO 传递
               ↓
┌─────────────────────────────────────────┐
│        Application Layer                │  ← 应用服务层
│                                         │
│  职责：                                  │
│  • 编排领域对象和领域服务                │
│  • DTO ↔ 领域对象转换                   │
│  • 事务边界管理                         │
│  • 权限检查                             │
│  • 调用基础设施服务                      │
└──────────────┬──────────────────────────┘
               │ 领域对象
               ↓
┌─────────────────────────────────────────┐
│          Domain Layer                   │  ← 领域层
│  (Aggregate, Entity, Value Object,      │
│   Domain Service)                       │
└─────────────────────────────────────────┘
```

**关键原则**：

* ✅ **薄应用服务**：业务逻辑在领域层，应用服务只做编排
* ✅ **无状态**：应用服务不保存状态，只依赖领域对象
* ✅ **事务边界**：应用服务方法是事务边界
* ✅ **DTO 转换**：应用服务负责 DTO 与领域对象的转换

### 1.2 Survey 子域的应用服务

```text
Survey 子域应用服务
├── Questionnaire 应用服务（3个）
│   ├── QuestionnaireCreationService    (创建问卷)
│   ├── QuestionnairePublishService     (发布管理)
│   └── QuestionnaireQueryService       (查询问卷)
│
├── AnswerSheet 应用服务（3个）
│   ├── AnswerSheetSubmissionService    (提交答卷)
│   ├── AnswerSheetScoringService       (答卷计分)
│   └── AnswerSheetQueryService         (查询答卷)
│
└── 共享组件
    ├── DTO 定义                        (请求/响应对象)
    ├── Assembler                       (DTO ↔ 领域对象转换)
    └── Repository 接口                 (持久化接口)
```

---

## 2. Questionnaire 应用服务

### 2.1 QuestionnaireCreationService（创建问卷）

#### 2.1.1 服务定义

```go
// QuestionnaireCreationService 问卷创建服务（伪代码）
type QuestionnaireCreationService struct {
    questionnaireRepo QuestionnaireRepository
    validator         validation.Validator
}

func NewQuestionnaireCreationService(
    repo QuestionnaireRepository,
    validator validation.Validator,
) *QuestionnaireCreationService {
    return &QuestionnaireCreationService{
        questionnaireRepo: repo,
        validator:         validator,
    }
}
```

> **查看完整实现**：[internal/apiserver/application/questionnaire/creation_service.go](../../internal/apiserver/application/questionnaire/creation_service.go)

#### 2.1.2 创建问卷

**核心方法**：

```go
// CreateQuestionnaire 创建问卷（伪代码）
func (s *QuestionnaireCreationService) CreateQuestionnaire(
    ctx context.Context,
    dto CreateQuestionnaireDTO,
) (*QuestionnaireDTO, error) {
    // 1. DTO → 领域对象转换
    questions := make([]Question, len(dto.Questions))
    for i, qDTO := range dto.Questions {
        question, err := s.assembleQuestion(qDTO)
        if err != nil {
            return nil, err
        }
        questions[i] = question
    }
    
    // 2. 创建问卷聚合根
    questionnaire, err := questionnaire.NewQuestionnaire(
        meta.NewCode(dto.Code),
        dto.Title,
        dto.Description,
        questions,
    )
    if err != nil {
        return nil, err
    }
    
    // 3. 持久化
    if err := s.questionnaireRepo.Create(ctx, questionnaire); err != nil {
        return nil, err
    }
    
    // 4. 领域对象 → DTO 转换
    return s.toQuestionnaireDTO(questionnaire), nil
}
```

**职责分析**：

* ✅ DTO 转换：`assembleQuestion` 和 `toQuestionnaireDTO`
* ✅ 编排领域对象：调用 `NewQuestionnaire`
* ✅ 持久化：调用 Repository
* ❌ 不包含业务逻辑（业务逻辑在领域层）

#### 2.1.3 DTO 定义

```go
// CreateQuestionnaireDTO 创建问卷请求（伪代码）
type CreateQuestionnaireDTO struct {
    Code        string                `json:"code"`
    Title       string                `json:"title"`
    Description string                `json:"description"`
    Questions   []CreateQuestionDTO   `json:"questions"`
}

// CreateQuestionDTO 创建问题请求（伪代码）
type CreateQuestionDTO struct {
    Code             string                 `json:"code"`
    Type             string                 `json:"type"`
    Stem             string                 `json:"stem"`
    Required         bool                   `json:"required"`
    Options          []OptionDTO            `json:"options,omitempty"`
    ValidationRules  []ValidationRuleDTO    `json:"validation_rules,omitempty"`
    DisplayOrder     int                    `json:"display_order"`
}

// QuestionnaireDTO 问卷响应（伪代码）
type QuestionnaireDTO struct {
    ID          string           `json:"id"`
    Code        string           `json:"code"`
    Title       string           `json:"title"`
    Version     string           `json:"version"`
    Status      string           `json:"status"`
    Questions   []QuestionDTO    `json:"questions"`
    CreatedAt   time.Time        `json:"created_at"`
}
```

> **查看完整实现**：[internal/apiserver/application/questionnaire/dto.go](../../internal/apiserver/application/questionnaire/dto.go)

### 2.2 QuestionnairePublishService（发布管理）

#### 2.2.1 服务定义

```go
// QuestionnairePublishService 问卷发布服务（伪代码）
type QuestionnairePublishService struct {
    questionnaireRepo QuestionnaireRepository
    lifecycleService  questionnaire.LifecycleService
    validator         questionnaire.ValidatorService
}
```

> **查看完整实现**：[internal/apiserver/application/questionnaire/publish_service.go](../../internal/apiserver/application/questionnaire/publish_service.go)

#### 2.2.2 发布问卷

**核心方法**：

```go
// PublishQuestionnaire 发布问卷（伪代码）
func (s *QuestionnairePublishService) PublishQuestionnaire(
    ctx context.Context,
    code string,
) error {
    // 1. 查询问卷
    q, err := s.questionnaireRepo.FindByCode(ctx, code)
    if err != nil {
        return err
    }
    
    // 2. 发布前验证（调用领域服务）
    if err := s.validator.ValidateForPublish(q); err != nil {
        return errors.Wrap(err, "问卷验证失败")
    }
    
    // 3. 发布（调用领域服务）
    if err := s.lifecycleService.Publish(q); err != nil {
        return err
    }
    
    // 4. 持久化
    return s.questionnaireRepo.Update(ctx, q)
}
```

**关键点**：

* ✅ 调用**领域服务**进行业务操作（Validator, Lifecycle）
* ✅ 应用服务只做**编排**
* ✅ 事务边界在应用服务方法

#### 2.2.3 下线问卷

```go
// UnpublishQuestionnaire 下线问卷（伪代码）
func (s *QuestionnairePublishService) UnpublishQuestionnaire(
    ctx context.Context,
    code string,
) error {
    q, err := s.questionnaireRepo.FindByCode(ctx, code)
    if err != nil {
        return err
    }
    
    // 调用领域服务
    if err := s.lifecycleService.Unpublish(q); err != nil {
        return err
    }
    
    return s.questionnaireRepo.Update(ctx, q)
}
```

### 2.3 QuestionnaireQueryService（查询问卷）

#### 2.3.1 服务定义

```go
// QuestionnaireQueryService 问卷查询服务（伪代码）
type QuestionnaireQueryService struct {
    questionnaireRepo QuestionnaireRepository
}
```

> **查看完整实现**：[internal/apiserver/application/questionnaire/query_service.go](../../internal/apiserver/application/questionnaire/query_service.go)

#### 2.3.2 查询方法

```go
// GetByCode 根据编码查询（伪代码）
func (s *QuestionnaireQueryService) GetByCode(
    ctx context.Context,
    code string,
) (*QuestionnaireDTO, error) {
    q, err := s.questionnaireRepo.FindByCode(ctx, code)
    if err != nil {
        return nil, err
    }
    return s.toQuestionnaireDTO(q), nil
}

// ListPublished 查询已发布问卷（伪代码）
func (s *QuestionnaireQueryService) ListPublished(
    ctx context.Context,
    page, pageSize int,
) ([]*QuestionnaireDTO, int64, error) {
    questionnaires, total, err := s.questionnaireRepo.FindPublished(ctx, page, pageSize)
    if err != nil {
        return nil, 0, err
    }
    
    dtos := make([]*QuestionnaireDTO, len(questionnaires))
    for i, q := range questionnaires {
        dtos[i] = s.toQuestionnaireDTO(q)
    }
    
    return dtos, total, nil
}
```

**职责**：

* ✅ 简单的查询操作
* ✅ 领域对象 → DTO 转换
* ✅ 无复杂业务逻辑

---

## 3. AnswerSheet 应用服务

### 3.1 AnswerSheetSubmissionService（提交答卷）

#### 3.1.1 服务定义

```go
// AnswerSheetSubmissionService 答卷提交服务（伪代码）
type AnswerSheetSubmissionService struct {
    answerSheetRepo   AnswerSheetRepository
    questionnaireRepo QuestionnaireRepository
    validator         validation.Validator
}
```

> **查看完整实现**：[internal/apiserver/application/answersheet/submission_service.go](../../internal/apiserver/application/answersheet/submission_service.go)

#### 3.1.2 提交答卷

**核心方法**（最复杂的应用服务）：

```go
// SubmitAnswerSheet 提交答卷（伪代码）
func (s *AnswerSheetSubmissionService) SubmitAnswerSheet(
    ctx context.Context,
    dto SubmitAnswerSheetDTO,
) (*AnswerSheetDTO, error) {
    // 1. 查询问卷（验证问卷是否存在且已发布）
    q, err := s.questionnaireRepo.FindByCode(ctx, dto.QuestionnaireCode)
    if err != nil {
        return nil, err
    }
    if !q.IsPublished() {
        return nil, errors.New("问卷未发布")
    }
    
    // 2. 创建答案列表并校验
    answers := make([]Answer, 0, len(dto.Answers))
    for _, answerDTO := range dto.Answers {
        // 2.1 查找对应的问题
        question := q.FindQuestion(meta.NewCode(answerDTO.QuestionCode))
        if question == nil {
            return nil, fmt.Errorf("问题 %s 不存在", answerDTO.QuestionCode)
        }
        
        // 2.2 创建答案值
        answerValue, err := answersheet.CreateAnswerValueFromRaw(
            question.GetType(),
            answerDTO.Value,
        )
        if err != nil {
            return nil, err
        }
        
        // 2.3 校验答案（调用 Validation 子域）
        validatableValue := answersheet.NewAnswerValueAdapter(answerValue)
        result := s.validator.ValidateValue(
            validatableValue,
            question.GetValidationRules(),
        )
        if !result.IsValid() {
            return nil, s.formatValidationErrors(answerDTO.QuestionCode, result)
        }
        
        // 2.4 创建答案
        answer, err := answersheet.NewAnswer(
            meta.NewCode(answerDTO.QuestionCode),
            question.GetType(),
            answerValue,
            0, // 初始分数为0
        )
        if err != nil {
            return nil, err
        }
        
        answers = append(answers, answer)
    }
    
    // 3. 创建答卷聚合根
    sheet, err := answersheet.NewAnswerSheet(
        answersheet.NewQuestionnaireRef(
            q.GetCode().Value(),
            q.GetVersion().String(),
            q.GetTitle(),
        ),
        answersheet.NewFillerRef(dto.FillerID, dto.FillerType),
        answers,
        time.Now(),
    )
    if err != nil {
        return nil, err
    }
    
    // 4. 标记为已提交
    sheet.MarkAsSubmitted()
    
    // 5. 持久化
    if err := s.answerSheetRepo.Create(ctx, sheet); err != nil {
        return nil, err
    }
    
    // 6. 返回 DTO
    return s.toAnswerSheetDTO(sheet), nil
}
```

**职责分析**：

* ✅ **编排多个领域对象**：Questionnaire, AnswerSheet, Answer
* ✅ **跨聚合校验**：问卷是否发布、问题是否存在
* ✅ **调用子域服务**：Validation 子域的校验
* ✅ **DTO 转换**：请求 DTO → 领域对象 → 响应 DTO
* ✅ **事务边界**：整个方法是一个事务

#### 3.1.3 DTO 定义

```go
// SubmitAnswerSheetDTO 提交答卷请求（伪代码）
type SubmitAnswerSheetDTO struct {
    QuestionnaireCode string              `json:"questionnaire_code"`
    FillerID          int64               `json:"filler_id"`
    FillerType        string              `json:"filler_type"`
    Answers           []SubmitAnswerDTO   `json:"answers"`
}

// SubmitAnswerDTO 提交答案（伪代码）
type SubmitAnswerDTO struct {
    QuestionCode string `json:"question_code"`
    Value        any    `json:"value"`  // 原始值（string/number/[]string）
}

// AnswerSheetDTO 答卷响应（伪代码）
type AnswerSheetDTO struct {
    ID                string        `json:"id"`
    QuestionnaireCode string        `json:"questionnaire_code"`
    QuestionnaireTitle string       `json:"questionnaire_title"`
    FillerID          int64         `json:"filler_id"`
    Status            string        `json:"status"`
    Answers           []AnswerDTO   `json:"answers"`
    FilledAt          time.Time     `json:"filled_at"`
}
```

> **查看完整实现**：[internal/apiserver/application/answersheet/dto.go](../../internal/apiserver/application/answersheet/dto.go)

### 3.2 AnswerSheetScoringService（答卷计分）

#### 3.2.1 服务定义

```go
// AnswerSheetScoringService 答卷计分服务（伪代码）
type AnswerSheetScoringService struct {
    answerSheetRepo   AnswerSheetRepository
    questionnaireRepo QuestionnaireRepository
    scoreCalculator   calculation.ScoreCalculator  // Scale 子域服务
}
```

> **查看完整实现**：[internal/apiserver/application/answersheet/scoring_service.go](../../internal/apiserver/application/answersheet/scoring_service.go)

#### 3.2.2 计算分数

```go
// CalculateScore 计算答卷分数（伪代码）
func (s *AnswerSheetScoringService) CalculateScore(
    ctx context.Context,
    answerSheetID string,
) (*AnswerSheetDTO, error) {
    // 1. 查询答卷
    sheet, err := s.answerSheetRepo.FindByID(ctx, answerSheetID)
    if err != nil {
        return nil, err
    }
    
    // 2. 查询问卷（获取计算规则）
    q, err := s.questionnaireRepo.FindByCode(ctx, sheet.GetQuestionnaireRef().Code)
    if err != nil {
        return nil, err
    }
    
    // 3. 遍历每个答案，计算分数
    for _, answer := range sheet.GetAnswers() {
        question := q.FindQuestion(meta.NewCode(answer.QuestionCode()))
        if question == nil {
            continue
        }
        
        // 调用 Scale 子域的计算服务
        score := s.scoreCalculator.Calculate(
            answer.Value(),
            question.GetCalculationRules(),
        )
        
        // 更新答案分数
        sheet.UpdateAnswerScore(meta.NewCode(answer.QuestionCode()), score)
    }
    
    // 4. 持久化
    if err := s.answerSheetRepo.Update(ctx, sheet); err != nil {
        return nil, err
    }
    
    return s.toAnswerSheetDTO(sheet), nil
}
```

**职责**：

* ✅ 编排 AnswerSheet 和 Questionnaire
* ✅ 调用 Scale 子域服务计算分数
* ✅ 更新答卷分数

### 3.3 AnswerSheetQueryService（查询答卷）

#### 3.3.1 服务定义

```go
// AnswerSheetQueryService 答卷查询服务（伪代码）
type AnswerSheetQueryService struct {
    answerSheetRepo AnswerSheetRepository
}
```

> **查看完整实现**：[internal/apiserver/application/answersheet/query_service.go](../../internal/apiserver/application/answersheet/query_service.go)

#### 3.3.2 查询方法

```go
// GetByID 根据ID查询（伪代码）
func (s *AnswerSheetQueryService) GetByID(
    ctx context.Context,
    id string,
) (*AnswerSheetDTO, error) {
    sheet, err := s.answerSheetRepo.FindByID(ctx, id)
    if err != nil {
        return nil, err
    }
    return s.toAnswerSheetDTO(sheet), nil
}

// ListByFiller 查询填写人的答卷列表（伪代码）
func (s *AnswerSheetQueryService) ListByFiller(
    ctx context.Context,
    fillerID int64,
    page, pageSize int,
) ([]*AnswerSheetDTO, int64, error) {
    sheets, total, err := s.answerSheetRepo.FindByFiller(ctx, fillerID, page, pageSize)
    if err != nil {
        return nil, 0, err
    }
    
    dtos := make([]*AnswerSheetDTO, len(sheets))
    for i, sheet := range sheets {
        dtos[i] = s.toAnswerSheetDTO(sheet)
    }
    
    return dtos, total, nil
}
```

---

## 4. DTO 与领域对象转换（Assembler）

### 4.1 Assembler 模式

**职责**：负责 DTO 与领域对象之间的双向转换。

```text
┌─────────────────┐                  ┌─────────────────┐
│   Request DTO   │ ──────────────▶  │  Domain Object  │
│  (from client)  │   toEntity()     │   (Aggregate)   │
└─────────────────┘                  └─────────────────┘
                                              │
                                              │
┌─────────────────┐                          │
│  Response DTO   │ ◀──────────────────────  │
│  (to client)    │        toDTO()
└─────────────────┘
```

### 4.2 Question Assembler

```go
// QuestionAssembler Question 转换器（伪代码）
type QuestionAssembler struct {
    validator validation.Validator
}

// ToEntity DTO → 领域对象
func (a *QuestionAssembler) ToEntity(dto CreateQuestionDTO) (Question, error) {
    // 1. 转换基础属性
    opts := []QuestionOption{
        WithCode(meta.NewCode(dto.Code)),
        WithStem(dto.Stem),
        WithRequired(dto.Required),
        WithDisplayOrder(dto.DisplayOrder),
    }
    
    // 2. 转换选项（如果是选择题）
    if len(dto.Options) > 0 {
        options := make([]Option, len(dto.Options))
        for i, optDTO := range dto.Options {
            options[i] = questionnaire.NewOption(
                optDTO.Code,
                optDTO.Label,
                optDTO.Score,
            )
        }
        opts = append(opts, WithOptions(options))
    }
    
    // 3. 转换校验规则
    if len(dto.ValidationRules) > 0 {
        rules := make([]ValidationRule, len(dto.ValidationRules))
        for i, ruleDTO := range dto.ValidationRules {
            rules[i] = a.toValidationRule(ruleDTO)
        }
        opts = append(opts, WithValidationRules(rules))
    }
    
    // 4. 创建 Question
    return NewQuestion(TypeFromString(dto.Type), opts...)
}

// ToDTO 领域对象 → DTO
func (a *QuestionAssembler) ToDTO(question Question) QuestionDTO {
    return QuestionDTO{
        Code:         question.GetCode().Value(),
        Type:         question.GetType().Value(),
        Stem:         question.GetStem(),
        Required:     question.IsRequired(),
        Options:      a.optionsToDTO(question.GetOptions()),
        DisplayOrder: question.GetDisplayOrder(),
    }
}
```

> **查看完整实现**：[internal/apiserver/application/questionnaire/assembler.go](../../internal/apiserver/application/questionnaire/assembler.go)

### 4.3 AnswerSheet Assembler

```go
// AnswerSheetAssembler AnswerSheet 转换器（伪代码）
type AnswerSheetAssembler struct{}

// ToDTO 领域对象 → DTO
func (a *AnswerSheetAssembler) ToDTO(sheet *AnswerSheet) *AnswerSheetDTO {
    return &AnswerSheetDTO{
        ID:                 sheet.ID().Value(),
        QuestionnaireCode:  sheet.GetQuestionnaireRef().Code,
        QuestionnaireTitle: sheet.GetQuestionnaireRef().Title,
        FillerID:           sheet.GetFillerRef().ID,
        Status:             string(sheet.GetStatus()),
        Answers:            a.answersToDTO(sheet.GetAnswers()),
        FilledAt:           sheet.GetFilledAt(),
    }
}

// answersToDTO 答案列表 → DTO
func (a *AnswerSheetAssembler) answersToDTO(answers []Answer) []AnswerDTO {
    dtos := make([]AnswerDTO, len(answers))
    for i, answer := range answers {
        dtos[i] = AnswerDTO{
            QuestionCode: answer.QuestionCode(),
            QuestionType: answer.QuestionType(),
            Value:        answer.Value().Raw(),
            Score:        answer.Score(),
        }
    }
    return dtos
}
```

> **查看完整实现**：[internal/apiserver/application/answersheet/assembler.go](../../internal/apiserver/application/answersheet/assembler.go)

**Assembler 的价值**：

* ✅ **单一职责**：专门负责转换
* ✅ **复用性**：多个应用服务共享
* ✅ **可测试性**：独立测试转换逻辑
* ✅ **隔离变化**：DTO 变化不影响领域层

---

## 5. 事务边界管理

### 5.1 事务边界原则

**原则**：**一个应用服务方法 = 一个事务**

```go
// ✅ 正确：整个方法是一个事务
func (s *QuestionnairePublishService) PublishQuestionnaire(
    ctx context.Context,
    code string,
) error {
    // 事务开始
    tx, err := s.txManager.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback()  // 失败时回滚
    
    // 业务操作
    q, _ := s.questionnaireRepo.FindByCode(ctx, code)
    s.validator.ValidateForPublish(q)
    s.lifecycleService.Publish(q)
    s.questionnaireRepo.Update(ctx, q)
    
    // 事务提交
    return tx.Commit()
}
```

```go
// ❌ 错误：不要在领域层管理事务
func (q *Questionnaire) Publish() error {
    tx.Begin()  // ❌ 领域对象不应该知道事务
    // ...
    tx.Commit()
}
```

### 5.2 跨聚合事务

**场景**：提交答卷时需要查询问卷

```go
func (s *AnswerSheetSubmissionService) SubmitAnswerSheet(...) error {
    // 事务开始
    tx, _ := s.txManager.Begin(ctx)
    defer tx.Rollback()
    
    // 1. 查询 Questionnaire 聚合（只读）
    q, _ := s.questionnaireRepo.FindByCode(ctx, code)
    
    // 2. 创建 AnswerSheet 聚合（写入）
    sheet, _ := answersheet.NewAnswerSheet(...)
    s.answerSheetRepo.Create(ctx, sheet)
    
    // 事务提交
    return tx.Commit()
}
```

**原则**：

* ✅ 应用服务可以跨聚合协调
* ✅ 只在必要时使用事务（如涉及写操作）
* ✅ 避免长事务，尽快提交

### 5.3 最终一致性

**场景**：答卷提交后异步计分

```go
// 同步提交（伪代码）
func (s *SubmissionService) SubmitAnswerSheet(...) error {
    // 事务1：创建答卷（分数为0）
    sheet := answersheet.NewAnswerSheet(...)
    s.answerSheetRepo.Create(ctx, sheet)
    
    // 发布事件：答卷已提交
    s.eventBus.Publish(AnswerSheetSubmittedEvent{
        AnswerSheetID: sheet.ID(),
    })
    
    return nil
}

// 异步计分（事件处理器）
func (h *AnswerSheetEventHandler) HandleSubmitted(event AnswerSheetSubmittedEvent) {
    // 事务2：计算分数并更新
    s.scoringService.CalculateScore(ctx, event.AnswerSheetID)
}
```

**优点**：

* ✅ 提交快速响应（无需等待计分）
* ✅ 计分失败不影响提交
* ✅ 可以重试计分

---

## 6. 应用服务使用示例

### 6.1 在接口层调用应用服务

**gRPC Handler 示例**：

```go
// QuestionnaireHandler gRPC 处理器（伪代码）
type QuestionnaireHandler struct {
    creationService *QuestionnaireCreationService
    publishService  *QuestionnairePublishService
    queryService    *QuestionnaireQueryService
}

// CreateQuestionnaire gRPC 方法
func (h *QuestionnaireHandler) CreateQuestionnaire(
    ctx context.Context,
    req *pb.CreateQuestionnaireRequest,
) (*pb.CreateQuestionnaireResponse, error) {
    // 1. gRPC Request → DTO
    dto := CreateQuestionnaireDTO{
        Code:        req.Code,
        Title:       req.Title,
        Description: req.Description,
        Questions:   h.toQuestionDTOs(req.Questions),
    }
    
    // 2. 调用应用服务
    result, err := h.creationService.CreateQuestionnaire(ctx, dto)
    if err != nil {
        return nil, status.Error(codes.Internal, err.Error())
    }
    
    // 3. DTO → gRPC Response
    return &pb.CreateQuestionnaireResponse{
        Questionnaire: h.toProtoQuestionnaire(result),
    }, nil
}
```

**HTTP Handler 示例**：

```go
// QuestionnaireController HTTP 控制器（伪代码）
type QuestionnaireController struct {
    creationService *QuestionnaireCreationService
    publishService  *QuestionnairePublishService
    queryService    *QuestionnaireQueryService
}

// POST /questionnaires
func (c *QuestionnaireController) Create(ctx *gin.Context) {
    // 1. 解析 JSON → DTO
    var dto CreateQuestionnaireDTO
    if err := ctx.ShouldBindJSON(&dto); err != nil {
        ctx.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    // 2. 调用应用服务
    result, err := c.creationService.CreateQuestionnaire(ctx, dto)
    if err != nil {
        ctx.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    // 3. 返回 JSON
    ctx.JSON(201, result)
}

// POST /questionnaires/:code/publish
func (c *QuestionnaireController) Publish(ctx *gin.Context) {
    code := ctx.Param("code")
    
    // 调用应用服务
    if err := c.publishService.PublishQuestionnaire(ctx, code); err != nil {
        ctx.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    ctx.JSON(200, gin.H{"message": "发布成功"})
}
```

### 6.2 完整的提交答卷流程

```go
// 1. 客户端发送 HTTP 请求
POST /answer-sheets
{
  "questionnaire_code": "PHQ-9",
  "filler_id": 123,
  "filler_type": "self",
  "answers": [
    {"question_code": "Q1", "value": "2"},
    {"question_code": "Q2", "value": "1"},
    {"question_code": "Q3", "value": "小明"}
  ]
}

// 2. HTTP Handler 解析请求
var dto SubmitAnswerSheetDTO
ctx.ShouldBindJSON(&dto)

// 3. 调用应用服务
result, err := submissionService.SubmitAnswerSheet(ctx, dto)

// 4. 应用服务内部流程
// 4.1 查询问卷（验证是否存在）
q := questionnaireRepo.FindByCode(ctx, "PHQ-9")

// 4.2 创建并校验答案
for _, answerDTO := range dto.Answers {
    question := q.FindQuestion(answerDTO.QuestionCode)
    answerValue := CreateAnswerValueFromRaw(question.GetType(), answerDTO.Value)
    
    // 校验
    validatableValue := NewAnswerValueAdapter(answerValue)
    result := validator.ValidateValue(validatableValue, question.GetValidationRules())
    
    answer := NewAnswer(answerDTO.QuestionCode, question.GetType(), answerValue, 0)
}

// 4.3 创建答卷聚合根
sheet := NewAnswerSheet(questionnaireRef, fillerRef, answers, time.Now())
sheet.MarkAsSubmitted()

// 4.4 持久化
answerSheetRepo.Create(ctx, sheet)

// 5. 返回响应
ctx.JSON(201, result)
```

---

## 7. 应用服务设计原则总结

### 7.1 薄应用服务原则

**✅ 应用服务应该做的**：

* 编排领域对象和领域服务
* DTO 与领域对象转换
* 事务边界管理
* 调用基础设施服务（Repository, MessageQueue）
* 权限检查
* 日志记录

**❌ 应用服务不应该做的**：

* 包含业务逻辑（应在领域层）
* 直接操作数据库（应通过 Repository）
* 保存状态（应是无状态的）
* 包含计算逻辑（应在领域服务或值对象中）

### 7.2 示例对比

```go
// ❌ 错误：业务逻辑在应用服务
func (s *PublishService) PublishQuestionnaire(ctx context.Context, code string) error {
    q := s.repo.FindByCode(ctx, code)
    
    // ❌ 验证逻辑在应用服务（应该在领域服务）
    if len(q.Questions) == 0 {
        return errors.New("问卷必须包含问题")
    }
    for _, question := range q.Questions {
        if question.IsRequired && len(question.ValidationRules) == 0 {
            return errors.New("必填问题必须有校验规则")
        }
    }
    
    // ❌ 状态变更逻辑在应用服务（应该在领域服务）
    if q.Status == "published" {
        return errors.New("问卷已发布")
    }
    q.Status = "published"
    q.PublishedAt = time.Now()
    
    return s.repo.Update(ctx, q)
}
```

```go
// ✅ 正确：业务逻辑在领域层
func (s *PublishService) PublishQuestionnaire(ctx context.Context, code string) error {
    q := s.repo.FindByCode(ctx, code)
    
    // ✅ 调用领域服务进行验证
    if err := s.validator.ValidateForPublish(q); err != nil {
        return err
    }
    
    // ✅ 调用领域服务进行发布
    if err := s.lifecycleService.Publish(q); err != nil {
        return err
    }
    
    return s.repo.Update(ctx, q)
}
```

### 7.3 应用服务分层对比

| 层次 | 职责 | 示例 |
|-----|------|------|
| **Interface Layer** | 协议转换（HTTP/gRPC ↔ DTO） | `QuestionnaireController`, `QuestionnaireHandler` |
| **Application Layer** | 编排领域对象、DTO转换、事务 | `QuestionnaireCreationService` |
| **Domain Layer** | 业务逻辑、业务规则 | `Questionnaire`, `LifecycleService` |
| **Infrastructure Layer** | 技术实现（数据库、消息队列） | `QuestionnaireRepositoryImpl` |

---

## 8. 测试应用服务

### 8.1 单元测试示例

```go
// QuestionnaireCreationService 单元测试（伪代码）
func TestQuestionnaireCreationService_CreateQuestionnaire(t *testing.T) {
    // 1. 准备 Mock
    mockRepo := &MockQuestionnaireRepository{}
    mockValidator := &MockValidator{}
    service := NewQuestionnaireCreationService(mockRepo, mockValidator)
    
    // 2. 准备测试数据
    dto := CreateQuestionnaireDTO{
        Code:  "TEST-001",
        Title: "测试问卷",
        Questions: []CreateQuestionDTO{
            {Code: "Q1", Type: "radio", Stem: "问题1"},
        },
    }
    
    // 3. 设置 Mock 期望
    mockRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
    
    // 4. 执行测试
    result, err := service.CreateQuestionnaire(context.Background(), dto)
    
    // 5. 断言
    assert.NoError(t, err)
    assert.NotNil(t, result)
    assert.Equal(t, "TEST-001", result.Code)
    mockRepo.AssertExpectations(t)
}
```

### 8.2 集成测试示例

```go
// 集成测试（伪代码）
func TestSubmitAnswerSheet_Integration(t *testing.T) {
    // 1. 准备测试环境（真实数据库）
    db := setupTestDatabase()
    defer db.Close()
    
    // 2. 创建真实服务
    questionnaireRepo := NewQuestionnaireRepository(db)
    answerSheetRepo := NewAnswerSheetRepository(db)
    validator := NewDefaultValidator()
    service := NewAnswerSheetSubmissionService(
        answerSheetRepo,
        questionnaireRepo,
        validator,
    )
    
    // 3. 准备测试数据（先创建问卷）
    questionnaire := createTestQuestionnaire(questionnaireRepo)
    
    // 4. 执行测试
    dto := SubmitAnswerSheetDTO{
        QuestionnaireCode: questionnaire.GetCode().Value(),
        FillerID:          123,
        Answers: []SubmitAnswerDTO{
            {QuestionCode: "Q1", Value: "A"},
        },
    }
    
    result, err := service.SubmitAnswerSheet(context.Background(), dto)
    
    // 5. 断言
    assert.NoError(t, err)
    assert.NotNil(t, result)
    assert.Equal(t, "submitted", result.Status)
}
```

---

## 9. 下一步阅读

* **[11-04-06 设计模式应用总结](./11-04-06-设计模式应用总结.md)** - 7种设计模式的全面对比
* **[11-04-07 扩展指南](./11-04-07-扩展指南.md)** - 完整的题型扩展实战

---

> **相关文档**：
>
> * [Survey 子域设计系列](./11-04-Survey子域设计系列.md) - 系列文档索引
> * [11-04-01 Survey 子域架构总览](./11-04-01-Survey子域架构总览.md) - 架构设计
> * [11-04-02 Questionnaire 聚合设计](./11-04-02-Questionnaire聚合设计.md) - 题型设计
> * [11-04-03 AnswerSheet 聚合设计](./11-04-03-AnswerSheet聚合设计.md) - 答案设计
> * [11-04-04 Validation 子域设计](./11-04-04-Validation子域设计.md) - 校验设计
