# 11-04-07 扩展指南

> **版本**：V3.0  
> **最后更新**：2025-11-26  
> **状态**：✅ 实战示例  
> **所属系列**：[Survey 子域设计系列](./11-04-Survey子域设计系列.md)

---

## 1. 扩展指南概览

本文档提供完整的扩展实战示例，展示如何基于现有架构扩展新功能。

### 1.1 扩展场景

```text
┌────────────────────────────────────────────────────────┐
│            Survey 子域扩展场景                          │
└────────────────────────────────────────────────────────┘

1️⃣ 新增题型
   • 日期题（DateQuestion）
   • 时间题（TimeQuestion）
   • 地址题（AddressQuestion）
   • 文件上传题（FileUploadQuestion）

2️⃣ 新增答案类型
   • DateValue
   • TimeValue
   • AddressValue
   • FileValue

3️⃣ 新增校验策略
   • 日期范围校验（DateRangeStrategy）
   • 时间范围校验（TimeRangeStrategy）
   • 文件大小校验（FileSizeStrategy）
   • 文件类型校验（FileTypeStrategy）

4️⃣ 新增领域服务
   • 问卷克隆服务（CloningService）
   • 问卷导入导出服务（ImportExportService）
```

### 1.2 扩展原则

* ✅ **开闭原则**：新增功能不修改现有代码
* ✅ **最小影响**：只新增文件，不修改现有文件
* ✅ **统一风格**：遵循现有架构和命名规范
* ✅ **完整测试**：每个扩展都包含单元测试

---

## 2. 实战案例：新增日期题型

### 2.1 需求分析

**业务需求**：支持收集用户的出生日期、入职日期等信息。

**功能要求**：

* 支持日期格式：`YYYY-MM-DD`
* 支持日期范围校验（如：1900-01-01 到 2025-12-31）
* 支持必填校验
* 支持日期有效性校验

### 2.2 架构设计

```text
┌────────────────────────────────────────────────────────┐
│        日期题型完整架构                                 │
└────────────────────────────────────────────────────────┘

1️⃣ Question 层（题型定义）
   │
   ├─ DateQuestion 实现 Question 接口
   ├─ 在 init() 中注册工厂函数
   └─ 定义 TypeDate 常量

2️⃣ AnswerValue 层（答案类型）
   │
   ├─ DateValue 实现 AnswerValue 接口
   ├─ 在 CreateAnswerValueFromRaw 中添加分支
   └─ 在 AnswerValueAdapter 中处理日期类型

3️⃣ Validation 层（校验策略）
   │
   ├─ DateRangeStrategy 实现 ValidationStrategy 接口
   ├─ 在 init() 中注册策略
   └─ 定义 NewDateRangeRule 工厂方法

4️⃣ 测试层
   │
   ├─ DateQuestion 单元测试
   ├─ DateValue 单元测试
   ├─ DateRangeStrategy 单元测试
   └─ 集成测试
```

### 2.3 步骤一：定义题型常量

**文件位置**：`internal/apiserver/domain/survey/questionnaire/question.go`

**新增内容**：

```go
// 在现有题型常量后添加（伪代码）
const (
    TypeSection  = QuestionType("section")
    TypeRadio    = QuestionType("radio")
    TypeCheckbox = QuestionType("checkbox")
    TypeText     = QuestionType("text")
    TypeTextarea = QuestionType("textarea")
    TypeNumber   = QuestionType("number")
    TypeDate     = QuestionType("date")      // 新增 ✅
)
```

### 2.4 步骤二：实现 DateQuestion

**文件位置**：`internal/apiserver/domain/survey/questionnaire/date_question.go`（新建）

**完整实现**：

```go
// DateQuestion 日期题（伪代码）
package questionnaire

type DateQuestion struct {
    code             Code
    stem             string
    required         bool
    validationRules  []ValidationRule
    calculationRules []CalculationRule
    displayOrder     int
    helpText         string
    placeholder      string          // 占位符，如 "请选择日期"
    minDate          string          // 最小日期（可选）
    maxDate          string          // 最大日期（可选）
}

// 实现 Question 接口
func (q *DateQuestion) GetCode() Code { return q.code }
func (q *DateQuestion) GetType() QuestionType { return TypeDate }
func (q *DateQuestion) GetStem() string { return q.stem }
func (q *DateQuestion) IsRequired() bool { return q.required }
func (q *DateQuestion) GetOptions() []Option { return nil }  // 日期题无选项
func (q *DateQuestion) GetValidationRules() []ValidationRule { return q.validationRules }
func (q *DateQuestion) GetCalculationRules() []CalculationRule { return q.calculationRules }
func (q *DateQuestion) GetDisplayOrder() int { return q.displayOrder }
func (q *DateQuestion) GetHelpText() string { return q.helpText }

// 日期题特有方法
func (q *DateQuestion) GetPlaceholder() string { return q.placeholder }
func (q *DateQuestion) GetMinDate() string { return q.minDate }
func (q *DateQuestion) GetMaxDate() string { return q.maxDate }

// 注册工厂函数（自动执行）
func init() {
    RegisterQuestionFactory(TypeDate, func(params *QuestionParams) (Question, error) {
        // 参数校验
        if params.GetCode().IsEmpty() {
            return nil, errors.New("code is required")
        }
        if params.GetStem() == "" {
            return nil, errors.New("stem is required")
        }
        
        return &DateQuestion{
            code:             params.GetCode(),
            stem:             params.GetStem(),
            required:         params.IsRequired(),
            validationRules:  params.GetValidationRules(),
            calculationRules: params.GetCalculationRules(),
            displayOrder:     params.GetDisplayOrder(),
            helpText:         params.GetHelpText(),
            placeholder:      params.GetPlaceholder(),
            minDate:          params.GetMinDate(),
            maxDate:          params.GetMaxDate(),
        }, nil
    })
}
```

> **关键点**：
>
> * ✅ 实现 Question 接口的所有方法
> * ✅ 在 init() 中自动注册工厂函数
> * ✅ 工厂函数从 QuestionParams 读取参数

### 2.5 步骤三：扩展 QuestionParams

**文件位置**：`internal/apiserver/domain/survey/questionnaire/factory.go`

**新增字段**：

```go
// QuestionParams（伪代码）
type QuestionParams struct {
    // ... 现有字段
    
    // 日期题专用字段（新增）✅
    placeholder string
    minDate     string
    maxDate     string
}

// 新增 Getter 方法（新增）✅
func (p *QuestionParams) GetPlaceholder() string { return p.placeholder }
func (p *QuestionParams) GetMinDate() string { return p.minDate }
func (p *QuestionParams) GetMaxDate() string { return p.maxDate }
```

### 2.6 步骤四：新增函数式选项

**文件位置**：`internal/apiserver/domain/survey/questionnaire/factory.go`

**新增函数**：

```go
// 日期题配置函数（伪代码）

// WithPlaceholder 设置占位符
func WithPlaceholder(placeholder string) QuestionOption {
    return func(p *QuestionParams) {
        p.placeholder = placeholder
    }
}

// WithMinDate 设置最小日期
func WithMinDate(minDate string) QuestionOption {
    return func(p *QuestionParams) {
        p.minDate = minDate
    }
}

// WithMaxDate 设置最大日期
func WithMaxDate(maxDate string) QuestionOption {
    return func(p *QuestionParams) {
        p.maxDate = maxDate
    }
}
```

### 2.7 步骤五：使用日期题

**使用示例**：

```go
// 创建日期题（伪代码）
question, err := NewQuestion(TypeDate,
    WithCode(meta.NewCode("birthdate")),
    WithStem("请输入您的出生日期"),
    WithRequired(true),
    WithPlaceholder("YYYY-MM-DD"),
    WithMinDate("1900-01-01"),
    WithMaxDate("2025-12-31"),
    WithValidationRules([]ValidationRule{
        NewRequiredRule(),
        NewDateRangeRule("1900-01-01", "2025-12-31"),
    }),
)

if err != nil {
    return err
}

// 添加到问卷
questionnaire.AddQuestion(question)
```

**✅ 完成！** 新增题型只需创建 1 个文件，无需修改现有代码。

---

## 3. 实战案例：新增日期答案值

### 3.1 步骤一：实现 DateValue

**文件位置**：`internal/apiserver/domain/survey/answersheet/date_value.go`（新建）

**完整实现**：

```go
// DateValue 日期答案值（伪代码）
package answersheet

import (
    "time"
)

type DateValue struct {
    date time.Time
}

// NewDateValue 创建日期答案值
func NewDateValue(dateStr string) (AnswerValue, error) {
    // 解析日期字符串
    date, err := time.Parse("2006-01-02", dateStr)
    if err != nil {
        return nil, errors.Wrap(err, "invalid date format")
    }
    
    return DateValue{date: date}, nil
}

// Raw 实现 AnswerValue 接口
func (v DateValue) Raw() any {
    return v.date.Format("2006-01-02")
}

// 日期值特有方法
func (v DateValue) GetDate() time.Time {
    return v.date
}

func (v DateValue) Year() int {
    return v.date.Year()
}

func (v DateValue) Month() time.Month {
    return v.date.Month()
}

func (v DateValue) Day() int {
    return v.date.Day()
}
```

### 3.2 步骤二：扩展工厂方法

**文件位置**：`internal/apiserver/domain/survey/answersheet/answer.go`

**修改 CreateAnswerValueFromRaw**：

```go
// CreateAnswerValueFromRaw（伪代码）
func CreateAnswerValueFromRaw(qType QuestionType, raw any) (AnswerValue, error) {
    switch qType {
    case TypeRadio:
        return NewOptionValue(raw.(string)), nil
    case TypeCheckbox:
        return NewOptionsValue(raw.([]string)), nil
    case TypeText, TypeTextarea:
        return NewStringValue(raw.(string)), nil
    case TypeNumber:
        return NewNumberValue(raw.(float64)), nil
    
    // 新增日期类型处理 ✅
    case TypeDate:
        if dateStr, ok := raw.(string); ok {
            return NewDateValue(dateStr)
        }
        return nil, errors.New("date question expects string value")
    
    case TypeSection:
        return nil, errors.New("section question does not need answer")
    default:
        return nil, fmt.Errorf("unknown question type: %s", qType.Value())
    }
}
```

### 3.3 步骤三：扩展适配器

**文件位置**：`internal/apiserver/domain/survey/answersheet/validation_adapter.go`

**修改 AnswerValueAdapter**：

```go
// AsString 方法（伪代码）
func (a *AnswerValueAdapter) AsString() string {
    raw := a.answerValue.Raw()
    
    switch v := raw.(type) {
    case string:
        return v
    case float64:
        return fmt.Sprintf("%v", v)
    
    // 处理日期类型 ✅
    case time.Time:
        return v.Format("2006-01-02")
    
    case []string:
        return strings.Join(v, ",")
    default:
        return fmt.Sprintf("%v", v)
    }
}
```

**✅ 完成！** 日期答案值已集成到系统中。

---

## 4. 实战案例：新增日期范围校验

### 4.1 步骤一：定义规则类型

**文件位置**：`internal/apiserver/domain/survey/validation/rule.go`

**新增常量**：

```go
// RuleType（伪代码）
const (
    RuleTypeRequired       = "required"
    RuleTypeMinLength      = "min_length"
    RuleTypeMaxLength      = "max_length"
    RuleTypeMinValue       = "min_value"
    RuleTypeMaxValue       = "max_value"
    RuleTypeMinSelections  = "min_selections"
    RuleTypeMaxSelections  = "max_selections"
    RuleTypePattern        = "pattern"
    RuleTypeDateRange      = "date_range"      // 新增 ✅
)
```

### 4.2 步骤二：新增工厂方法

**文件位置**：`internal/apiserver/domain/survey/validation/rule.go`

**新增函数**：

```go
// NewDateRangeRule 创建日期范围规则（伪代码）
func NewDateRangeRule(minDate, maxDate string) ValidationRule {
    return ValidationRule{
        typ: RuleTypeDateRange,
        params: map[string]string{
            "min": minDate,
            "max": maxDate,
        },
    }
}
```

### 4.3 步骤三：实现校验策略

**文件位置**：`internal/apiserver/domain/survey/validation/date_range.go`（新建）

**完整实现**：

```go
// DateRangeStrategy 日期范围校验策略（伪代码）
package validation

import (
    "fmt"
    "time"
)

type DateRangeStrategy struct{}

// Validate 实现 ValidationStrategy 接口
func (s *DateRangeStrategy) Validate(
    value ValidatableValue,
    rule ValidationRule,
) error {
    // 1. 获取日期字符串
    dateStr := value.AsString()
    if dateStr == "" {
        return nil  // 空值由 RequiredStrategy 处理
    }
    
    // 2. 解析日期
    date, err := time.Parse("2006-01-02", dateStr)
    if err != nil {
        return errors.New("日期格式无效，请使用 YYYY-MM-DD 格式")
    }
    
    // 3. 获取规则参数
    params := rule.GetParams().(map[string]string)
    minDateStr := params["min"]
    maxDateStr := params["max"]
    
    // 4. 解析最小日期
    minDate, err := time.Parse("2006-01-02", minDateStr)
    if err != nil {
        return errors.Wrap(err, "invalid min date in rule")
    }
    
    // 5. 解析最大日期
    maxDate, err := time.Parse("2006-01-02", maxDateStr)
    if err != nil {
        return errors.Wrap(err, "invalid max date in rule")
    }
    
    // 6. 校验日期范围
    if date.Before(minDate) {
        return fmt.Errorf("日期不能早于 %s", minDateStr)
    }
    
    if date.After(maxDate) {
        return fmt.Errorf("日期不能晚于 %s", maxDateStr)
    }
    
    return nil
}

// 自动注册策略
func init() {
    RegisterStrategy(RuleTypeDateRange, &DateRangeStrategy{})
}
```

### 4.4 步骤四：使用日期范围校验

**使用示例**：

```go
// 创建带日期范围校验的日期题（伪代码）
question, _ := NewQuestion(TypeDate,
    WithCode(meta.NewCode("birthdate")),
    WithStem("请输入您的出生日期"),
    WithRequired(true),
    WithValidationRules([]ValidationRule{
        NewRequiredRule(),                              // 必填
        NewDateRangeRule("1900-01-01", "2025-12-31"),  // 日期范围 ✅
    }),
)

// 创建答案并校验
answerValue, _ := NewDateValue("1990-05-20")
answer, _ := NewAnswer(
    meta.NewCode("birthdate"),
    TypeDate,
    answerValue,
    0,
)

// 校验
validator := NewDefaultValidator()
validatableValue := NewAnswerValueAdapter(answer.Value())
result := validator.ValidateValue(
    validatableValue,
    question.GetValidationRules(),
)

if !result.IsValid() {
    for _, err := range result.GetErrors() {
        fmt.Printf("校验失败: %s\n", err.GetMessage())
    }
}
```

**✅ 完成！** 日期范围校验已集成到系统中。

---

## 5. 完整流程：从创建到提交

### 5.1 创建包含日期题的问卷

```go
// 完整示例：创建并发布问卷（伪代码）
func CreateQuestionnaireWithDateQuestion() error {
    // 1. 创建问题列表
    questions := []Question{}
    
    // 1.1 姓名题（文本题）
    nameQuestion, _ := NewQuestion(TypeText,
        WithCode(meta.NewCode("name")),
        WithStem("请输入您的姓名"),
        WithRequired(true),
        WithValidationRules([]ValidationRule{
            NewRequiredRule(),
            NewMinLengthRule(2),
            NewMaxLengthRule(20),
        }),
    )
    questions = append(questions, nameQuestion)
    
    // 1.2 出生日期题（日期题）✅
    birthdateQuestion, _ := NewQuestion(TypeDate,
        WithCode(meta.NewCode("birthdate")),
        WithStem("请输入您的出生日期"),
        WithRequired(true),
        WithPlaceholder("例如：1990-05-20"),
        WithHelpText("请输入真实的出生日期"),
        WithValidationRules([]ValidationRule{
            NewRequiredRule(),
            NewDateRangeRule("1900-01-01", "2025-12-31"),
        }),
    )
    questions = append(questions, birthdateQuestion)
    
    // 1.3 性别题（单选题）
    genderQuestion, _ := NewQuestion(TypeRadio,
        WithCode(meta.NewCode("gender")),
        WithStem("请选择您的性别"),
        WithRequired(true),
        WithOptions([]Option{
            NewOption("M", "男", 0),
            NewOption("F", "女", 0),
        }),
    )
    questions = append(questions, genderQuestion)
    
    // 2. 创建问卷
    questionnaire, _ := questionnaire.NewQuestionnaire(
        meta.NewCode("USER-PROFILE"),
        "用户基本信息",
        "收集用户的基本信息",
        questions,
    )
    
    // 3. 验证并发布
    validator := questionnaire.NewValidator()
    if err := validator.ValidateForPublish(questionnaire); err != nil {
        return err
    }
    
    lifecycleService := questionnaire.NewLifecycleService()
    if err := lifecycleService.Publish(questionnaire); err != nil {
        return err
    }
    
    // 4. 持久化
    return questionnaireRepo.Create(ctx, questionnaire)
}
```

### 5.2 提交包含日期答案的答卷

```go
// 完整示例：提交答卷（伪代码）
func SubmitAnswerSheetWithDateAnswer() error {
    // 1. 查询问卷
    q, _ := questionnaireRepo.FindByCode(ctx, "USER-PROFILE")
    
    // 2. 创建答案列表
    answers := []Answer{}
    
    // 2.1 姓名答案
    nameValue, _ := CreateAnswerValueFromRaw(TypeText, "张三")
    nameAnswer, _ := NewAnswer(
        meta.NewCode("name"),
        TypeText,
        nameValue,
        0,
    )
    answers = append(answers, nameAnswer)
    
    // 2.2 出生日期答案 ✅
    birthdateValue, _ := CreateAnswerValueFromRaw(TypeDate, "1990-05-20")
    birthdateAnswer, _ := NewAnswer(
        meta.NewCode("birthdate"),
        TypeDate,
        birthdateValue,
        0,
    )
    answers = append(answers, birthdateAnswer)
    
    // 2.3 性别答案
    genderValue, _ := CreateAnswerValueFromRaw(TypeRadio, "M")
    genderAnswer, _ := NewAnswer(
        meta.NewCode("gender"),
        TypeRadio,
        genderValue,
        0,
    )
    answers = append(answers, genderAnswer)
    
    // 3. 校验所有答案
    validator := NewDefaultValidator()
    for _, answer := range answers {
        question := q.FindQuestion(meta.NewCode(answer.QuestionCode()))
        validatableValue := NewAnswerValueAdapter(answer.Value())
        result := validator.ValidateValue(
            validatableValue,
            question.GetValidationRules(),
        )
        
        if !result.IsValid() {
            return fmt.Errorf("校验失败: %v", result.GetErrors())
        }
    }
    
    // 4. 创建答卷
    sheet, _ := answersheet.NewAnswerSheet(
        answersheet.NewQuestionnaireRef(
            q.GetCode().Value(),
            q.GetVersion().String(),
            q.GetTitle(),
        ),
        answersheet.NewFillerRef(123, answersheet.FillerTypeSelf),
        answers,
        time.Now(),
    )
    
    sheet.MarkAsSubmitted()
    
    // 5. 持久化
    return answerSheetRepo.Create(ctx, sheet)
}
```

---

## 6. 扩展检查清单

### 6.1 新增题型检查清单

```text
✅ 新增题型完整检查清单

□ 1. 定义题型常量
    └─ 在 question.go 中添加 TypeXxx 常量

□ 2. 实现 Question 接口
    └─ 创建 xxx_question.go 文件
    └─ 实现所有接口方法
    └─ 添加题型特有方法（可选）

□ 3. 注册工厂函数
    └─ 在 init() 中调用 RegisterQuestionFactory()
    └─ 工厂函数从 QuestionParams 读取参数

□ 4. 扩展 QuestionParams（如需新参数）
    └─ 添加新字段
    └─ 添加 Getter 方法

□ 5. 新增函数式选项（如需新参数）
    └─ 创建 WithXxx() 函数

□ 6. 编写单元测试
    └─ 测试题型创建
    └─ 测试题型方法
    └─ 测试工厂函数

□ 7. 编写集成测试
    └─ 测试完整流程（创建→添加到问卷→发布）

□ 8. 更新文档
    └─ API 文档
    └─ 用户手册
```

### 6.2 新增答案类型检查清单

```text
✅ 新增答案类型完整检查清单

□ 1. 实现 AnswerValue 接口
    └─ 创建 xxx_value.go 文件
    └─ 实现 Raw() 方法
    └─ 创建 NewXxxValue() 工厂函数

□ 2. 扩展 CreateAnswerValueFromRaw
    └─ 在 switch 中添加题型分支
    └─ 类型转换逻辑

□ 3. 扩展 AnswerValueAdapter
    └─ 在 AsString() 中处理新类型
    └─ 在 AsNumber() 中处理新类型（如需要）
    └─ 在 AsArray() 中处理新类型（如需要）

□ 4. 编写单元测试
    └─ 测试答案值创建
    └─ 测试 Raw() 方法
    └─ 测试适配器转换

□ 5. 编写集成测试
    └─ 测试完整流程（创建→校验→提交）
```

### 6.3 新增校验策略检查清单

```text
✅ 新增校验策略完整检查清单

□ 1. 定义规则类型常量
    └─ 在 rule.go 中添加 RuleTypeXxx 常量

□ 2. 创建规则工厂方法
    └─ 在 rule.go 中添加 NewXxxRule() 函数

□ 3. 实现 ValidationStrategy 接口
    └─ 创建 xxx_strategy.go 文件
    └─ 实现 Validate() 方法

□ 4. 注册策略
    └─ 在 init() 中调用 RegisterStrategy()

□ 5. 编写单元测试
    └─ 测试策略逻辑
    └─ 测试边界情况
    └─ 测试错误场景

□ 6. 编写集成测试
    └─ 测试与其他策略组合使用
```

---

## 7. 常见扩展场景

### 7.1 新增时间题型

**特点**：收集具体时间（HH:mm:ss）

**实现要点**：

* TimeQuestion 实现 Question 接口
* TimeValue 实现 AnswerValue 接口
* TimeRangeStrategy 实现时间范围校验

**配置示例**：

```go
// 时间题（伪代码）
question, _ := NewQuestion(TypeTime,
    WithCode(meta.NewCode("appointment_time")),
    WithStem("请选择预约时间"),
    WithRequired(true),
    WithPlaceholder("HH:mm"),
    WithValidationRules([]ValidationRule{
        NewRequiredRule(),
        NewTimeRangeRule("09:00", "18:00"),  // 工作时间
    }),
)
```

### 7.2 新增地址题型

**特点**：收集省市区详细地址

**实现要点**：

* AddressQuestion 实现 Question 接口
* AddressValue（结构化值：省/市/区/详细地址）
* 可选的地址联动配置

**配置示例**：

```go
// 地址题（伪代码）
question, _ := NewQuestion(TypeAddress,
    WithCode(meta.NewCode("home_address")),
    WithStem("请输入您的家庭住址"),
    WithRequired(true),
    WithAddressConfig(AddressConfig{
        RequireProvince: true,
        RequireCity:     true,
        RequireDistrict: true,
        RequireDetail:   true,
    }),
)
```

### 7.3 新增文件上传题型

**特点**：支持文件上传

**实现要点**：

* FileUploadQuestion 实现 Question 接口
* FileValue（包含文件路径/URL）
* FileSizeStrategy（文件大小校验）
* FileTypeStrategy（文件类型校验）

**配置示例**：

```go
// 文件上传题（伪代码）
question, _ := NewQuestion(TypeFileUpload,
    WithCode(meta.NewCode("resume")),
    WithStem("请上传您的简历"),
    WithRequired(true),
    WithFileConfig(FileConfig{
        MaxSize:      10 * 1024 * 1024,  // 10MB
        AllowedTypes: []string{".pdf", ".doc", ".docx"},
        MaxCount:     1,
    }),
    WithValidationRules([]ValidationRule{
        NewRequiredRule(),
        NewFileSizeRule(10 * 1024 * 1024),
        NewFileTypeRule([]string{".pdf", ".doc", ".docx"}),
    }),
)
```

### 7.4 新增矩阵题型

**特点**：多个问题共享相同的选项

**实现要点**：

* MatrixQuestion 实现 Question 接口
* 包含多个子问题（rows）
* 共享选项（columns）
* MatrixValue（多维答案）

**配置示例**：

```go
// 矩阵题（伪代码）
question, _ := NewQuestion(TypeMatrix,
    WithCode(meta.NewCode("satisfaction")),
    WithStem("请对以下方面进行评价"),
    WithRequired(true),
    WithMatrixRows([]MatrixRow{
        {Code: "quality", Label: "产品质量"},
        {Code: "service", Label: "客户服务"},
        {Code: "price", Label: "价格合理性"},
    }),
    WithMatrixColumns([]Option{
        NewOption("1", "非常不满意", 1),
        NewOption("2", "不满意", 2),
        NewOption("3", "一般", 3),
        NewOption("4", "满意", 4),
        NewOption("5", "非常满意", 5),
    }),
)
```

---

## 8. 扩展最佳实践

### 8.1 命名规范

**题型命名**：

* 类型常量：`Type{Name}`，如 `TypeDate`
* 实现类：`{Name}Question`，如 `DateQuestion`
* 文件名：`{name}_question.go`，如 `date_question.go`

**答案值命名**：

* 实现类：`{Name}Value`，如 `DateValue`
* 工厂函数：`New{Name}Value`，如 `NewDateValue`
* 文件名：`{name}_value.go`，如 `date_value.go`

**校验策略命名**：

* 规则常量：`RuleType{Name}`，如 `RuleTypeDateRange`
* 策略类：`{Name}Strategy`，如 `DateRangeStrategy`
* 工厂函数：`New{Name}Rule`，如 `NewDateRangeRule`
* 文件名：`{name}_strategy.go` 或 `{name}.go`

### 8.2 代码组织

**推荐目录结构**：

```text
internal/apiserver/domain/survey/
├── questionnaire/
│   ├── question.go              (接口 + 常量)
│   ├── factory.go               (工厂 + 注册器 + QuestionParams)
│   ├── radio_question.go        (单选题)
│   ├── checkbox_question.go     (多选题)
│   ├── text_question.go         (文本题)
│   ├── date_question.go         (日期题) ✅ 新增
│   └── time_question.go         (时间题) ✅ 新增
│
├── answersheet/
│   ├── answer.go                (Answer + AnswerValue接口 + 工厂方法)
│   ├── string_value.go
│   ├── number_value.go
│   ├── option_value.go
│   ├── options_value.go
│   ├── date_value.go            ✅ 新增
│   └── validation_adapter.go
│
└── validation/
    ├── strategy.go              (接口 + 注册器)
    ├── rule.go                  (规则 + 工厂方法)
    ├── required.go
    ├── min_length.go
    ├── max_length.go
    ├── min_value.go
    ├── max_value.go
    ├── selections.go
    ├── pattern.go
    └── date_range.go            ✅ 新增
```

### 8.3 测试策略

**单元测试**：

```go
// 题型测试（伪代码）
func TestDateQuestion_Creation(t *testing.T) {
    question, err := NewQuestion(TypeDate,
        WithCode(meta.NewCode("birthdate")),
        WithStem("出生日期"),
        WithRequired(true),
    )
    
    assert.NoError(t, err)
    assert.Equal(t, TypeDate, question.GetType())
    assert.True(t, question.IsRequired())
}

// 答案值测试（伪代码）
func TestDateValue_Creation(t *testing.T) {
    value, err := NewDateValue("1990-05-20")
    
    assert.NoError(t, err)
    assert.Equal(t, "1990-05-20", value.Raw())
}

// 策略测试（伪代码）
func TestDateRangeStrategy_Validate(t *testing.T) {
    strategy := &DateRangeStrategy{}
    value := &MockValidatableValue{str: "1990-05-20"}
    rule := NewDateRangeRule("1900-01-01", "2025-12-31")
    
    err := strategy.Validate(value, rule)
    
    assert.NoError(t, err)
}
```

**集成测试**：

```go
// 完整流程测试（伪代码）
func TestDateQuestion_FullFlow(t *testing.T) {
    // 1. 创建问卷
    q := createQuestionnaireWithDateQuestion()
    
    // 2. 提交答卷
    sheet := submitAnswerSheetWithDateAnswer(q)
    
    // 3. 验证答卷
    assert.Equal(t, StatusSubmitted, sheet.GetStatus())
    
    // 4. 查询答案
    answer := sheet.FindAnswer(meta.NewCode("birthdate"))
    assert.NotNil(t, answer)
    assert.Equal(t, "1990-05-20", answer.Value().Raw())
}
```

### 8.4 文档要求

**每个扩展都应该包含**：

* ✅ 代码注释（接口、方法、关键逻辑）
* ✅ 使用示例（godoc example）
* ✅ API 文档更新
* ✅ 用户手册更新
* ✅ CHANGELOG 记录

---

## 9. 总结

### 9.1 扩展流程总结

```text
┌────────────────────────────────────────────────────┐
│        Survey 子域扩展流程                          │
└────────────────────────────────────────────────────┘

1️⃣ 需求分析
   └─ 明确功能需求和使用场景

2️⃣ 架构设计
   └─ 选择合适的扩展点
   └─ 设计数据结构和接口

3️⃣ 实现
   └─ 题型实现（Question）
   └─ 答案值实现（AnswerValue）
   └─ 校验策略实现（ValidationStrategy）

4️⃣ 集成
   └─ 注册到系统中（init()）
   └─ 扩展相关组件（工厂、适配器）

5️⃣ 测试
   └─ 单元测试
   └─ 集成测试
   └─ 手动测试

6️⃣ 文档
   └─ 代码注释
   └─ API 文档
   └─ 用户手册

7️⃣ 发布
   └─ 代码审查
   └─ CHANGELOG
   └─ 版本发布
```

### 9.2 关键原则

* ✅ **开闭原则**：通过注册器模式实现，新增功能无需修改现有代码
* ✅ **最小影响**：每个扩展独立在自己的文件中
* ✅ **统一风格**：遵循现有命名和代码规范
* ✅ **完整测试**：单元测试 + 集成测试
* ✅ **文档齐全**：代码注释 + 使用示例 + API 文档

### 9.3 扩展能力总结

基于当前架构，Survey 子域可以轻松扩展：

| 扩展类型 | 难度 | 工作量 | 影响范围 |
|---------|------|-------|---------|
| **新增题型** | ⭐⭐ | 2-4小时 | 新增 1 个文件 |
| **新增答案类型** | ⭐⭐ | 1-2小时 | 修改 2 个文件 |
| **新增校验策略** | ⭐ | 1-2小时 | 新增 1 个文件 |
| **新增领域服务** | ⭐⭐ | 2-3小时 | 新增 1 个文件 |

**核心价值**：通过精心设计的架构，实现了**高扩展性**和**低维护成本**。

---

## 10. 附录：完整代码示例

### 10.1 DateQuestion 完整实现

> **查看完整实现**：可以参考现有题型的实现方式
>
> * [radio_question.go](../../internal/apiserver/domain/survey/questionnaire/radio_question.go)
> * [text_question.go](../../internal/apiserver/domain/survey/questionnaire/text_question.go)

### 10.2 DateValue 完整实现

> **查看完整实现**：可以参考现有答案值的实现方式
>
> * [string_value.go](../../internal/apiserver/domain/survey/answersheet/answer.go)
> * [number_value.go](../../internal/apiserver/domain/survey/answersheet/answer.go)

### 10.3 DateRangeStrategy 完整实现

> **查看完整实现**：可以参考现有策略的实现方式
>
> * [min_length.go](../../internal/apiserver/domain/survey/validation/min_length.go)
> * [pattern.go](../../internal/apiserver/domain/survey/validation/pattern.go)

---

> **相关文档**：
>
> * [Survey 子域设计系列](./11-04-Survey子域设计系列.md) - 系列文档索引
> * [11-04-01 Survey 子域架构总览](./11-04-01-Survey子域架构总览.md) - 架构设计
> * [11-04-02 Questionnaire 聚合设计](./11-04-02-Questionnaire聚合设计.md) - 题型设计
> * [11-04-03 AnswerSheet 聚合设计](./11-04-03-AnswerSheet聚合设计.md) - 答案设计
> * [11-04-04 Validation 子域设计](./11-04-04-Validation子域设计.md) - 校验设计
> * [11-04-05 应用服务层设计](./11-04-05-应用服务层设计.md) - 应用服务层
> * [11-04-06 设计模式应用总结](./11-04-06-设计模式应用总结.md) - 设计模式总结

---

**🎉 Survey 子域设计系列文档已全部完成！**
