# 12-05 测评计划与入校筛查建模（V2）

> 版本：V2.0
> 范围：plan 子域（AssessmentPlan / AssessmentTask），screening 子域（ScreeningProject）
> 前置文档：11-01 领域模型总览，11-03 Testee & Staff 用户模型设计，12-03 评估工作流设计

---

## 1. 设计目标

在问卷&量表 BC 中，需要同时支持两类“批量测评”业务：

1. **周期性测评计划**（plan 子域）：

   * 互联网医院：患者报到后，医生为其制定随访测评计划（例如每 4 周一次）。
   * 行为训练中心：学员入校/签约后，按照课时或周数生成测评计划。

2. **入校筛查项目**（screening 子域）：

   * 学校/教育局维度的筛查项目，统一给某年级/班级家长推送问卷。

要求：

* 与单次测评的 Assessment 聚合打通；
* 便于统计“计划执行情况”“筛查完成情况”；
* 不把外部业务（互联网医院、行为中心）的所有概念硬塞进本 BC。

---

## 2. 测评计划建模（plan 子域）

### 2.1 核心思路

* **AssessmentPlan**：描述“对某个 Testee 在一段时间内做若干次测评”的计划；
* **AssessmentTask**：计划下的“某一次测评任务实例”（第 N 次测评）；
* **Assessment**：最终实际发生的测评，由提交答卷时创建，并与 Task 关联。

### 2.2 AssessmentPlan 聚合

```go
type AssessmentPlanID string

// 计划状态
type PlanStatus string

const (
    PlanStatusActive   PlanStatus = "active"
    PlanStatusPaused   PlanStatus = "paused"
    PlanStatusFinished PlanStatus = "finished"
    PlanStatusCanceled PlanStatus = "canceled"
)

// 计划类型：按周、按天、按固定日期等
type PlanScheduleType string

const (
    PlanScheduleByWeek    PlanScheduleType = "by_week"    // 每 N 周一次
    PlanScheduleByDay     PlanScheduleType = "by_day"     // 每 N 天一次
    PlanScheduleFixedDate PlanScheduleType = "fixed_date" // 指定日期列表
)

type AssessmentPlan struct {
    id            AssessmentPlanID
    orgID         int64
    testeeID      user.TesteeID
    scaleID       scale.MedicalScaleID

    scheduleType  PlanScheduleType
    interval      int           // 间隔 N 周/天
    totalTimes    int           // 计划总次数
    fixedDates    []time.Time   // 固定日期模式下使用

    startDate     time.Time
    endDate       *time.Time

    status        PlanStatus

    createdBy     user.StaffID
    createdAt     time.Time
    updatedAt     time.Time
}
```

说明：

* Plan 只描述“应该如何测”，不关心每一次是否完成；
* 计划的“执行情况”通过 Task 与 Assessment 统计。

### 2.3 AssessmentTask 实体

```go
type AssessmentTaskID string

// 任务状态
type TaskStatus string

const (
    TaskStatusPending   TaskStatus = "pending"   // 已生成任务，但未开始/未创建 Assessment
    TaskStatusOpened    TaskStatus = "opened"    // 已生成测评入口（二维码/链接）
    TaskStatusCompleted TaskStatus = "completed" // 已提交答卷并完成评估
    TaskStatusExpired   TaskStatus = "expired"   // 超过截止时间未完成
)

type AssessmentTask struct {
    id            AssessmentTaskID
    planID        AssessmentPlanID
    seq           int             // 第 N 次测评
    testeeID      user.TesteeID
    scaleID       scale.MedicalScaleID

    plannedAt     time.Time       // 计划时间点（用于前端展示/提醒）
    openAt        *time.Time      // 实际开放时间
    expireAt      *time.Time      // 截止时间

    status        TaskStatus
    assessmentID  *assessment.AssessmentID

    createdAt     time.Time
    updatedAt     time.Time
}
```

说明：

* Task 是计划分解后的“应测实例”，对接消息推送与入口生成；
* Task 与 Assessment 是 1:0..1 关系：

  * 若用户填写完成，创建 Assessment 并回写 assessmentID；
  * 若用户从未填写，到期后 Task 标记为 expired。

### 2.4 Plan 与 Task 的生成策略

#### 2.4.1 创建计划时一次性生成全部 Task（简单版）

* 适用于测评次数不多的场景（例如 10 次以内）；
* 创建计划时，根据 scheduleType / interval / totalTimes 生成所有 Task；
* 优点：逻辑简单，查询方便；
* 缺点：计划跨度很大时（数年）不够优雅，但当前业务不会到这么夸张。

#### 2.4.2 定时生成 Task（进阶版）

* 使用 daily cron job：

  * 扫描计划，生成未来 N 天内应发生的 Task；
* 适用于大规模长期随访，但现阶段可不做。

V2 先采用 **简单版**：创建计划时一次性生成 Task，控制计划总次数在合理范围（如 ≤ 50 次）。

### 2.5 Plan & Task 与 Assessment 的关系

* 入口生成：

  * 每个 Task 对应一个测评入口（二维码/链接），入口中包含 task_id；
* 提交答卷：

  * collection-server 收到带 task_id 的提交；
  * 应用层根据 task_id 查 Task，进一步查 Plan / Testee / Scale；
  * 创建 Assessment 时写入：

    * originType = plan
    * originID = planID
    * taskID 写入 Assessment 的扩展字段或关联表；
  * 更新 Task.status = completed，`assessmentID = Assessment.ID`。

这样：

* 按 Task 维度可计算“每次计划的完成情况”；
* 按 Plan 维度可统计“计划总执行率、每次完成率”；
* 按 Testee 聚合时可看到“该 Testee 在该量表上的多次测评折线图”。

---

## 3. 入校筛查建模（screening 子域）

### 3.1 业务特点

* 以“项目”为单位：某校、某年级、某批次；
* 发放统一问卷/量表到大量家长/学生；
* 多数用户为外部家长，通过二维码或链接进入填写；
* 不一定预先在 IAM 中创建全部学生档案。

### 3.2 ScreeningProject 聚合

```go
type ScreeningProjectID string

// 项目状态
type ScreeningStatus string

const (
    ScreeningStatusDraft     ScreeningStatus = "draft"
    ScreeningStatusPublished ScreeningStatus = "published"
    ScreeningStatusClosed    ScreeningStatus = "closed"
)

type ScreeningProject struct {
    id             ScreeningProjectID
    orgID          int64             // 学校/教育机构
    name           string            // 项目名称，如 "2025 秋季一年级入校筛查"

    questionnaireID survey.QuestionnaireID
    scaleID         *scale.MedicalScaleID // 可选：问卷模式时为空

    grade           *string           // 年级
    classes         []string          // 班级列表（可选）

    startAt         time.Time
    endAt           time.Time

    status          ScreeningStatus

    createdBy       user.StaffID
    createdAt       time.Time
    updatedAt       time.Time
}
```

说明：

* ScreeningProject 定义了一次筛查活动的边界（时间范围、问卷、对象范围）；
* 是否为“量表模式”由 scaleID 是否为空决定。

### 3.3 填写入口与 Testee 关系

扫码场景：

* 家长扫描项目二维码（包含 screening_project_id）；
* collection-server 根据 screening_project_id 载入项目；
* 若提前导入学生主档：

  * 可以在扫码流程中让家长选择孩子（学号/姓名 + 校验）；
  * 系统使用 student_info → 查找/创建 Testee；
* 若未导入主档：

  * 可直接创建临时 Testee（最少记录姓名/性别/班级信息）。

随后流程：

* 保存 AnswerSheet；
* 创建 Assessment（originType=screening，originID=ScreeningProjectID）；
* 若存在 scaleID，则进入评估工作流；
* 所有项目统计均以 Assessment + ScreeningProject 维度进行。

### 3.4 Screening 统计视角

常见统计需求：

1. 完成率：

   * 项目总发放人数 vs 已完成测评人数；
2. 风险分布：

   * 不同风险等级（none/low/mid/high）的学生数量；
3. 班级/年级维度对比：

   * 不同班级的高风险人数比例。

建模建议：

* 不在 ScreeningProject 中直接嵌入统计字段；
* 通过独立的统计表或离线任务维护：

  * `screening_stats`：

    * 维度：screening_project_id, grade, class;
    * 指标：total, completed, high_risk_count 等；
* Assessment 与 Testee/ScreeningProject 的关系保证统计时可追溯。

---

## 4. 与 Testee 模型的协同

### 4.1 测评计划

* 创建 AssessmentPlan 前，必须确保 Testee 存在；
* 计划与 Task 全程引用 TesteeID；
* 多次测评的趋势分析可以直接按 TesteeID 聚合 Assessment。

### 4.2 入校筛查

* 若已导入学生主档，可提前批量创建 Testee：

  * 以 student_id 为 key 做幂等创建；
* 若未导入主档：

  * 可允许创建“临时 Testee”，只用于当前项目；
  * 后续如要在其他 BC 中使用，再做 ID 绑定。

---

## 5. 仓储接口示例

```go
type AssessmentPlanRepository interface {
    FindByID(ctx context.Context, id AssessmentPlanID) (*AssessmentPlan, error)
    Save(ctx context.Context, p *AssessmentPlan) error
}

type AssessmentTaskRepository interface {
    FindByID(ctx context.Context, id AssessmentTaskID) (*AssessmentTask, error)
    FindByPlanID(ctx context.Context, planID AssessmentPlanID) ([]AssessmentTask, error)
    Save(ctx context.Context, t *AssessmentTask) error
}

type ScreeningProjectRepository interface {
    FindByID(ctx context.Context, id ScreeningProjectID) (*ScreeningProject, error)
    Save(ctx context.Context, p *ScreeningProject) error
}
```

---

## 6. 用例示例

### 6.1 创建测评计划

1. API：`POST /testees/{id}/assessment_plans`；
2. 应用层：

   * 校验 Testee 存在；
   * 校验 scale/问卷配置；
   * 构建 AssessmentPlan；
   * 根据规则一次性生成 AssessmentTask 列表；
   * 持久化；
   * 返回 PlanID。

### 6.2 根据 Task 创建 Assessment

1. 小程序访问 Task 的测评入口提交答卷；
2. 应用层：

   * 根据 task_id 查 Task 与 Plan；
   * 确认 Task 状态为 pending/opened 且未过期；
   * 创建 AnswerSheet；
   * 创建 Assessment（originType=plan, originID=planID, testeeID=plan.testeeID）；
   * 更新 Task.status=completed, assessmentID=Assessment.ID；
   * 发布 AssessmentSubmittedEvent。

### 6.3 创建入校筛查项目

1. 后台用户（Staff）调用 `POST /screening_projects`；
2. 应用层：

   * 校验 org/问卷/时间范围；
   * 创建 ScreeningProject；
   * 返回 project_id，并生成二维码链接。

---

## 7. 总结

* plan 子域通过 AssessmentPlan + AssessmentTask 管理“周期性测评”，与 Assessment/Testee 串联，支撑计划执行率与趋势分析；
* screening 子域通过 ScreeningProject 表达“入校筛查项目”，与 Assessment/Testee 结合，支撑学校/班级维度的整体风险分析；
* 两者都不把外部业务 BC 的细节引入本 BC，而是通过 orgID、TesteeID 以及 originType/originID 做松耦合关联；
* 所有统计都可以从 Assessment + Testee + Plan/Screening 的组合关系上推导出来，保持领域模型简洁、可演进。
