# 12-01 校验规则设计（策略模式）（V2）

> 版本：V2.0
> 范围：survey 子域（Questionnaire / AnswerSheet 的领域校验）
> 目标：为“答卷校验”提供一套可扩展、可配置、无状态的规则体系。

---

## 1. 背景

问卷校验涵盖：

* 必填项；
* 数值范围；
* 选项个数；
* 依赖/跳题逻辑；
* 正则匹配等。

特点：

* 每题可能有 0~N 个规则；
* 规则本身无状态，只依赖问卷结构与当前答卷；
* 需要配置驱动、可扩展。

V2 采用：

* Question 上只存 **规则配置 RuleConfig**；
* 使用 **QuestionRule 策略接口** 表达具体规则；
* 使用 **RuleFactory** 从配置生成策略；
* 使用 **AnswerSheetValidator** 统一执行。

---

## 2. RuleConfig 与 Question 上的配置

```go
type RuleType string

const (
    RuleTypeRequired    RuleType = "required"
    RuleTypeNumberRange RuleType = "number_range"
    RuleTypeOptionCount RuleType = "option_count"
    RuleTypeDependency  RuleType = "dependency"
    RuleTypeRegex       RuleType = "regex"
)

type RuleConfig struct {
    Type   RuleType
    Params map[string]string
}
```

Question 中：

```go
type Question struct {
    id             QuestionID
    qType          QuestionType
    title          string
    required       bool
    options        []Option
    validationRule []RuleConfig
    scoringConfig  *ScoringConfig
}
```

---

## 3. QuestionRule 策略接口

上下文对象：

```go
type QuestionValidationContext struct {
    Questionnaire *Questionnaire
    Sheet         *AnswerSheet
    Question      *Question
    Item          *AnswerItem // 可能为 nil
}
```

错误结构：

```go
type ValidationError struct {
    QuestionID QuestionID
    Code       string
    Message    string
}

type ValidationErrors []ValidationError

func (ve ValidationErrors) Error() string {
    return "answersheet validation failed"
}
```

策略接口：

```go
type QuestionRule interface {
    Code() RuleType
    Validate(ctx context.Context, c QuestionValidationContext) *ValidationError
}
```

---

## 4. 典型规则实现示例

### 4.1 必填规则

```go
type RequiredRule struct{}

func (r *RequiredRule) Code() RuleType { return RuleTypeRequired }

func (r *RequiredRule) Validate(ctx context.Context, c QuestionValidationContext) *ValidationError {
    if !c.Question.required {
        return nil
    }
    if c.Item == nil || len(c.Item.Values) == 0 {
        return &ValidationError{
            QuestionID: c.Question.id,
            Code:       "required",
            Message:    "required question not answered",
        }
    }
    return nil
}
```

### 4.2 数值范围规则

```go
type NumberRangeRule struct {
    Min *float64
    Max *float64
}
```

核心逻辑：解析 AnswerItem 的值为 float，与 Min/Max 比较。

### 4.3 选项个数规则

```go
type OptionCountRule struct {
    Min *int
    Max *int
}
```

核心逻辑：检查 `len(c.Item.Values)` 是否在区间内。

其他规则（依赖题、正则等）同理实现。

---

## 5. RuleFactory：配置 → 策略实例

```go
type QuestionRuleFactory interface {
    FromConfig(cfg RuleConfig) (QuestionRule, error)
}

type defaultRuleFactory struct{}

func NewDefaultRuleFactory() QuestionRuleFactory {
    return &defaultRuleFactory{}
}

func (f *defaultRuleFactory) FromConfig(cfg RuleConfig) (QuestionRule, error) {
    switch cfg.Type {
    case RuleTypeRequired:
        return &RequiredRule{}, nil
    case RuleTypeNumberRange:
        // 解析 min/max 为 float64，返回 NumberRangeRule
    case RuleTypeOptionCount:
        // 解析 min/max 为 int，返回 OptionCountRule
    default:
        return nil, nil
    }
}
```

---

## 6. AnswerSheetValidator：组合执行

接口：

```go
type AnswerSheetValidator interface {
    Validate(ctx context.Context, q *Questionnaire, s *AnswerSheet) error
}
```

默认实现：

```go
type DefaultAnswerSheetValidator struct {
    ruleFactory QuestionRuleFactory
}

func NewDefaultAnswerSheetValidator(f QuestionRuleFactory) *DefaultAnswerSheetValidator {
    return &DefaultAnswerSheetValidator{ruleFactory: f}
}

func (v *DefaultAnswerSheetValidator) Validate(
    ctx context.Context,
    q *Questionnaire,
    s *AnswerSheet,
) error {
    var errs ValidationErrors

    for _, question := range q.questions {
        ctxQ := QuestionValidationContext{
            Questionnaire: q,
            Sheet:         s,
            Question:      &question,
            Item:          s.FindItem(question.id),
        }

        for _, cfg := range question.validationRule {
            rule, err := v.ruleFactory.FromConfig(cfg)
            if err != nil || rule == nil {
                continue
            }
            if e := rule.Validate(ctx, ctxQ); e != nil {
                errs = append(errs, *e)
            }
        }
    }

    if len(errs) > 0 {
        return errs
    }
    return nil
}
```

---

## 7. 应用层中的使用

提交答卷用例服务中：

```go
func (s *SubmitAssessmentService) Submit(ctx context.Context, cmd SubmitCommand) error {
    q, _ := s.questionnaireRepo.FindByID(ctx, cmd.QuestionnaireID)
    sheet := survey.NewAnswerSheet(q.ID())
    // 填充 AnswerItem ...

    if err := s.validator.Validate(ctx, q, sheet); err != nil {
        return err
    }

    sheet.Submit()
    return s.answersheetRepo.Save(ctx, sheet)
}
```

---

## 8. 设计原则

1. **规则策略化**：新增规则只需新增 RuleType + Rule 实现 + factory 分支。
2. **无状态**：规则只依赖 Question / AnswerSheet，不访问外部资源。
3. **配置驱动**：通过 RuleConfig.Params 描述规则参数，支撑后台配置。
4. **分层清晰**：HTTP 参数校验在 handler 层，领域校验关注业务合法性。

这套设计为 survey 子域提供了可扩展、可测试的校验机制。
