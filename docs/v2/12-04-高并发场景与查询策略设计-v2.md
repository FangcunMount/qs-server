# 12-04 高并发场景与查询策略设计（V2）

> 版本：V2.0
> 范围：问卷&量表测评系统（qs-apiserver + qs-collection + qs-worker）在“几千并发测评”场景下的读写与查询策略设计。
> 前置依赖：11-01 领域模型、11-02 代码结构、12-03 评估工作流。

---

## 1. 目标与假设

### 1.1 性能目标

* 峰值 **200 QPS** 级别（HTTP 层面）；
* 典型高峰持续时间：几十分钟级，例如某次入校筛查集中发卷；
* 单次测评评估耗时：**< 3s**（绝大部分在 1s 内完成）。

### 1.2 架构前提

* MySQL：云数据库，主库承担写 & 大部分读；
* MongoDB：部署在 ServerA 上，承载 Questionnaire / AnswerSheet / InterpretReport 文档；
* Redis-cache：部署在 ServerA，**仅作缓存，可淘汰，不持久化**；
* NSQ：ServerA 上部署集群，承担 Assessment 相关事件流；
* 服务：

  * `qs-collectionserver`：面向小程序的答卷提交与查询入口；
  * `qs-apiserver`：领域 API入口，处理 Assessment / Testee / Plan 等；
  * `qs-worker`：评估任务消费者（异步计算）。

---

## 2. 访问模式分析

### 2.1 写路径

1. 小程序提交答卷：

   * 调用 `qs-collection` → `qs-apiserver`；
   * 写 Mongo：AnswerSheet；
   * 写 MySQL：Assessment（status=submitted）、AssessmentPlan/Task 相关字段更新；
   * 发 NSQ：AssessmentSubmittedEvent。

写请求特点：

* QPS 相对有限（相对于读）；
* 以主键写为主（insert/update），对索引要求简单；
* 可以接受少量排队（评估异步）。

### 2.2 读路径

主要三类：

1. **轮询单个测评结果**（最核心）：

   * 小程序在“解析中页面”轮询：`GET /assessments/{id}`；
2. **受试者历史记录**：

   * 列出某 Testee 的全部 Assessment 列表，支持按量表筛选；
3. **后台统计/报表**：

   * 按机构/计划/筛查项目维度做统计（离线或低频）。

高并发时压力最集中在 **1. 单测评轮询**。

---

## 3. 基线方案：短轮询 + 主键查询

先给出最简单、也是第一版可上线的方案：

### 3.1 接口设计

```http
GET /api/v1/assessments/{assessment_id}
```

返回：

* status：submitted / interpreted / failed；
* 若 interpreted：附带基础报告摘要（总分、风险级别等）；
* 若 submitted：仅返回状态和提示文案。

### 3.2 查询策略

* 只查 MySQL Assessment 主表（或视图），不 join 大量表：

```sql
SELECT id, status, total_score, risk_level, interpreted_at
FROM   assessments
WHERE  id = ?
LIMIT  1;
```

* 当 status = interpreted 时，再按需查询 InterpretReport（Mongo）：

  * 若只需要“摘要”，可直接用 Assessment 字段；
  * 若需要“详细报告”，再发起一次 `GET /assessment_reports/{id}` 查询 Mongo。

### 3.3 索引设计

* `assessments`：

  * 主键：`PRIMARY KEY (id)`；
  * 常用查询：

    * 按 Testee 列表：`INDEX idx_assessments_testee (testee_id, created_at DESC)`；
    * 按 Plan / Screening：`INDEX idx_assessments_origin (origin_type, origin_id, created_at DESC)`；

> 轮询场景 **只打主键**，不会走复合索引，确保 MySQL 高效处理高频主键查询。

### 3.4 为什么足够支撑 200 QPS

* 单次轮询是一次主键查询，属于 MySQL 最擅长的访问模式；
* 解析成功后，前端会停止轮询，压力只在“解析窗口”的几十秒内；
* QPS 200 对云 MySQL 来说极其正常；
* 只要控制好轮询频率（例如 1~2 秒一次），完全在可控范围内。

---

## 4. 轮询策略与频率

### 4.1 简单策略

* 提交成功后：

  * 立即请求一次 `/assessments/{id}`；
  * 若 status=submitted：隔 1 秒再查；
* 最多轮询 30 次（约 30 秒）；

  * 超时后给用户展示“稍后在测评记录中查看结果”。

### 4.2 渐进退避（可选优化）

进一步降低压力：

* 前 5 次：间隔 1 秒；
* 之后 10 次：间隔 2 秒；
* 再之后：间隔 3~5 秒；

在高峰时，等待几秒对用户体验影响有限，但可以显著减少请求总数。

---

## 5. Redis 缓存的使用时机

第一版不强依赖缓存，仅作为优化手段，在需要的时候再引入：

### 5.1 缓存什么？

* Assessment 的“轻量状态”视图：

```json
{
  "id": "A123",
  "status": "interpreted",
  "total_score": 56,
  "risk_level": "mid",
  "interpreted_at": "2025-11-16T10:00:00Z"
}
```

* Key 设计：`assessment:summary:{id}`；
* TTL：例如 10 分钟 ~ 1 小时，过期后自然落回数据库。

### 5.2 写入时机

* qs-worker 评估完成后，更新 MySQL 的同时写入 Redis：

  * 采用 **write-through** 模式：

    * 更新 Assessment；
    * 插入/更新 Redis-summary。

### 5.3 读取策略

* `GET /assessments/{id}`：

  * 先查 Redis；
  * 若命中直接返回；
  * 若未命中再查 MySQL；
  * 如果 MySQL status=interpreted，可以顺手回填 Redis。

### 5.4 引入 Redis 的前提

当出现以下信号时考虑开启缓存：

* 监控发现 MySQL CPU/IO 高、主键查询延迟明显抬升；
* 入校筛查项目规模扩大，短时间内有数万次轮询请求；
* QPS 目标从 200 提升到 500+。

---

## 6. 历史记录与统计查询

### 6.1 Testee 历史记录

接口：

```http
GET /api/v1/testees/{testee_id}/assessments?scale_code=SDS
```

查询：

```sql
SELECT id, testee_id, medical_scale_id, total_score, risk_level, created_at
FROM   assessments
WHERE  testee_id = ?
  AND  (medical_scale_id = ? OR ? IS NULL)
ORDER BY created_at DESC
LIMIT  50;
```

索引支撑：`idx_assessments_testee (testee_id, created_at DESC)`。

### 6.2 报表与统计

* 统计类型：

  * 按机构/计划/筛查项目统计测评数量、高风险人数比例等；
* 建议：

  * 作为 **后台离线任务** 或 **低频 API** 实现；
  * 允许较高延迟（秒级 ~ 分钟级）；
  * 必要时增加 MySQL 只读实例或单独的统计表。

### 6.3 预聚合（后续可选）

对于常用指标（如计划填写率）：

* 在 Assessment 状态变化时增量更新统计表：

  * `assessment_stats`：维度字段（plan_id/org_id/screening_id）、统计字段（total, completed, high_risk_count...）。
* 报表查询直接打统计表，而非全表扫描主表。

---

## 7. 失败与降级策略

### 7.1 评估失败

* qs-worker 出错：

  * 更新 Assessment.status = failed；
  * 前端轮询看到 failed，提示用户“解析失败，请稍后重试或联系管理员”。

### 7.2 MQ 堵塞 / 挂掉

* 提交流程不依赖评估结果即可返回；
* 可以在后台增加健康检查：发现 MQ 没消费时报警；
* 前端提示“解析可能延迟”。

### 7.3 DB 读压力过高

* 短期措施：

  * 增大轮询间隔；
  * 暂时关闭某些非核心查询（如某些报表接口）；
* 中长期措施：

  * 引入 Redis 缓存；
  * 视情况加只读实例或做简单分库（按机构拆）。

---

## 8. 版本演进路线

1. **V1 基线版本**：

   * 短轮询 + Assessment 主键查询；
   * MySQL 单库，合理索引；
   * 不用 Redis 缓存；
   * 统计简单做，避免复杂报表。

2. **V2 优化版本**：

   * 加入 Redis 缓存 Assessment 摘要；
   * 部分统计指标转为预聚合表；
   * 轮询采用渐进退避策略。

3. **V3 进阶版本**（必要时）：

   * Assessment 按 org / 业务线分库分表；
   * 报表查询用离线 ETL + 专用统计库（如 ClickHouse / Elasticsearch）。

---

## 9. 总结

* 第一版优先采用 **简单可控** 的方案：短轮询 + 主键查；
* 通过合理索引与轮询频率控制，足以支撑 200 QPS 和“几千并发测评”；
* Redis 缓存、预聚合统计作为后续优化手段，而不是一开始就堆复杂度；
* MQ 解耦评估任务，使得提交路径不会被计算负载拖死，整体架构有清晰的扩展方向。
