# Worker Handler 设计模式重构总结

## 架构概览

Worker 的事件处理系统采用了多种经典设计模式，实现了高内聚、低耦合的架构。

```
NSQ Topic → DomainHandler (分发) → EventDispatcher (策略) → EventHandler (处理)
    ↓              ↓                      ↓                      ↓
Registry       BaseHandler          EventHandler           BaseEventHandler
(注册表)        (模板)               (策略接口)             (模板方法)
```

---

## 1. 注册表模式 (Registry Pattern)

**位置**: `handlers/registry.go`

**职责**: 管理 Topic Handler 的注册与查找

```go
type Registry struct {
    handlers map[string]base.Handler
}

// 注册 Topic Handler
registry.Register(questionnaire.NewQuestionnaireDomainHandler(logger))
registry.Register(assessment.NewAssessmentDomainHandler(logger, client))
```

**优点**:
- 集中管理所有 Topic Handler
- 支持动态注册和查询
- 解耦 Handler 的创建和使用

---

## 2. 策略模式 (Strategy Pattern)

**位置**: `handlers/base/dispatcher.go`

**职责**: 将每个事件类型封装为独立的策略对象

### 策略接口
```go
type EventHandler interface {
    EventType() string
    Handle(ctx context.Context, payload []byte) error
}
```

### 策略上下文（分发器）
```go
type EventDispatcher struct {
    handlers map[string]EventHandler
}

func (d *EventDispatcher) Dispatch(ctx context.Context, eventType string, payload []byte) error {
    handler := d.handlers[eventType]
    return handler.Handle(ctx, payload)
}
```

### 具体策略
```go
// 问卷发布事件策略
type QuestionnairePublishedEventHandler struct {
    *base.BaseEventHandler
}

// 量表更新事件策略
type ScaleUpdatedEventHandler struct {
    *base.BaseEventHandler
}
```

**优点**:
- 消除了大量的 switch-case 语句
- 每个事件处理逻辑独立封装，符合单一职责原则
- 易于扩展新事件类型，符合开闭原则
- 可以单独测试每个事件处理器

---

## 3. 工厂模式 (Factory Pattern)

**位置**: 各 `New*Handler()` 函数

**职责**: 封装对象创建逻辑，提供统一的创建接口

```go
// DomainHandler 工厂
func NewQuestionnaireDomainHandler(logger *slog.Logger) *QuestionnaireDomainHandler {
    handler := &QuestionnaireDomainHandler{
        BaseHandler: base.NewBaseHandler("questionnaire.lifecycle", "..."),
        logger:      logger,
        dispatcher:  base.NewEventDispatcher(),
    }
    handler.registerEventHandlers() // 自动注册子事件
    return handler
}

// EventHandler 工厂
func NewQuestionnairePublishedEventHandler(logger *slog.Logger) *QuestionnairePublishedEventHandler {
    return &QuestionnairePublishedEventHandler{
        BaseEventHandler: base.NewBaseEventHandler("questionnaire.published", logger),
    }
}
```

**优点**:
- 隐藏复杂的初始化逻辑
- 确保对象正确初始化（如自动注册事件处理器）
- 支持依赖注入

---

## 4. 模板方法模式 (Template Method Pattern)

**位置**: `handlers/base/template.go`

**职责**: 定义事件处理的标准流程骨架，允许子类定制特定步骤

```go
func (h *BaseEventHandler) HandleWithTemplate(
    ctx context.Context,
    payload []byte,
    validator func([]byte) error,           // 钩子1：验证
    parser func([]byte) (interface{}, error), // 钩子2：解析
    processor func(context.Context, interface{}) error, // 钩子3：处理
) error {
    // 1. 前置日志
    h.logger.Info("processing event", ...)
    
    // 2. 验证（钩子）
    if validator != nil {
        validator(payload)
    }
    
    // 3. 解析（钩子）
    data, _ := parser(payload)
    
    // 4. 处理业务逻辑（钩子）
    processor(ctx, data)
    
    // 5. 后置日志
    h.logger.Info("event processed successfully", ...)
}
```

**使用示例**:
```go
func (h *QuestionnairePublishedEventHandler) Handle(ctx context.Context, payload []byte) error {
    return h.HandleWithTemplate(
        ctx,
        payload,
        nil, // 无需额外验证
        func(p []byte) (interface{}, error) {
            var dto QuestionnairePublishedEventDTO
            json.Unmarshal(p, &dto)
            return dto, nil
        },
        func(ctx context.Context, data interface{}) error {
            dto := data.(QuestionnairePublishedEventDTO)
            // 业务逻辑：预热缓存
            return nil
        },
    )
}
```

**优点**:
- 统一事件处理流程（日志、验证、解析、处理）
- 减少重复代码
- 便于在流程中添加通用功能（如监控、追踪）

---

## 5. 责任链模式 (Chain of Responsibility Pattern)

**位置**: `handlers/base/chain.go`

**职责**: 将事件处理请求沿着处理链传递，允许多个中间件处理

```go
type EventMiddleware func(EventHandler) EventHandler

func NewChainableEventHandler(handler EventHandler, middlewares ...EventMiddleware) EventHandler {
    h := handler
    for i := len(middlewares) - 1; i >= 0; i-- {
        h = middlewares[i](h)
    }
    return h
}
```

### 内置中间件

#### 日志中间件
```go
func LoggingMiddleware(logger *slog.Logger) EventMiddleware {
    return func(next EventHandler) EventHandler {
        return &loggingHandler{next: next, logger: logger}
    }
}
```

#### 恢复中间件
```go
func RecoveryMiddleware(logger *slog.Logger) EventMiddleware {
    return func(next EventHandler) EventHandler {
        return &recoveryHandler{next: next, logger: logger}
    }
}
```

**使用示例**:
```go
handler := NewQuestionnairePublishedEventHandler(logger)
handler = NewChainableEventHandler(
    handler,
    LoggingMiddleware(logger),
    RecoveryMiddleware(logger),
    MetricsMiddleware(metrics),
)
```

**优点**:
- 支持横切关注点（日志、监控、恢复）
- 中间件可复用
- 易于添加新的中间件

---

## 目录结构与职责

```
handlers/
├── base/                          # 基础设施包
│   ├── handler.go                 # Handler 接口 + BaseHandler
│   ├── dispatcher.go              # EventDispatcher (策略模式)
│   ├── template.go                # BaseEventHandler (模板方法模式)
│   ├── chain.go                   # 中间件 (责任链模式)
│   └── utils.go                   # 工具函数
│
├── questionnaire/                 # 问卷域 (Topic: questionnaire.lifecycle)
│   ├── handler.go                 # QuestionnaireDomainHandler (聚合)
│   ├── events_questionnaire.go    # 问卷事件处理器 (策略)
│   ├── events_scale.go            # 量表事件处理器 (策略)
│   └── dtos.go                    # 事件 DTO
│
├── assessment/                    # 测评域 (Topic: assessment.lifecycle)
│   ├── handler.go                 # AssessmentDomainHandler (聚合)
│   ├── events.go                  # 测评事件处理器 (策略)
│   └── dtos.go                    # 事件 DTO
│
└── registry.go                    # Registry (注册表模式)
```

---

## 设计优势总结

### 1. 高内聚、低耦合
- 每个事件处理器独立封装，职责单一
- 事件处理器之间无直接依赖
- 通过接口和分发器解耦

### 2. 易于扩展
- 添加新事件：创建新的 EventHandler，注册到 Dispatcher
- 添加新 Topic：创建新的 DomainHandler 目录
- 添加新中间件：实现 EventMiddleware 接口

### 3. 易于测试
- 每个 EventHandler 可独立测试
- 可以 Mock Dispatcher 测试 DomainHandler
- 中间件可独立测试

### 4. 符合 SOLID 原则
- **S** (单一职责): 每个 EventHandler 只处理一种事件
- **O** (开闭原则): 扩展新事件无需修改现有代码
- **L** (里氏替换): EventHandler 可自由替换
- **I** (接口隔离): 接口最小化
- **D** (依赖倒置): 依赖抽象 (EventHandler 接口) 而非具体实现

---

## 使用示例

### 添加新事件类型

1. **创建事件处理器**
```go
// questionnaire/events_questionnaire.go
type QuestionnaireDeletedEventHandler struct {
    *base.BaseEventHandler
}

func NewQuestionnaireDeletedEventHandler(logger *slog.Logger) *QuestionnaireDeletedEventHandler {
    return &QuestionnaireDeletedEventHandler{
        BaseEventHandler: base.NewBaseEventHandler("questionnaire.deleted", logger),
    }
}

func (h *QuestionnaireDeletedEventHandler) Handle(ctx context.Context, payload []byte) error {
    // 处理逻辑
    return nil
}
```

2. **注册到 Dispatcher**
```go
// questionnaire/handler.go
func (h *QuestionnaireDomainHandler) registerEventHandlers() {
    // ... 现有注册
    h.dispatcher.Register(NewQuestionnaireDeletedEventHandler(h.logger))
}
```

完成！无需修改 switch-case，符合开闭原则。

---

## 对比：重构前 vs 重构后

### 重构前
```go
func (h *DomainHandler) Handle(ctx context.Context, payload []byte) error {
    eventType, _ := ExtractEventType(payload)
    
    switch eventType {
    case "questionnaire.published":
        return h.handleQuestionnairePublished(ctx, payload)
    case "questionnaire.unpublished":
        return h.handleQuestionnaireUnpublished(ctx, payload)
    // ... 7 个 case
    default:
        return nil
    }
}
```

### 重构后
```go
func (h *DomainHandler) Handle(ctx context.Context, payload []byte) error {
    eventType, _ := base.ExtractEventType(payload)
    return h.dispatcher.Dispatch(ctx, eventType, payload)
}
```

**改进**:
- 代码行数从 60+ 行减少到 3 行
- 消除了 switch-case
- 每个事件处理器独立文件，可并行开发
- 易于测试和维护
