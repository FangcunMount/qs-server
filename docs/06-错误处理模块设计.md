# âš ï¸ é”™è¯¯å¤„ç†æ¨¡å—è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [é”™è¯¯ç±»å‹ä½“ç³»](#error-type-system)
- [å †æ ˆè·Ÿè¸ªæœºåˆ¶](#stack-trace-mechanism)
- [é”™è¯¯ç ç®¡ç†ç³»ç»Ÿ](#error-code-management)
- [é”™è¯¯ä¼ æ’­ä¸åŒ…è£…](#error-propagation-wrapping)
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#practical-use-cases)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æœ¬é¡¹ç›®çš„é”™è¯¯å¤„ç†æ¨¡å—åŸºäº**pkg/errors**åº“æ„å»ºäº†å®Œæ•´çš„é”™è¯¯ç®¡ç†ä½“ç³»ï¼Œé‡‡ç”¨**å †æ ˆè·Ÿè¸ª**ã€**é”™è¯¯åŒ…è£…**å’Œ**é”™è¯¯ç æ˜ å°„**çš„è®¾è®¡ï¼Œå®ç°äº†ä¼ä¸šçº§çš„é”™è¯¯å¤„ç†å’Œè¯Šæ–­èƒ½åŠ›ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **å †æ ˆè·Ÿè¸ª**: å®Œæ•´çš„é”™è¯¯è°ƒç”¨æ ˆä¿¡æ¯
2. **é”™è¯¯åŒ…è£…**: æ”¯æŒé”™è¯¯ä¸Šä¸‹æ–‡çš„å±‚å±‚åŒ…è£…
3. **é”™è¯¯ç ç³»ç»Ÿ**: æ ‡å‡†åŒ–çš„é”™è¯¯ç ç®¡ç†
4. **ç±»å‹å®‰å…¨**: å¼ºç±»å‹çš„é”™è¯¯å¤„ç†
5. **å‘åå…¼å®¹**: ä¸Goæ ‡å‡†é”™è¯¯æ¥å£å…¼å®¹
6. **æ€§èƒ½ä¼˜åŒ–**: ä½å¼€é”€çš„é”™è¯¯å¤„ç†

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

- **é”™è¯¯å³å€¼**: é”™è¯¯æ˜¯ä¸€ç­‰å…¬æ°‘
- **ä¸Šä¸‹æ–‡ä¿ç•™**: ä¿ç•™å®Œæ•´çš„é”™è¯¯ä¸Šä¸‹æ–‡
- **å¿«é€Ÿå¤±è´¥**: é”™è¯¯åº”è¯¥å°½æ—©è¢«å‘ç°å’Œå¤„ç†
- **æ¸…æ™°è¡¨è¾¾**: é”™è¯¯ä¿¡æ¯åº”è¯¥æ¸…æ™°æ˜“æ‡‚
- **å¯è¿½æº¯æ€§**: æ”¯æŒå®Œæ•´çš„é”™è¯¯è¿½è¸ª

## ğŸ›ï¸ é”™è¯¯ç±»å‹ä½“ç³» {#error-type-system}

### ğŸ“¦ æ ¸å¿ƒé”™è¯¯ç»“æ„

```go
// pkg/errors/errors.go

// fundamental åŸºç¡€é”™è¯¯ç±»å‹
type fundamental struct {
    msg string    // é”™è¯¯æ¶ˆæ¯
    *stack       // å †æ ˆä¿¡æ¯
}

func (f *fundamental) Error() string { 
    return f.msg 
}

// withStack å¸¦å †æ ˆçš„é”™è¯¯
type withStack struct {
    error       // åŒ…è£…çš„åŸå§‹é”™è¯¯
    *stack     // å †æ ˆä¿¡æ¯
}

func (w *withStack) Cause() error { 
    return w.error 
}

// withMessage å¸¦æ¶ˆæ¯çš„é”™è¯¯
type withMessage struct {
    cause error  // åŸå§‹é”™è¯¯
    msg   string // é™„åŠ æ¶ˆæ¯
}

func (w *withMessage) Error() string { 
    return w.msg 
}

func (w *withMessage) Cause() error  { 
    return w.cause 
}

// withCode å¸¦é”™è¯¯ç çš„é”™è¯¯
type withCode struct {
    err   error   // åŒ…è£…çš„é”™è¯¯
    code  int     // é”™è¯¯ç 
    cause error   // åŸå§‹é”™è¯¯
    *stack       // å †æ ˆä¿¡æ¯
}
```

### ğŸ”§ é”™è¯¯åˆ›å»ºAPI

#### 1. åŸºç¡€é”™è¯¯åˆ›å»º

```go
// New åˆ›å»ºæ–°é”™è¯¯ï¼ˆå¸¦å †æ ˆï¼‰
func New(message string) error {
    return &fundamental{
        msg:   message,
        stack: callers(),
    }
}

// Errorf æ ¼å¼åŒ–åˆ›å»ºé”™è¯¯ï¼ˆå¸¦å †æ ˆï¼‰
func Errorf(format string, args ...interface{}) error {
    return &fundamental{
        msg:   fmt.Sprintf(format, args...),
        stack: callers(),
    }
}

// ä½¿ç”¨ç¤ºä¾‹
err1 := errors.New("æ•°æ®åº“è¿æ¥å¤±è´¥")
err2 := errors.Errorf("ç”¨æˆ· %s ä¸å­˜åœ¨", username)
```

#### 2. é”™è¯¯åŒ…è£…API

```go
// WithStack ä¸ºé”™è¯¯æ·»åŠ å †æ ˆä¿¡æ¯
func WithStack(err error) error {
    if err == nil {
        return nil
    }
    return &withStack{
        err,
        callers(),
    }
}

// Wrap åŒ…è£…é”™è¯¯å¹¶æ·»åŠ ä¸Šä¸‹æ–‡æ¶ˆæ¯
func Wrap(err error, message string) error {
    if err == nil {
        return nil
    }
    err = &withMessage{
        cause: err,
        msg:   message,
    }
    return &withStack{
        err,
        callers(),
    }
}

// Wrapf æ ¼å¼åŒ–åŒ…è£…é”™è¯¯
func Wrapf(err error, format string, args ...interface{}) error {
    if err == nil {
        return nil
    }
    err = &withMessage{
        cause: err,
        msg:   fmt.Sprintf(format, args...),
    }
    return &withStack{
        err,
        callers(),
    }
}

// ä½¿ç”¨ç¤ºä¾‹
originalErr := sql.ErrNoRows
wrappedErr := errors.Wrap(originalErr, "æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯å¤±è´¥")
contextErr := errors.Wrapf(wrappedErr, "å¤„ç†ç”¨æˆ·ID %d çš„è¯·æ±‚æ—¶å‡ºé”™", userID)
```

#### 3. å¸¦é”™è¯¯ç çš„é”™è¯¯

```go
// WithCode åˆ›å»ºå¸¦é”™è¯¯ç çš„é”™è¯¯
func WithCode(code int, format string, args ...interface{}) error {
    return &withCode{
        err:   fmt.Errorf(format, args...),
        code:  code,
        stack: callers(),
    }
}

// WrapC åŒ…è£…é”™è¯¯å¹¶æ·»åŠ é”™è¯¯ç 
func WrapC(err error, code int, format string, args ...interface{}) error {
    if err == nil {
        return nil
    }
    return &withCode{
        err:   fmt.Errorf(format, args...),
        code:  code,
        cause: err,
        stack: callers(),
    }
}

// ä½¿ç”¨ç¤ºä¾‹
err := errors.WithCode(40001, "ç”¨æˆ·å %s å·²å­˜åœ¨", username)
wrappedErr := errors.WrapC(dbErr, 50001, "æ•°æ®åº“æ“ä½œå¤±è´¥")
```

## ğŸ“Š å †æ ˆè·Ÿè¸ªæœºåˆ¶ {#stack-trace-mechanism}

### ğŸ” å †æ ˆä¿¡æ¯æ•è·

```go
// pkg/errors/stack.go

// Frame è¡¨ç¤ºå †æ ˆå¸§
type Frame uintptr

// pc è¿”å›ç¨‹åºè®¡æ•°å™¨
func (f Frame) pc() uintptr { return uintptr(f) - 1 }

// file è¿”å›æ–‡ä»¶å
func (f Frame) file() string {
    fn := runtime.FuncForPC(f.pc())
    if fn == nil {
        return "unknown"
    }
    file, _ := fn.FileLine(f.pc())
    return file
}

// line è¿”å›è¡Œå·
func (f Frame) line() int {
    fn := runtime.FuncForPC(f.pc())
    if fn == nil {
        return 0
    }
    _, line := fn.FileLine(f.pc())
    return line
}

// name è¿”å›å‡½æ•°å
func (f Frame) name() string {
    fn := runtime.FuncForPC(f.pc())
    if fn == nil {
        return "unknown"
    }
    return fn.Name()
}

// StackTrace å †æ ˆè·Ÿè¸ª
type StackTrace []Frame

// stack å †æ ˆä¿¡æ¯
type stack struct {
    *StackTrace
}

// callers æ•è·è°ƒç”¨æ ˆ
func callers() *stack {
    const depth = 32
    var pcs [depth]uintptr
    n := runtime.Callers(3, pcs[:])
    var st stack = pcs[0:n]
    return &st
}
```

### ğŸ¨ å †æ ˆæ ¼å¼åŒ–è¾“å‡º

```go
// Format å®ç° fmt.Formatter æ¥å£
func (f Frame) Format(s fmt.State, verb rune) {
    switch verb {
    case 's':
        switch {
        case s.Flag('+'):
            // +s: è¾“å‡ºå®Œæ•´è·¯å¾„å’Œå‡½æ•°å
            io.WriteString(s, f.name())
            io.WriteString(s, "\n\t")
            io.WriteString(s, f.file())
        default:
            // s: åªè¾“å‡ºå‡½æ•°å
            io.WriteString(s, path.Base(f.file()))
        }
    case 'd':
        // d: è¾“å‡ºè¡Œå·
        io.WriteString(s, strconv.Itoa(f.line()))
    case 'n':
        // n: è¾“å‡ºå‡½æ•°å
        io.WriteString(s, funcname(f.name()))
    case 'v':
        // v: é»˜è®¤æ ¼å¼
        f.Format(s, 's')
        io.WriteString(s, ":")
        f.Format(s, 'd')
    }
}

// å †æ ˆè·Ÿè¸ªæ ¼å¼åŒ–ç¤ºä¾‹
func demonstrateStackTrace() {
    err := errors.New("ç¤ºä¾‹é”™è¯¯")
    fmt.Printf("é”™è¯¯ä¿¡æ¯: %v\n", err)
    fmt.Printf("è¯¦ç»†å †æ ˆ: %+v\n", err)
}

// è¾“å‡ºç¤ºä¾‹:
// é”™è¯¯ä¿¡æ¯: ç¤ºä¾‹é”™è¯¯
// è¯¦ç»†å †æ ˆ: ç¤ºä¾‹é”™è¯¯
// main.demonstrateStackTrace
//     /path/to/main.go:123
// main.main
//     /path/to/main.go:100
// runtime.main
//     /usr/local/go/src/runtime/proc.go:250
```

## ğŸ·ï¸ é”™è¯¯ç ç®¡ç†ç³»ç»Ÿ {#error-code-management}

### ğŸ“Š é”™è¯¯ç å®šä¹‰

```go
// internal/pkg/code/base.go

// ErrCode é”™è¯¯ç ç±»å‹
type ErrCode struct {
    C    int    // é”™è¯¯ç 
    HTTP int    // HTTPçŠ¶æ€ç 
    Ext  string // æ‰©å±•æ¶ˆæ¯
    Ref  string // å‚è€ƒæ–‡æ¡£
}

// Code è¿”å›é”™è¯¯ç 
func (coder ErrCode) Code() int {
    return coder.C
}

// String è¿”å›é”™è¯¯ç çš„å­—ç¬¦ä¸²è¡¨ç¤º
func (coder ErrCode) String() string {
    return fmt.Sprintf("Code: %d, HTTP Status: %d, Message: %s, Reference: %s",
        coder.C, coder.HTTP, coder.Ext, coder.Ref)
}

// HTTPStatus è¿”å›HTTPçŠ¶æ€ç 
func (coder ErrCode) HTTPStatus() int {
    return coder.HTTP
}

// Reference è¿”å›å‚è€ƒæ–‡æ¡£
func (coder ErrCode) Reference() string {
    return coder.Ref
}
```

### ğŸ“ ä¸šåŠ¡é”™è¯¯ç å®šä¹‰

```go
// internal/pkg/code/apiserver.go

var (
    // é€šç”¨é”™è¯¯ç  (10xxx)
    ErrSuccess                 = ErrCode{10000, 200, "OK", ""}
    ErrUnknown                = ErrCode{10001, 500, "Internal server error", ""}
    ErrBind                   = ErrCode{10002, 400, "Error occurred while binding the request body to the struct", ""}
    ErrValidation             = ErrCode{10003, 400, "Validation failed", ""}
    ErrTokenInvalid           = ErrCode{10004, 401, "Token invalid", ""}
    
    // ç”¨æˆ·ç›¸å…³é”™è¯¯ç  (11xxx)
    ErrUserNotFound           = ErrCode{11001, 404, "User not found", ""}
    ErrUserAlreadyExists      = ErrCode{11002, 409, "User already exists", ""}
    ErrUserBasicInfoInvalid   = ErrCode{11003, 400, "User basic info invalid", ""}
    ErrUserPasswordInvalid    = ErrCode{11004, 400, "User password invalid", ""}
    ErrUserStatusInvalid      = ErrCode{11005, 400, "User status invalid", ""}
    
    // è®¤è¯ç›¸å…³é”™è¯¯ç  (12xxx)
    ErrAuthenticationFailed   = ErrCode{12001, 401, "Authentication failed", ""}
    ErrAuthorizationFailed    = ErrCode{12002, 403, "Authorization failed", ""}
    ErrTokenExpired           = ErrCode{12003, 401, "Token expired", ""}
    ErrTokenMalformed         = ErrCode{12004, 401, "Token malformed", ""}
    
    // æ•°æ®åº“ç›¸å…³é”™è¯¯ç  (13xxx)
    ErrDatabase               = ErrCode{13001, 500, "Database error", ""}
    ErrDuplicateKey           = ErrCode{13002, 409, "Duplicate key error", ""}
    ErrRecordNotFound         = ErrCode{13003, 404, "Record not found", ""}
    
    // å¤–éƒ¨æœåŠ¡é”™è¯¯ç  (14xxx)
    ErrExternalService        = ErrCode{14001, 500, "External service error", ""}
    ErrThirdPartyService      = ErrCode{14002, 500, "Third party service error", ""}
)
```

### ğŸ”§ é”™è¯¯ç æ³¨å†Œæœºåˆ¶

```go
// internal/pkg/code/register.go

// é”™è¯¯ç æ³¨å†Œè¡¨
var codes = map[int]ErrCode{}

// Register æ³¨å†Œé”™è¯¯ç 
func Register(code ErrCode) {
    if _, exists := codes[code.Code()]; exists {
        panic(fmt.Sprintf("é”™è¯¯ç  %d å·²ç»æ³¨å†Œ", code.Code()))
    }
    codes[code.Code()] = code
}

// MustRegister å¿…é¡»æ³¨å†ŒæˆåŠŸ
func MustRegister(code ErrCode) {
    Register(code)
}

// IsRegistered æ£€æŸ¥é”™è¯¯ç æ˜¯å¦å·²æ³¨å†Œ
func IsRegistered(code int) bool {
    _, exists := codes[code]
    return exists
}

// GetErrCode è·å–é”™è¯¯ç 
func GetErrCode(code int) (ErrCode, bool) {
    errCode, exists := codes[code]
    return errCode, exists
}

// init åˆå§‹åŒ–æ—¶æ³¨å†Œæ‰€æœ‰é”™è¯¯ç 
func init() {
    Register(ErrSuccess)
    Register(ErrUnknown)
    Register(ErrBind)
    // ... æ³¨å†Œæ‰€æœ‰é”™è¯¯ç 
}
```

## ğŸ”„ é”™è¯¯ä¼ æ’­ä¸åŒ…è£… {#error-propagation-wrapping}

### ğŸ“¤ é”™è¯¯é“¾ä¼ æ’­

```mermaid
graph TD
    subgraph "é”™è¯¯ä¼ æ’­é“¾"
        ORIGIN[åŸå§‹é”™è¯¯<br/>sql.ErrNoRows]
        REPO[ä»“å‚¨å±‚åŒ…è£…<br/>Wrap: "æŸ¥è¯¢ç”¨æˆ·å¤±è´¥"]
        APP[åº”ç”¨å±‚åŒ…è£…<br/>WrapC: code=11001]
        HANDLER[å¤„ç†å™¨å±‚åŒ…è£…<br/>Wrap: "è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥"]
        RESPONSE[HTTPå“åº”<br/>è½¬æ¢ä¸ºJSON]
    end
    
    ORIGIN --> REPO
    REPO --> APP
    APP --> HANDLER
    HANDLER --> RESPONSE
    
    style ORIGIN fill:#ffeb3b
    style REPO fill:#ff9800
    style APP fill:#f44336
    style HANDLER fill:#9c27b0
    style RESPONSE fill:#2196f3
```

### ğŸ”§ é”™è¯¯å¤„ç†æ¨¡å¼

#### 1. ä»“å‚¨å±‚é”™è¯¯å¤„ç†

```go
// internal/apiserver/adapters/driven/mysql/user/repo.go

func (r *Repository) FindByUsername(ctx context.Context, username string) (*user.User, error) {
    var entity UserEntity
    err := r.BaseRepository.FindByField(ctx, &entity, "username", username)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            // è½¬æ¢ä¸ºä¸šåŠ¡é”™è¯¯
            return nil, errors.WithCode(code.ErrUserNotFound, 
                "ç”¨æˆ·ä¸å­˜åœ¨: %s", username)
        }
        // åŒ…è£…æ•°æ®åº“é”™è¯¯
        return nil, errors.WrapC(err, code.ErrDatabase, 
            "æŸ¥è¯¢ç”¨æˆ·å¤±è´¥: username=%s", username)
    }
    return r.mapper.ToDomain(&entity), nil
}
```

#### 2. åº”ç”¨å±‚é”™è¯¯å¤„ç†

```go
// internal/apiserver/application/user/queryer.go

func (q *UserQueryer) GetUserByUsername(ctx context.Context, username string) (*port.UserResponse, error) {
    user, err := q.userRepo.FindByUsername(ctx, username)
    if err != nil {
        // æ£€æŸ¥æ˜¯å¦ä¸ºä¸šåŠ¡é”™è¯¯
        if code.IsErrCode(err, code.ErrUserNotFound) {
            return nil, err // ç›´æ¥ä¼ æ’­ä¸šåŠ¡é”™è¯¯
        }
        // åŒ…è£…å…¶ä»–é”™è¯¯
        return nil, errors.Wrap(err, "è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥")
    }
    
    return &port.UserResponse{
        ID:       user.ID().Value(),
        Username: user.Username(),
        // ... å…¶ä»–å­—æ®µ
    }, nil
}
```

#### 3. å¤„ç†å™¨å±‚é”™è¯¯å¤„ç†

```go
// internal/apiserver/adapters/driving/restful/user/handler.go

func (h *Handler) GetUserByUsername(c *gin.Context) {
    username := c.Param("username")
    
    userResp, err := h.userQueryer.GetUserByUsername(c.Request.Context(), username)
    if err != nil {
        // è®°å½•é”™è¯¯æ—¥å¿—
        log.L(c).Errorw("è·å–ç”¨æˆ·å¤±è´¥",
            "username", username,
            "error", err,
        )
        
        // è½¬æ¢ä¸ºHTTPå“åº”
        h.ErrorResponse(c, err)
        return
    }
    
    h.SuccessResponse(c, userResp)
}
```

### ğŸŒ HTTPé”™è¯¯å“åº”è½¬æ¢

```go
// pkg/core/core.go

// WriteResponse ç»Ÿä¸€å“åº”å†™å…¥
func WriteResponse(c *gin.Context, err error, data interface{}) {
    if err != nil {
        // æå–é”™è¯¯ç ä¿¡æ¯
        var (
            code    = code.ErrUnknown.Code()
            message = err.Error()
            httpStatus = code.ErrUnknown.HTTPStatus()
        )
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºå¸¦é”™è¯¯ç çš„é”™è¯¯
        if coder := extractErrCode(err); coder != nil {
            code = coder.Code()
            message = coder.Ext
            httpStatus = coder.HTTPStatus()
        }
        
        // è®°å½•é”™è¯¯
        log.L(c).Errorw("APIé”™è¯¯å“åº”",
            "code", code,
            "message", message,
            "error", err,
        )
        
        // è¿”å›é”™è¯¯å“åº”
        c.JSON(httpStatus, gin.H{
            "code":    code,
            "message": message,
        })
        return
    }
    
    // è¿”å›æˆåŠŸå“åº”
    c.JSON(http.StatusOK, gin.H{
        "code":    code.ErrSuccess.Code(),
        "message": "success",
        "data":    data,
    })
}

// æå–é”™è¯¯ç 
func extractErrCode(err error) *code.ErrCode {
    if err == nil {
        return nil
    }
    
    // éå†é”™è¯¯é“¾æŸ¥æ‰¾å¸¦é”™è¯¯ç çš„é”™è¯¯
    for err != nil {
        if coder, ok := err.(interface{ Code() int }); ok {
            if errCode, exists := code.GetErrCode(coder.Code()); exists {
                return &errCode
            }
        }
        
        // æ£€æŸ¥Causeæ¥å£
        if causer, ok := err.(interface{ Cause() error }); ok {
            err = causer.Cause()
        } else {
            break
        }
    }
    
    return nil
}
```

## ğŸ› ï¸ é”™è¯¯å·¥å…·å‡½æ•°

### ğŸ” é”™è¯¯æ£€æŸ¥å·¥å…·

```go
// pkg/errors/utils.go

// Cause è·å–æ ¹æœ¬åŸå› 
func Cause(err error) error {
    type causer interface {
        Cause() error
    }

    for err != nil {
        cause, ok := err.(causer)
        if !ok {
            break
        }
        if cause.Cause() == nil {
            break
        }
        err = cause.Cause()
    }
    return err
}

// Is æ£€æŸ¥é”™è¯¯ç±»å‹ (Go 1.13+ å…¼å®¹)
func Is(err, target error) bool {
    if target == nil {
        return err == target
    }

    isComparable := reflect.TypeOf(target).Comparable()
    for {
        if isComparable && err == target {
            return true
        }
        if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
            return true
        }
        if err = Unwrap(err); err == nil {
            return false
        }
    }
}

// As ç±»å‹æ–­è¨€ (Go 1.13+ å…¼å®¹)
func As(err error, target interface{}) bool {
    if target == nil {
        panic("errors: target cannot be nil")
    }
    val := reflect.ValueOf(target)
    typ := val.Type()
    if typ.Kind() != reflect.Ptr || val.Elem().Kind() == reflect.Interface {
        panic("errors: target must be a non-nil pointer to either a type that implements error, or to any interface type")
    }
    targetType := typ.Elem()
    for err != nil {
        if reflect.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflect.ValueOf(err))
            return true
        }
        if x, ok := err.(interface{ As(interface{}) bool }); ok && x.As(target) {
            return true
        }
        err = Unwrap(err)
    }
    return false
}

// Unwrap è§£åŒ…é”™è¯¯
func Unwrap(err error) error {
    type unwrapper interface {
        Unwrap() error
    }
    if u, ok := err.(unwrapper); ok {
        return u.Unwrap()
    }
    return nil
}
```

### ğŸ“Š é”™è¯¯ç»Ÿè®¡å’Œåˆ†æ

```go
// pkg/errors/stats.go

// ErrorStats é”™è¯¯ç»Ÿè®¡
type ErrorStats struct {
    mu    sync.RWMutex
    stats map[int]*ErrorStat
}

type ErrorStat struct {
    Code       int       `json:"code"`
    Count      int64     `json:"count"`
    LastSeen   time.Time `json:"last_seen"`
    FirstSeen  time.Time `json:"first_seen"`
    Message    string    `json:"message"`
}

var globalStats = &ErrorStats{
    stats: make(map[int]*ErrorStat),
}

// Record è®°å½•é”™è¯¯ç»Ÿè®¡
func (es *ErrorStats) Record(code int, message string) {
    es.mu.Lock()
    defer es.mu.Unlock()
    
    now := time.Now()
    stat, exists := es.stats[code]
    if !exists {
        stat = &ErrorStat{
            Code:      code,
            Count:     0,
            FirstSeen: now,
            Message:   message,
        }
        es.stats[code] = stat
    }
    
    stat.Count++
    stat.LastSeen = now
    if message != "" {
        stat.Message = message
    }
}

// GetStats è·å–é”™è¯¯ç»Ÿè®¡
func (es *ErrorStats) GetStats() []*ErrorStat {
    es.mu.RLock()
    defer es.mu.RUnlock()
    
    stats := make([]*ErrorStat, 0, len(es.stats))
    for _, stat := range es.stats {
        stats = append(stats, &ErrorStat{
            Code:      stat.Code,
            Count:     stat.Count,
            LastSeen:  stat.LastSeen,
            FirstSeen: stat.FirstSeen,
            Message:   stat.Message,
        })
    }
    return stats
}

// RecordError è®°å½•é”™è¯¯åˆ°å…¨å±€ç»Ÿè®¡
func RecordError(err error) {
    if coder := extractErrCode(err); coder != nil {
        globalStats.Record(coder.Code(), coder.Ext)
    }
}
```

## ğŸ“š å®é™…åº”ç”¨æ¡ˆä¾‹ {#practical-use-cases}

### ğŸ—ï¸ å®Œæ•´é”™è¯¯å¤„ç†æµç¨‹

```go
// 1. æ•°æ®å±‚é”™è¯¯
func (r *UserRepository) Save(ctx context.Context, user *domain.User) error {
    entity := r.mapper.ToEntity(user)
    if err := r.db.WithContext(ctx).Create(entity).Error; err != nil {
        if isDuplicateKeyError(err) {
            return errors.WithCode(code.ErrDuplicateKey, 
                "ç”¨æˆ·åå·²å­˜åœ¨: %s", user.Username())
        }
        return errors.WrapC(err, code.ErrDatabase, 
            "ä¿å­˜ç”¨æˆ·å¤±è´¥: %s", user.Username())
    }
    return nil
}

// 2. åº”ç”¨å±‚é”™è¯¯å¤„ç†
func (c *UserCreator) CreateUser(ctx context.Context, req CreateUserRequest) (*UserResponse, error) {
    // éªŒè¯å‚æ•°
    if err := c.validateRequest(req); err != nil {
        return nil, errors.WithCode(code.ErrValidation, 
            "ç”¨æˆ·åˆ›å»ºå‚æ•°æ— æ•ˆ: %v", err)
    }
    
    // åˆ›å»ºç”¨æˆ·å¯¹è±¡
    user, err := c.buildUser(req)
    if err != nil {
        return nil, errors.Wrap(err, "æ„å»ºç”¨æˆ·å¯¹è±¡å¤±è´¥")
    }
    
    // ä¿å­˜ç”¨æˆ·
    if err := c.userRepo.Save(ctx, user); err != nil {
        return nil, errors.Wrap(err, "åˆ›å»ºç”¨æˆ·å¤±è´¥")
    }
    
    return c.buildResponse(user), nil
}

// 3. HTTPå¤„ç†å™¨é”™è¯¯å¤„ç†
func (h *UserHandler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        log.L(c).Errorw("å‚æ•°ç»‘å®šå¤±è´¥", "error", err)
        core.WriteResponse(c, errors.WithCode(code.ErrBind, err.Error()), nil)
        return
    }
    
    resp, err := h.userCreator.CreateUser(c.Request.Context(), req)
    if err != nil {
        log.L(c).Errorw("åˆ›å»ºç”¨æˆ·å¤±è´¥", 
            "request", req,
            "error", err,
        )
        // è®°å½•é”™è¯¯ç»Ÿè®¡
        RecordError(err)
        core.WriteResponse(c, err, nil)
        return
    }
    
    core.WriteResponse(c, nil, resp)
}
```

### ğŸ“Š é”™è¯¯ç›‘æ§å’Œå‘Šè­¦

```go
// internal/pkg/middleware/error_monitor.go

// ErrorMonitorMiddleware é”™è¯¯ç›‘æ§ä¸­é—´ä»¶
func ErrorMonitorMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        // å¤„ç†è¯·æ±‚
        c.Next()
        
        // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
        if len(c.Errors) > 0 {
            for _, ginErr := range c.Errors {
                // è®°å½•é”™è¯¯ç»Ÿè®¡
                RecordError(ginErr.Err)
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
                if shouldAlert(ginErr.Err) {
                    alertError(c, ginErr.Err, time.Since(start))
                }
            }
        }
    }
}

// é”™è¯¯å‘Šè­¦é€»è¾‘
func shouldAlert(err error) bool {
    if coder := extractErrCode(err); coder != nil {
        // 5xxé”™è¯¯éœ€è¦å‘Šè­¦
        return coder.HTTPStatus() >= 500
    }
    return false
}

func alertError(c *gin.Context, err error, duration time.Duration) {
    alert := map[string]interface{}{
        "timestamp": time.Now(),
        "method":    c.Request.Method,
        "path":      c.Request.URL.Path,
        "error":     err.Error(),
        "duration":  duration,
        "client_ip": c.ClientIP(),
        "user_agent": c.Request.UserAgent(),
    }
    
    // å‘é€å‘Šè­¦ï¼ˆå¯ä»¥æ˜¯é‚®ä»¶ã€çŸ­ä¿¡ã€é’‰é’‰ç­‰ï¼‰
    sendAlert(alert)
}
```

## ğŸ¯ è®¾è®¡æ€»ç»“

é”™è¯¯å¤„ç†æ¨¡å—è®¾è®¡å®ç°äº†ï¼š

### 1. **å®Œæ•´çš„é”™è¯¯ä¿¡æ¯**

- å †æ ˆè·Ÿè¸ªæä¾›ç²¾ç¡®çš„é”™è¯¯ä½ç½®
- é”™è¯¯åŒ…è£…ä¿ç•™å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
- é”™è¯¯ç ç³»ç»Ÿæ ‡å‡†åŒ–é”™è¯¯åˆ†ç±»

### 2. **é«˜æ•ˆçš„é”™è¯¯å¤„ç†**

- é›¶åˆ†é…çš„é”™è¯¯åˆ›å»º
- å»¶è¿Ÿå †æ ˆä¿¡æ¯è®¡ç®—
- é”™è¯¯é“¾å¿«é€Ÿéå†

### 3. **ä¼ä¸šçº§ç‰¹æ€§**

- é”™è¯¯ç»Ÿè®¡å’Œåˆ†æ
- é”™è¯¯ç›‘æ§å’Œå‘Šè­¦
- è¯¦ç»†çš„é”™è¯¯æ–‡æ¡£

### 4. **å¼€å‘å‹å¥½**

- ä¸°å¯Œçš„APIæ¥å£
- å‘åå…¼å®¹Goæ ‡å‡†åº“
- æ¸…æ™°çš„é”™è¯¯ä¼ æ’­é“¾

### 5. **ç”Ÿäº§å°±ç»ª**

- å®Œæ•´çš„é”™è¯¯åˆ†ç±»ä½“ç³»
- è‡ªåŠ¨åŒ–é”™è¯¯å¤„ç†
- é”™è¯¯è¶‹åŠ¿åˆ†æ

è¿™ç§è®¾è®¡ä¸ºæ„å»ºå¯é çš„ä¼ä¸šçº§Goåº”ç”¨æä¾›äº†åšå®çš„é”™è¯¯å¤„ç†åŸºç¡€ã€‚
