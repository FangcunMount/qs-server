# 11-07 测评计划子域设计（V2）

> **版本**：V2.0  
> **范围**：问卷&量表 BC 中的 plan 子域  
> **目标**：阐述测评计划子域的核心职责、周期性测评管理业务设计、与其他子域的协作关系

---

## 1. Plan 子域的定位与职责

### 1.1 子域边界

**plan 子域关注的核心问题**：

* **周期性测评管理**：针对单个受试者制定长期、周期性的测评计划
* **测评任务调度**：按时间规则自动生成测评任务并推送通知
* **计划执行追踪**：跟踪每次测评任务的完成情况，支持填写率统计
* **上游业务集成**：接收来自互联网医院、行为训练中心等业务 BC 的计划创建请求

**plan 子域不关心的问题**：

* "问卷怎么展示、如何填写"：这是 survey 子域的职责
* "如何计分和解读"：这是 scale 子域的职责
* "批量筛查项目"：这是 screening 子域的职责

### 1.2 核心聚合

plan 子域包含两个核心聚合：

1. **AssessmentPlan 聚合根**：测评计划
   * 描述对某个 Testee 在一段时间内进行若干次测评的策略
   * 管理计划状态（active / paused / finished / canceled）
   * 定义周期规则（按周、按天、固定日期等）

2. **AssessmentTask 实体**：测评任务
   * 计划分解后的"应测实例"，代表第 N 次测评
   * 管理任务状态（pending / opened / completed / expired）
   * 与 Assessment 关联（1:0..1 关系）

### 1.3 与其他子域的关系

* **依赖** user 子域：引用 TesteeID
* **依赖** survey 子域：引用 QuestionnaireCode
* **依赖** scale 子域：引用 MedicalScaleID（可选）
* **被引用** assessment 子域：AssessmentTask 创建 Assessment 时记录 originType=plan

**计划归属决策（方案 A）**：

* **测评计划归问卷&量表 BC 管理**
* 上游 BC（互联网医院、行为训练中心）只负责决策"要什么计划"
* 问卷 BC 负责计划实体 + 生命周期 + 调度执行

```text
上游 BC (医院/训练中心)          问卷&量表 BC
┌─────────────────┐              ┌─────────────────────┐
│ 医生下医嘱       │              │                     │
│ 学员签约         │ ─────────>   │ CreatePlan API      │
│                 │   命令/事件   │                     │
└─────────────────┘              │ EnsureTestee        │
                                  │ Create Plan         │
                                  │ Generate Tasks      │
                                  │ Schedule & Notify   │
                                  └─────────────────────┘
```

---

## 2. 周期性测评管理业务

### 2.1 业务场景

***场景 1：互联网医院随访测评**

* 患者出院后，医生为其制定随访测评计划
* 例如：每 4 周进行一次心理量表测评，共 6 次
* 系统定时生成测评任务，推送通知给患者

***场景 2：行为训练中心周期评估***

* 学员入校/签约后，按照课时或周数生成测评计划
* 例如：在第 2、4、8、12 周分别进行行为评估
* 系统自动生成测评任务，推送给家长

***场景 3：慢病管理定期测评***

* 慢病患者定期进行健康量表测评
* 例如：每 2 周一次，持续 3 个月
* 系统自动提醒并记录完成情况

### 2.2 核心业务流程

#### 2.2.1 创建测评计划

```text
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│上游 BC   │────>│问卷 BC   │────>│Testee    │────>│Plan      │
│医生决策  │ 命令 │应用服务  │查询/创建│实体      │创建  │聚合      │
└──────────┘     └──────────┘     └──────────┘     └──────────┘
                      │
                      ▼
                 ┌──────────┐
                 │Task      │
                 │任务生成  │
                 └──────────┘
```

**步骤说明**：

1. **上游 BC 发起命令**：`POST /assessment-plans`

   ```json
   {
     "iam_child_id": 123,
     "org_id": 10,
     "questionnaire_id": 456,
     "medical_scale_id": 789,
     "schedule_type": "by_week",
     "interval": 4,
     "total_times": 6,
     "start_date": "2025-01-01"
   }
   ```

2. **EnsureTestee**：确保受试者存在
   * 根据 `iam_child_id + org_id` 查询 Testee
   * 若不存在，从 IAM 拉取 Child 信息创建 Testee

3. **创建 AssessmentPlan**：
   * 关联 TesteeID
   * 设置周期规则
   * 初始状态为 active

4. **生成 AssessmentTask**：
   * 根据周期规则生成所有任务（简单版：一次性生成）
   * 每个任务标记计划时间点（plannedAt）

#### 2.2.2 定时调度与推送

```text
定时任务（每小时/每天）
    │
    ▼
扫描 Task (status=pending, plannedAt <= now)
    │
    ▼
生成测评入口（二维码/链接）
    │
    ▼
发送通知（短信/小程序/邮件）
    │
    ▼
更新 Task (status=opened, openAt=now)
```

#### 2.2.3 用户填写与完成

```text
用户点击入口 ────> 进入答题页面 ────> 提交答卷
    │                                     │
    ▼                                     ▼
查询 Task                          创建 Assessment
验证状态                           (originType=plan)
    │                                     │
    ▼                                     ▼
展示问卷                           创建 AnswerSheet
    │                                     │
    ▼                                     ▼
实时保存                           更新 Task
(draft)                            (status=completed)
                                        │
                                        ▼
                                   发布事件
                                   (AssessmentSubmittedEvent)
```

#### 2.2.4 过期处理

```text
定时任务（每天）
    │
    ▼
扫描 Task (status=opened, expireAt <= now)
    │
    ▼
更新 Task (status=expired)
```

### 2.3 计划创建时 Testee 的生成

**关键原则**：Testee 在第一次创建测评计划时懒创建

```go
func (s *PlanAppService) CreatePlan(ctx context.Context, cmd CreatePlanCmd) (*AssessmentPlan, error) {
    // 1. 先确保 Testee 存在（幂等创建）
    testee, err := s.testeeSvc.EnsureTestee(ctx, EnsureTesteeKey{
        IamUserID:  cmd.IamUserID,
        IamChildID: cmd.IamChildID,
        OrgID:      cmd.OrgID,
    })
    if err != nil {
        return nil, err
    }

    // 2. 创建 Plan，关联 TesteeID
    plan := domain.NewAssessmentPlan(testee.ID, cmd)
    if err := s.planRepo.Save(ctx, plan); err != nil {
        return nil, err
    }

    // 3. 生成 Tasks
    tasks := s.taskGenerator.GenerateTasks(plan)
    if err := s.taskRepo.SaveBatch(ctx, tasks); err != nil {
        return nil, err
    }

    return plan, nil
}
```

**EnsureTestee 逻辑**：

```go
func (s *TesteeAppService) EnsureTestee(ctx context.Context, key EnsureTesteeKey) (*Testee, error) {
    // 1. 先查现有的
    testee, err := s.testeeRepo.FindByKey(ctx, key)
    if err == nil {
        return testee, nil
    }
    if !errors.Is(err, domain.ErrNotFound) {
        return nil, err
    }

    // 2. 不存在 => 去 IAM 拉 child 信息
    profile, err := s.iamClient.FetchChildProfile(ctx, key.IamChildID)
    if err != nil {
        return nil, err
    }

    // 3. 创建 Testee
    testee = domain.NewTesteeFromProfile(profile, key)

    // 4. 持久化（带唯一约束做幂等）
    if err := s.testeeRepo.Save(ctx, testee); err != nil {
        if isDuplicateKey(err) {
            // 并发下被其他请求先建了，再查一遍
            return s.testeeRepo.FindByKey(ctx, key)
        }
        return nil, err
    }

    return testee, nil
}
```

---

## 3. AssessmentPlan 聚合根

### 3.1 聚合根定位

AssessmentPlan 是 plan 子域的核心聚合根，代表"针对某个 Testee 的周期性测评策略"。

**核心职责**：

1. 描述"应该如何测"的策略（对谁、测什么、什么时候测）
2. 管理计划生命周期（启用、暂停、结束、取消）
3. 不关心每一次是否完成（由 Task 负责）

### 3.2 聚合根结构

```go
type AssessmentPlanID string

// 计划状态
type PlanStatus string

const (
    PlanStatusActive   PlanStatus = "active"   // 活跃
    PlanStatusPaused   PlanStatus = "paused"   // 暂停
    PlanStatusFinished PlanStatus = "finished" // 已完成
    PlanStatusCanceled PlanStatus = "canceled" // 已取消
)

// 计划周期类型
type PlanScheduleType string

const (
    PlanScheduleByWeek    PlanScheduleType = "by_week"    // 每 N 周一次
    PlanScheduleByDay     PlanScheduleType = "by_day"     // 每 N 天一次
    PlanScheduleFixedDate PlanScheduleType = "fixed_date" // 指定日期列表
    PlanScheduleCustom    PlanScheduleType = "custom"     // 自定义周次（如 2,4,8,12）
)

type AssessmentPlan struct {
    // 基本标识
    id     AssessmentPlanID
    orgID  int64

    // 关联实体
    testeeID  user.TesteeID
    scaleID   scale.MedicalScaleID

    // 周期策略
    scheduleType  PlanScheduleType
    interval      int           // 间隔 N 周/天（用于 by_week / by_day）
    totalTimes    int           // 计划总次数
    fixedDates    []time.Time   // 固定日期列表（用于 fixed_date）
    customWeeks   []int         // 自定义周次（用于 custom，如 [2,4,8,12]）

    // 时间范围
    startDate     time.Time
    endDate       *time.Time

    // 状态
    status        PlanStatus

    // 审计字段
    createdBy     user.StaffID
    createdAt     time.Time
    updatedAt     time.Time
    deletedAt     *time.Time
    version       int64
}
```

### 3.3 构造函数与核心方法

```go
// NewAssessmentPlan 创建测评计划
func NewAssessmentPlan(
    orgID int64,
    testeeID user.TesteeID,
    scaleID scale.MedicalScaleID,
    scheduleType PlanScheduleType,
    interval int,
    totalTimes int,
    startDate time.Time,
    createdBy user.StaffID,
) *AssessmentPlan {
    now := time.Now()

    return &AssessmentPlan{
        id:           NewAssessmentPlanID(),
        orgID:        orgID,
        testeeID:     testeeID,
        scaleID:      scaleID,
        scheduleType: scheduleType,
        interval:     interval,
        totalTimes:   totalTimes,
        startDate:    startDate,
        status:       PlanStatusActive,
        createdBy:    createdBy,
        createdAt:    now,
        updatedAt:    now,
    }
}

// Pause 暂停计划
func (p *AssessmentPlan) Pause() error {
    if p.status != PlanStatusActive {
        return ErrPlanNotActive
    }
    p.status = PlanStatusPaused
    p.updatedAt = time.Now()
    return nil
}

// Resume 恢复计划
func (p *AssessmentPlan) Resume() error {
    if p.status != PlanStatusPaused {
        return ErrPlanNotPaused
    }
    p.status = PlanStatusActive
    p.updatedAt = time.Now()
    return nil
}

// Finish 完成计划
func (p *AssessmentPlan) Finish() {
    p.status = PlanStatusFinished
    p.updatedAt = time.Now()
}

// Cancel 取消计划
func (p *AssessmentPlan) Cancel() {
    p.status = PlanStatusCanceled
    p.updatedAt = time.Now()
}
```

---

## 4. AssessmentTask 实体

### 4.1 实体定位

AssessmentTask 是计划分解后的"应测实例"，代表"第 N 次测评"。

**核心职责**：

1. 记录计划的第 N 次测评应该在什么时候进行
2. 管理任务状态（待推送、已推送、已完成、已过期）
3. 与 Assessment 关联（1:0..1 关系）

### 4.2 实体结构

```go
type AssessmentTaskID string

// 任务状态
type TaskStatus string

const (
    TaskStatusPending   TaskStatus = "pending"   // 待推送
    TaskStatusOpened    TaskStatus = "opened"    // 已推送（生成了入口）
    TaskStatusCompleted TaskStatus = "completed" // 已完成
    TaskStatusExpired   TaskStatus = "expired"   // 已过期
    TaskStatusCanceled  TaskStatus = "canceled"  // 已取消
)

type AssessmentTask struct {
    // 基本标识
    id       AssessmentTaskID
    planID   AssessmentPlanID
    seq      int             // 第 N 次测评

    // 关联实体
    testeeID  user.TesteeID
    scaleID   scale.MedicalScaleID

    // 时间点
    plannedAt     time.Time       // 计划时间点
    openAt        *time.Time      // 实际开放时间
    expireAt      *time.Time      // 截止时间
    completedAt   *time.Time      // 完成时间

    // 状态与关联
    status        TaskStatus
    assessmentID  *assessment.AssessmentID

    // 入口信息
    entryToken    string          // 入口令牌（用于生成二维码/链接）
    entryURL      string          // 入口 URL

    // 审计字段
    createdAt     time.Time
    updatedAt     time.Time
    version       int64
}
```

### 4.3 核心方法

```go
// Open 开放任务（生成入口）
func (t *AssessmentTask) Open(entryToken string, entryURL string, expireAt time.Time) error {
    if t.status != TaskStatusPending {
        return ErrTaskNotPending
    }

    now := time.Now()
    t.status = TaskStatusOpened
    t.openAt = &now
    t.expireAt = &expireAt
    t.entryToken = entryToken
    t.entryURL = entryURL
    t.updatedAt = now

    return nil
}

// Complete 完成任务
func (t *AssessmentTask) Complete(assessmentID assessment.AssessmentID) error {
    if t.status != TaskStatusOpened {
        return ErrTaskNotOpened
    }

    now := time.Now()
    t.status = TaskStatusCompleted
    t.completedAt = &now
    t.assessmentID = &assessmentID
    t.updatedAt = now

    return nil
}

// Expire 过期任务
func (t *AssessmentTask) Expire() error {
    if t.status != TaskStatusOpened {
        return ErrTaskNotOpened
    }

    t.status = TaskStatusExpired
    t.updatedAt = time.Now()

    return nil
}

// Cancel 取消任务
func (t *AssessmentTask) Cancel() {
    t.status = TaskStatusCanceled
    t.updatedAt = time.Now()
}
```

---

## 5. Plan 与 Task 的生成策略

### 5.1 一次性生成全部 Task（简单版 - 推荐）

**适用场景**：测评次数不多（≤ 50 次）

**生成时机**：创建计划时立即生成所有 Task

**优点**：

* 逻辑简单，易于实现
* 查询方便，可直接展示所有任务
* 前端可一次性展示完整计划

**缺点**：

* 计划跨度很大时数据量较多
* 修改计划周期需要重新生成 Task

**实现示例**：

```go
func (g *TaskGenerator) GenerateTasks(plan *AssessmentPlan) []*AssessmentTask {
    var tasks []*AssessmentTask

    switch plan.ScheduleType() {
    case PlanScheduleByWeek:
        // 每 N 周一次
        for i := 0; i < plan.TotalTimes(); i++ {
            plannedAt := plan.StartDate().Add(time.Duration(i*plan.Interval()) * 7 * 24 * time.Hour)
            task := NewAssessmentTask(plan.ID(), i+1, plan.TesteeID(), plan.ScaleID(), plannedAt)
            tasks = append(tasks, task)
        }

    case PlanScheduleByDay:
        // 每 N 天一次
        for i := 0; i < plan.TotalTimes(); i++ {
            plannedAt := plan.StartDate().Add(time.Duration(i*plan.Interval()) * 24 * time.Hour)
            task := NewAssessmentTask(plan.ID(), i+1, plan.TesteeID(), plan.ScaleID(), plannedAt)
            tasks = append(tasks, task)
        }

    case PlanScheduleCustom:
        // 自定义周次（如 [2,4,8,12]）
        for i, week := range plan.CustomWeeks() {
            plannedAt := plan.StartDate().Add(time.Duration(week) * 7 * 24 * time.Hour)
            task := NewAssessmentTask(plan.ID(), i+1, plan.TesteeID(), plan.ScaleID(), plannedAt)
            tasks = append(tasks, task)
        }

    case PlanScheduleFixedDate:
        // 固定日期列表
        for i, date := range plan.FixedDates() {
            task := NewAssessmentTask(plan.ID(), i+1, plan.TesteeID(), plan.ScaleID(), date)
            tasks = append(tasks, task)
        }
    }

    return tasks
}
```

### 5.2 定时生成 Task（进阶版）

**适用场景**：计划跨度很大（数年）或次数很多

**生成时机**：定时任务扫描计划，生成未来 N 天内的 Task

**优点**：

* 数据量可控
* 支持超长周期计划

**缺点**：

* 逻辑复杂
* 需要定时任务支持

**实现示例**：

```go
// 定时任务：每天凌晨执行
func (job *TaskGeneratorJob) Run(ctx context.Context) {
    // 查询所有 active 的计划
    plans, err := job.planRepo.FindActiveComments(ctx)
    if err != nil {
        return
    }

    for _, plan := range plans {
        // 生成未来 30 天内的任务
        endDate := time.Now().Add(30 * 24 * time.Hour)
        tasks := job.generator.GenerateTasksUntil(plan, endDate)

        // 过滤已存在的任务
        existingTasks, _ := job.taskRepo.FindByPlanID(ctx, plan.ID())
        newTasks := filterNewTasks(tasks, existingTasks)

        // 保存新任务
        if err := job.taskRepo.SaveBatch(ctx, newTasks); err != nil {
            log.Error("failed to save tasks", "plan_id", plan.ID(), "error", err)
        }
    }
}
```

---

## 6. Plan & Task 与 Assessment 的关系

### 6.1 关系说明

* **入口生成**：每个 Task 对应一个测评入口（二维码/链接），入口中包含 task_id
* **提交答卷**：
  * collection-server 收到带 task_id 的提交
  * 应用层根据 task_id 查 Task，进一步查 Plan / Testee / Scale
  * 创建 Assessment 时写入：
    * `originType = plan`
    * `originID = planID`
    * `taskID` 写入 Assessment 的扩展字段或关联表
  * 更新 Task 状态为 completed，`assessmentID = Assessment.ID`

### 6.2 数据流向

```text
AssessmentTask
    │
    ▼ 用户点击入口
AnswerSheet (创建)
    │
    ▼ 提交答卷
Assessment (创建)
    originType = plan
    originID = planID
    │
    ▼ 回写
AssessmentTask
    status = completed
    assessmentID = xxx
```

### 6.3 统计维度

这样设计后，可以从多个维度统计：

1. **按 Task 维度**：计算每次计划的完成情况

   ```sql
   SELECT seq, status, completed_at
   FROM assessment_tasks
   WHERE plan_id = ?
   ORDER BY seq
   ```

2. **按 Plan 维度**：统计计划总执行率、每次完成率

   ```sql
   SELECT
       plan_id,
       SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS filled_count,
       COUNT(*) AS total_count,
       SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS completion_rate
   FROM assessment_tasks
   WHERE plan_id = ?
   GROUP BY plan_id
   ```

3. **按 Testee 维度**：查看受试者在某量表上的多次测评折线图

   ```sql
   SELECT ast.total_score, ast.risk_level, ast.interpreted_at
   FROM assessments ast
   JOIN assessment_tasks task ON ast.id = task.assessment_id
   WHERE task.testee_id = ?
     AND ast.medical_scale_id = ?
   ORDER BY ast.interpreted_at
   ```

---

## 7. 填写率统计与图表设计

### 7.1 计划维度的填写率

**定义**：填写率 = 已完成任务数 / 所有已到期任务数

**SQL 查询**：

```sql
SELECT
    plan_id,
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS filled_count,
    COUNT(CASE WHEN planned_at <= NOW() THEN 1 END) AS due_count,
    ROUND(
        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) * 100.0 / 
        COUNT(CASE WHEN planned_at <= NOW() THEN 1 END), 
        2
    ) AS completion_rate
FROM assessment_tasks
WHERE plan_id = ?
GROUP BY plan_id
```

### 7.2 时间趋势图

**按周统计完成情况**：

```sql
SELECT
    YEARWEEK(planned_at, 1) AS year_week,
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS filled_count,
    SUM(CASE WHEN status = 'expired' THEN 1 ELSE 0 END) AS expired_count,
    SUM(CASE WHEN status IN ('pending', 'opened') THEN 1 ELSE 0 END) AS pending_count
FROM assessment_tasks
WHERE org_id = ?
  AND planned_at BETWEEN ? AND ?
GROUP BY YEARWEEK(planned_at, 1)
ORDER BY year_week
```

### 7.3 计划完成率可视化示例

**场景**：某患者的术后随访计划

| 测评次序 | 计划日期 | 状态 | 完成日期 | 总分 | 风险等级 |
|---------|---------|------|---------|------|---------|
| 第 1 次 | 2025-01-15 | 已完成 | 2025-01-15 | 45 | Low |
| 第 2 次 | 2025-01-29 | 已完成 | 2025-01-30 | 42 | Low |
| 第 3 次 | 2025-02-26 | 已完成 | 2025-02-27 | 38 | None |
| 第 4 次 | 2025-03-26 | 待完成 | - | - | - |

**趋势折线图**：

* X 轴：测评次序（1-4）
* Y 轴：总分（0-80）
* 折线展示分数随时间下降趋势，说明康复效果良好

---

## 8. 周期策略的详细设计

### 8.1 等间隔周期（IntervalWeeks / IntervalDays）

**场景**：每 N 周/天测评一次

**Task 生成示例**：

* 开始日期：2025-01-01
* 每 4 周一次，共 5 次
* 生成 Task：
  * Task 1: 2025-01-01
  * Task 2: 2025-01-29
  * Task 3: 2025-02-26
  * Task 4: 2025-03-26
  * Task 5: 2025-04-23

### 8.2 定点触发周期（CustomWeeks）

**场景**：相对基准日期的第 2、4、8、12 周

**示例（术后随访）**：

* 开始日期：2025-01-01（出院日期）
* 定点周次：[2, 4, 8, 12]
* 生成 Task：
  * Task 1: 2025-01-15（第 2 周）
  * Task 2: 2025-01-29（第 4 周）
  * Task 3: 2025-02-26（第 8 周）
  * Task 4: 2025-03-26（第 12 周）

### 8.3 固定日期列表（FixedDate）

**场景**：指定具体日期

**示例（节假日测评）**：

* 固定日期：[2025-01-01, 2025-05-01, 2025-10-01]
* 生成 Task：
  * Task 1: 2025-01-01
  * Task 2: 2025-05-01
  * Task 3: 2025-10-01

---

## 9. 仓储接口

```go
// AssessmentPlanRepository 测评计划仓储
type AssessmentPlanRepository interface {
    // FindByID 根据 ID 查询计划
    FindByID(ctx context.Context, id AssessmentPlanID) (*AssessmentPlan, error)

    // FindByTesteeID 查询某个受试者的所有计划
    FindByTesteeID(ctx context.Context, testeeID user.TesteeID) ([]*AssessmentPlan, error)

    // FindActiveComments 查询所有活跃的计划
    FindActiveComments(ctx context.Context) ([]*AssessmentPlan, error)

    // Save 保存计划
    Save(ctx context.Context, plan *AssessmentPlan) error
}

// AssessmentTaskRepository 测评任务仓储
type AssessmentTaskRepository interface {
    // FindByID 根据 ID 查询任务
    FindByID(ctx context.Context, id AssessmentTaskID) (*AssessmentTask, error)

    // FindByPlanID 查询某个计划的所有任务
    FindByPlanID(ctx context.Context, planID AssessmentPlanID) ([]*AssessmentTask, error)

    // FindPendingTasks 查询待推送的任务
    FindPendingTasks(ctx context.Context, before time.Time) ([]*AssessmentTask, error)

    // FindExpiredTasks 查询已过期的任务
    FindExpiredTasks(ctx context.Context) ([]*AssessmentTask, error)

    // Save 保存任务
    Save(ctx context.Context, task *AssessmentTask) error

    // SaveBatch 批量保存任务
    SaveBatch(ctx context.Context, tasks []*AssessmentTask) error
}
```

---

## 10. 领域事件

```go
// PlanCreatedEvent 计划创建事件
type PlanCreatedEvent struct {
    PlanID    AssessmentPlanID
    TesteeID  user.TesteeID
    ScaleID   scale.MedicalScaleID
    CreatedAt time.Time
}

// TaskOpenedEvent 任务开放事件
type TaskOpenedEvent struct {
    TaskID   AssessmentTaskID
    PlanID   AssessmentPlanID
    TesteeID user.TesteeID
    EntryURL string
    OpenAt   time.Time
}

// TaskCompletedEvent 任务完成事件
type TaskCompletedEvent struct {
    TaskID       AssessmentTaskID
    PlanID       AssessmentPlanID
    AssessmentID assessment.AssessmentID
    CompletedAt  time.Time
}

// TaskExpiredEvent 任务过期事件
type TaskExpiredEvent struct {
    TaskID   AssessmentTaskID
    PlanID   AssessmentPlanID
    ExpiredAt time.Time
}
```

---

## 11. 总结

* **plan 子域**通过 AssessmentPlan + AssessmentTask 管理周期性测评，与 Assessment/Testee 串联，支持计划执行率与趋势分析
* **测评计划归问卷 BC 管理**（方案 A），上游 BC 通过 API 创建计划，问卷 BC 负责调度和执行
* **支持多种周期策略**：等间隔周期、定点触发、固定日期列表，满足不同业务场景需求
* **通过 Task 维度计算填写率**，可绘制时间趋势图和完成率统计图表
* **Testee 在第一次创建计划时懒创建**，通过 EnsureTestee 实现幂等创建，支持多上游 BC 安全调用
