# 测评计划子域设计（V3）

> **版本**：V3.0  
> **范围**：问卷&量表 BC 中的 plan 子域  
> **目标**：阐述测评计划子域的核心职责、周期性测评管理业务设计、与其他子域的协作关系  
> **更新日期**：2025-01-XX  
> **实现状态**：✅ 已实现

---

## 1. Plan 子域的定位与职责

### 1.1 子域边界

**plan 子域关注的核心问题**：

* **周期性测评管理**：针对单个受试者制定长期、周期性的测评计划
* **测评任务调度**：按时间规则自动生成测评任务并推送通知
* **计划执行追踪**：跟踪每次测评任务的完成情况，支持填写率统计
* **上游业务集成**：接收来自互联网医院、行为训练中心等业务 BC 的计划创建请求

**plan 子域不关心的问题**：

* "问卷怎么展示、如何填写"：这是 survey 子域的职责
* "如何计分和解读"：这是 scale 子域的职责
* "批量筛查项目"：这是 screening 子域的职责

### 1.2 核心聚合

plan 子域包含两个核心聚合：

1. **AssessmentPlan 聚合根**：测评计划模板
   * **设计理念**：Plan 是模板，不关联具体的受试者，定义"应该如何测"的策略
   * 描述周期性测评策略（测什么量表、什么时候测、测几次）
   * 管理计划状态（active / paused / finished / canceled）
   * 定义周期规则（按周、按天、固定日期、自定义周次）
   * **关键特性**：多个受试者可以加入同一个 Plan，每个受试者生成自己的 Task

2. **AssessmentTask 实体**：测评任务
   * 计划分解后的"应测实例"，代表"某个受试者的第 N 次测评"
   * 关联具体的受试者（testeeID）和计划（planID）
   * 管理任务状态（pending / opened / completed / expired / canceled）
   * 与 Assessment 关联（1:0..1 关系）

### 1.3 与其他子域的关系

* **依赖** actor 子域：引用 TesteeID（在 Task 中）
* **依赖** scale 子域：引用 ScaleID（meta.ID）
* **被引用** evaluation 子域：AssessmentTask 创建 Assessment 时记录 originType=plan

**计划归属决策（方案 A）**：

* **测评计划归问卷&量表 BC 管理**
* 上游 BC（互联网医院、行为训练中心）只负责决策"要什么计划"
* 问卷 BC 负责计划实体 + 生命周期 + 调度执行

```text
上游 BC (医院/训练中心)          问卷&量表 BC
┌─────────────────┐              ┌─────────────────────┐
│ 医生下医嘱       │              │                     │
│ 学员签约         │ ─────────>   │ CreatePlan API      │
│                 │   命令/事件   │                     │
└─────────────────┘              │ EnsureTestee        │
                                  │ Create Plan         │
                                  │ Generate Tasks      │
                                  │ Schedule & Notify   │
                                  └─────────────────────┘
```

---

## 2. 周期性测评管理业务

### 2.1 业务场景

***场景 1：互联网医院随访测评**

* 患者出院后，医生为其制定随访测评计划
* 例如：每 4 周进行一次心理量表测评，共 6 次
* 系统定时生成测评任务，推送通知给患者

***场景 2：行为训练中心周期评估***

* 学员入校/签约后，按照课时或周数生成测评计划
* 例如：在第 2、4、8、12 周分别进行行为评估
* 系统自动生成测评任务，推送给家长

***场景 3：慢病管理定期测评***

* 慢病患者定期进行健康量表测评
* 例如：每 2 周一次，持续 3 个月
* 系统自动提醒并记录完成情况

### 2.2 核心业务流程

#### 2.2.1 创建测评计划

```text
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│上游 BC   │────>│问卷 BC   │────>│Testee    │────>│Plan      │
│医生决策  │ 命令 │应用服务  │查询/创建│实体      │创建  │聚合      │
└──────────┘     └──────────┘     └──────────┘     └──────────┘
                      │
                      ▼
                 ┌──────────┐
                 │Task      │
                 │任务生成  │
                 └──────────┘
```

**步骤说明**：

1. **创建计划模板**：`POST /api/v1/plans`

   ```json
   {
     "scale_id": "789",
     "schedule_type": "by_week",
     "interval": 4,
     "total_times": 6,
     "relative_weeks": null
   }
   ```

   **关键点**：
   * Plan 是模板，不关联 testeeID
   * 不包含 startDate（startDate 是任务生成时的参数）
   * 审计字段（createdAt, updatedAt 等）由基础设施层处理

2. **受试者加入计划**：`POST /api/v1/plans/enroll`

   ```json
   {
     "plan_id": "123",
     "testee_id": "456",
     "start_date": "2025-01-01"
   }
   ```

   **流程**：
   * 验证计划状态（必须是 active）
   * 验证受试者是否已加入（幂等性检查）
   * 调用 `TaskGenerator.GenerateTasks(plan, testeeID, startDate)` 生成所有任务
   * 保存任务到数据库
   * 发布 `PlanEnrolledEvent` 事件（可选）

3. **任务生成逻辑**：
   * 根据 Plan 的周期策略和 startDate 计算每个任务的 plannedAt
   * 每个任务关联 planID、testeeID、seq（序号）
   * 初始状态为 pending

#### 2.2.2 定时调度与推送

```text
定时任务（每小时）
    │
    ▼
调用 POST /api/v1/plans/tasks/schedule
    │
    ▼
TaskSchedulerService.SchedulePendingTasks()
    │
    ▼
查询 Task (status=pending, plannedAt <= before)
    │
    ▼
EntryGenerator.GenerateEntry() 生成入口（token、URL、过期时间）
    │
    ▼
TaskLifecycle.Open() 开放任务
    │
    ▼
更新 Task (status=opened, openAt=now, entryToken, entryURL, expireAt)
    │
    ▼
发布 TaskOpenedEvent 事件
    │
    ▼
Worker 消费事件 → 发送通知给受试者
```

#### 2.2.3 用户填写与完成

```text
用户点击入口 ────> 进入答题页面 ────> 提交答卷
    │                                     │
    ▼                                     ▼
查询 Task                          创建 Assessment
验证状态                           (originType=plan)
    │                                     │
    ▼                                     ▼
展示问卷                           创建 AnswerSheet
    │                                     │
    ▼                                     ▼
实时保存                           更新 Task
(draft)                            (status=completed)
                                        │
                                        ▼
                                   发布事件
                                   (AssessmentSubmittedEvent)
```

#### 2.2.4 过期处理

```text
定时任务（每天）
    │
    ▼
扫描 Task (status=opened, expireAt <= now)
    │
    ▼
更新 Task (status=expired)
```

### 2.3 计划模板与受试者加入的分离

**关键原则**：Plan 是模板，受试者通过"加入计划"的方式生成自己的任务

**设计优势**：

* **模板复用**：一个 Plan 可以被多个受试者使用（如 SNAP 18 周测评模板）
* **灵活调度**：每个受试者可以有不同的 startDate
* **独立管理**：计划模板和受试者任务分离，便于管理

**流程**：

1. **创建计划模板**（不关联受试者）：

   ```go
   plan := domain.NewAssessmentPlan(
       orgID,
       scaleID,
       scheduleType,
       interval,
       totalTimes,
       opts..., // WithFixedDates, WithRelativeWeeks
   )
   ```

2. **受试者加入计划**（生成任务）：

   ```go
   // 调用 PlanEnrollment.EnrollTestee()
   tasks := taskGenerator.GenerateTasks(plan, testeeID, startDate)
   // 每个任务关联 planID、testeeID、seq
   ```

---

## 3. AssessmentPlan 聚合根

### 3.1 聚合根定位

AssessmentPlan 是 plan 子域的核心聚合根，代表"周期性测评策略模板"。

**核心职责**：

1. 描述"应该如何测"的策略（测什么、什么时候测、测几次）
2. 管理计划生命周期（启用、暂停、结束、取消）
3. 不关心具体受试者（Plan 是模板，多个受试者可以加入）
4. 不关心每一次是否完成（由 Task 负责）

**设计理念**：

* Plan 是模板，不关联 testeeID
* 多个受试者可以加入同一个 Plan
* 每个受试者加入时，根据 Plan 的策略和自己的 startDate 生成 Task

### 3.2 聚合根结构

```go
// AssessmentPlanID 计划ID（使用 meta.ID）
type AssessmentPlanID = meta.ID

// PlanStatus 计划状态
type PlanStatus string

const (
    PlanStatusActive   PlanStatus = "active"   // 活跃
    PlanStatusPaused   PlanStatus = "paused"   // 暂停
    PlanStatusFinished PlanStatus = "finished" // 已完成
    PlanStatusCanceled PlanStatus = "canceled" // 已取消
)

// PlanScheduleType 计划周期类型
type PlanScheduleType string

const (
    PlanScheduleByWeek    PlanScheduleType = "by_week"    // 每 N 周一次
    PlanScheduleByDay     PlanScheduleType = "by_day"     // 每 N 天一次
    PlanScheduleFixedDate PlanScheduleType = "fixed_date" // 指定日期列表
    PlanScheduleCustom    PlanScheduleType = "custom"     // 自定义周次（如 2,4,8,12）
)

type AssessmentPlan struct {
    // === 核心标识 ===
    id    AssessmentPlanID
    orgID int64

    // === 关联实体引用 ===
    scaleID meta.ID  // 量表ID（不关联 testeeID，Plan 是模板）

    // === 周期策略 ===
    // 所有周期策略都是相对时间窗口，不是绝对日期
    // 任务生成时：plannedAt = startDate（参数）+ 相对时间偏移
    scheduleType  PlanScheduleType
    interval      int         // 间隔 N 周/天（用于 by_week / by_day）
    totalTimes    int         // 计划总次数
    fixedDates    []time.Time // 固定日期列表（用于 fixed_date，特殊场景使用绝对日期）
    relativeWeeks []int       // 相对周次列表（用于 custom，如 [2,4,8,12,18]）

    // === 状态 ===
    status PlanStatus

    // === 领域事件 ===
    events []event.DomainEvent
}
```

**关键设计点**：

* ❌ **不包含** `testeeID`：Plan 是模板，多个受试者可以加入
* ❌ **不包含** `startDate`/`endDate`：时间范围是任务生成时的参数，不是 Plan 的属性
* ❌ **不包含** 审计字段：`createdAt`, `updatedAt`, `version` 等由基础设施层处理
* ✅ **包含** `orgID`：用于权限控制和查询优化
* ✅ **包含** `scaleID`：关联量表
* ✅ **包含** 周期策略字段：定义"如何生成任务"

### 3.3 构造函数与核心方法

```go
// NewAssessmentPlan 创建测评计划模板
// 注意：
// - startDate 不在计划中，而是任务生成时的参数
// - testeeID 不在计划中，计划是模板，多个受试者可以加入
// - 审计字段（createdAt, updatedAt, version 等）由基础设施层处理
func NewAssessmentPlan(
    orgID int64,
    scaleID meta.ID,
    scheduleType PlanScheduleType,
    interval int,
    totalTimes int,
    opts ...PlanOption, // WithFixedDates, WithRelativeWeeks
) (*AssessmentPlan, error) {
    // 验证和创建逻辑...
    plan := &AssessmentPlan{
        id:           NewAssessmentPlanID(),
        orgID:        orgID,
        scaleID:      scaleID,
        scheduleType: scheduleType,
        interval:     interval,
        totalTimes:   totalTimes,
        status:       PlanStatusActive,
        events:       make([]event.DomainEvent, 0),
    }
    // 应用选项...
    // 发布 PlanCreatedEvent
    return plan, nil
}

// 状态变更方法（包内方法，由领域服务调用）
func (p *AssessmentPlan) pause() error { ... }
func (p *AssessmentPlan) resume() error { ... }
func (p *AssessmentPlan) finish() { ... }
func (p *AssessmentPlan) cancel() { ... }
```

**状态管理**：

* 状态变更方法（`pause`, `resume`, `finish`, `cancel`）是包内方法
* 由领域服务 `PlanLifecycle` 调用，封装业务规则
* 应用层通过 `PlanLifecycleService` 调用领域服务

---

## 4. AssessmentTask 实体

### 4.1 实体定位

AssessmentTask 是计划分解后的"应测实例"，代表"第 N 次测评"。

**核心职责**：

1. 记录计划的第 N 次测评应该在什么时候进行
2. 管理任务状态（待推送、已推送、已完成、已过期）
3. 与 Assessment 关联（1:0..1 关系）

### 4.2 实体结构

```go
type AssessmentTaskID string

// 任务状态
type TaskStatus string

const (
    TaskStatusPending   TaskStatus = "pending"   // 待推送
    TaskStatusOpened    TaskStatus = "opened"    // 已推送（生成了入口）
    TaskStatusCompleted TaskStatus = "completed" // 已完成
    TaskStatusExpired   TaskStatus = "expired"   // 已过期
    TaskStatusCanceled  TaskStatus = "canceled"  // 已取消
)

type AssessmentTask struct {
    // === 核心标识 ===
    id     AssessmentTaskID
    planID AssessmentPlanID
    seq    int // 第 N 次测评

    // === 关联实体引用 ===
    orgID    int64      // 机构ID（冗余，用于查询优化和权限控制）
    testeeID testee.ID  // 受试者ID
    scaleID  meta.ID    // 量表ID（冗余，用于查询优化）

    // === 时间点 ===
    plannedAt   time.Time  // 计划时间点
    openAt      *time.Time // 实际开放时间
    expireAt    *time.Time // 截止时间
    completedAt *time.Time // 完成时间

    // === 状态与关联 ===
    status       TaskStatus
    assessmentID *assessment.ID

    // === 入口信息 ===
    entryToken string // 入口令牌（用于生成二维码/链接）
    entryURL   string // 入口 URL

    // === 领域事件 ===
    events []event.DomainEvent
}
```

**关键设计点**：

* ✅ **包含** `testeeID`：任务关联具体的受试者
* ✅ **包含** `orgID` 和 `scaleID`（冗余）：用于查询优化，避免 JOIN Plan 表
* ❌ **不包含** 审计字段：`createdAt`, `updatedAt`, `version` 等由基础设施层处理
* ✅ **包含** `planID` 和 `seq`：标识任务属于哪个计划的第几次测评

### 4.3 核心方法

```go
// 状态变更方法（包内方法，由领域服务调用）
func (t *AssessmentTask) open(entryToken string, entryURL string, expireAt time.Time) error {
    // 状态检查、状态变更、发布事件
    t.addEvent(NewTaskOpenedEvent(...))
}

func (t *AssessmentTask) complete(assessmentID assessment.ID) error {
    // 状态检查、状态变更、发布事件
    t.addEvent(NewTaskCompletedEvent(...))
}

func (t *AssessmentTask) expire() error {
    // 状态检查、状态变更、发布事件
    t.addEvent(NewTaskExpiredEvent(...))
}

func (t *AssessmentTask) cancel() {
    // 状态变更
}
```

**状态管理**：

* 状态变更方法是包内方法，由领域服务 `TaskLifecycle` 调用
* 每个状态变更都会发布相应的领域事件
* 应用层通过 `TaskManagementService` 调用领域服务

---

## 5. Plan 与 Task 的生成策略

### 5.1 一次性生成全部 Task（当前实现）

**适用场景**：测评次数不多（≤ 50 次）

**生成时机**：受试者加入计划时立即生成所有 Task

**优点**：

* 逻辑简单，易于实现
* 查询方便，可直接展示所有任务
* 前端可一次性展示完整计划
* 支持计划暂停/恢复时的任务重新生成

**实现**：

```go
// TaskGenerator.GenerateTasks() 根据 Plan 和 startDate 生成任务
func (g *TaskGenerator) GenerateTasks(
    plan *AssessmentPlan,
    testeeID testee.ID,
    startDate time.Time,
) []*AssessmentTask {
    var tasks []*AssessmentTask

    switch plan.GetScheduleType() {
    case PlanScheduleByWeek:
        // 每 N 周一次
        for i := 0; i < plan.GetTotalTimes(); i++ {
            plannedAt := startDate.AddDate(0, 0, i*plan.GetInterval()*7)
            task := NewAssessmentTask(plan.GetID(), i+1, orgID, testeeID, plan.GetScaleID(), plannedAt)
            tasks = append(tasks, task)
        }

    case PlanScheduleByDay:
        // 每 N 天一次
        for i := 0; i < plan.GetTotalTimes(); i++ {
            plannedAt := startDate.AddDate(0, 0, i*plan.GetInterval())
            task := NewAssessmentTask(plan.GetID(), i+1, orgID, testeeID, plan.GetScaleID(), plannedAt)
            tasks = append(tasks, task)
        }

    case PlanScheduleCustom:
        // 自定义周次（如 [2,4,8,12]）
        relativeWeeks := plan.GetRelativeWeeks()
        for i, week := range relativeWeeks {
            plannedAt := startDate.AddDate(0, 0, week*7)
            task := NewAssessmentTask(plan.GetID(), i+1, orgID, testeeID, plan.GetScaleID(), plannedAt)
            tasks = append(tasks, task)
        }

    case PlanScheduleFixedDate:
        // 固定日期列表
        fixedDates := plan.GetFixedDates()
        for i, date := range fixedDates {
            task := NewAssessmentTask(plan.GetID(), i+1, orgID, testeeID, plan.GetScaleID(), date)
            tasks = append(tasks, task)
        }
    }

    return tasks
}
```

**关键点**：

* `startDate` 是参数，不是 Plan 的属性
* 每个受试者可以有不同的 `startDate`
* 任务生成时关联 `testeeID` 和 `planID`

### 5.2 计划暂停/恢复时的任务管理

**业务规则**：

* **暂停计划**：取消所有未执行的任务（pending 和 opened 状态）
* **恢复计划**：为每个受试者重新生成未完成的任务（序号大于已完成的最大序号）

**实现**：

```go
// PlanLifecycle.Pause() - 暂停计划
func (l *PlanLifecycle) Pause(ctx context.Context, plan *AssessmentPlan) ([]*AssessmentTask, error) {
    // 1. 查询该计划的所有任务
    allTasks, err := l.taskRepo.FindByPlanID(ctx, plan.GetID())
    
    // 2. 取消所有未执行的任务（pending 和 opened 状态）
    var canceledTasks []*AssessmentTask
    for _, task := range allTasks {
        if task.IsPending() || task.IsOpened() {
            l.taskLifecycle.Cancel(ctx, task)
            canceledTasks = append(canceledTasks, task)
        }
    }
    
    // 3. 更新计划状态
    plan.pause()
    
    return canceledTasks, nil
}

// PlanLifecycle.Resume() - 恢复计划
func (l *PlanLifecycle) Resume(
    ctx context.Context,
    plan *AssessmentPlan,
    testeeStartDates map[testee.ID]time.Time,
) ([]*AssessmentTask, error) {
    // 1. 查询该计划的所有任务
    allTasks, err := l.taskRepo.FindByPlanID(ctx, plan.GetID())
    
    // 2. 按受试者分组，找出每个受试者已完成的最大序号
    testeeMaxSeq := make(map[testee.ID]int)
    for _, task := range allTasks {
        if task.IsCompleted() {
            if seq := task.GetSeq(); seq > testeeMaxSeq[task.GetTesteeID()] {
                testeeMaxSeq[task.GetTesteeID()] = seq
            }
        }
    }
    
    // 3. 为每个受试者重新生成未完成的任务
    var newTasks []*AssessmentTask
    for testeeID, startDate := range testeeStartDates {
        // 生成所有任务
        allGeneratedTasks := l.taskGenerator.GenerateTasks(plan, testeeID, startDate)
        
        // 找出需要重新生成的任务（序号大于已完成的最大序号）
        maxCompletedSeq := testeeMaxSeq[testeeID]
        for _, task := range allGeneratedTasks {
            if task.GetSeq() > maxCompletedSeq {
                newTasks = append(newTasks, task)
            }
        }
    }
    
    // 4. 更新计划状态
    plan.resume()
    
    return newTasks, nil
}
```

---

## 6. Plan & Task 与 Assessment 的关系

### 6.1 关系说明

* **入口生成**：每个 Task 对应一个测评入口（二维码/链接），入口中包含 task_id
* **提交答卷**：
  * collection-server 收到带 task_id 的提交
  * 应用层根据 task_id 查 Task，进一步查 Plan / Testee / Scale
  * 创建 Assessment 时写入：
    * `originType = plan`
    * `originID = planID`
    * `taskID` 写入 Assessment 的扩展字段或关联表
  * 更新 Task 状态为 completed，`assessmentID = Assessment.ID`

### 6.2 数据流向

```text
AssessmentTask
    │
    ▼ 用户点击入口
AnswerSheet (创建)
    │
    ▼ 提交答卷
Assessment (创建)
    originType = plan
    originID = planID
    │
    ▼ 回写
AssessmentTask
    status = completed
    assessmentID = xxx
```

### 6.3 统计维度

这样设计后，可以从多个维度统计：

1. **按 Task 维度**：计算每次计划的完成情况

   ```sql
   SELECT seq, status, completed_at
   FROM assessment_tasks
   WHERE plan_id = ?
   ORDER BY seq
   ```

2. **按 Plan 维度**：统计计划总执行率、每次完成率

   ```sql
   SELECT
       plan_id,
       SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS filled_count,
       COUNT(*) AS total_count,
       SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS completion_rate
   FROM assessment_tasks
   WHERE plan_id = ?
   GROUP BY plan_id
   ```

3. **按 Testee 维度**：查看受试者在某量表上的多次测评折线图

   ```sql
   SELECT ast.total_score, ast.risk_level, ast.interpreted_at
   FROM assessments ast
   JOIN assessment_tasks task ON ast.id = task.assessment_id
   WHERE task.testee_id = ?
     AND ast.medical_scale_id = ?
   ORDER BY ast.interpreted_at
   ```

---

## 7. 填写率统计与图表设计

### 7.1 计划维度的填写率

**定义**：填写率 = 已完成任务数 / 所有已到期任务数

**SQL 查询**：

```sql
SELECT
    plan_id,
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS filled_count,
    COUNT(CASE WHEN planned_at <= NOW() THEN 1 END) AS due_count,
    ROUND(
        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) * 100.0 / 
        COUNT(CASE WHEN planned_at <= NOW() THEN 1 END), 
        2
    ) AS completion_rate
FROM assessment_tasks
WHERE plan_id = ?
GROUP BY plan_id
```

### 7.2 时间趋势图

**按周统计完成情况**：

```sql
SELECT
    YEARWEEK(planned_at, 1) AS year_week,
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS filled_count,
    SUM(CASE WHEN status = 'expired' THEN 1 ELSE 0 END) AS expired_count,
    SUM(CASE WHEN status IN ('pending', 'opened') THEN 1 ELSE 0 END) AS pending_count
FROM assessment_tasks
WHERE org_id = ?
  AND planned_at BETWEEN ? AND ?
GROUP BY YEARWEEK(planned_at, 1)
ORDER BY year_week
```

### 7.3 计划完成率可视化示例

**场景**：某患者的术后随访计划

| 测评次序 | 计划日期 | 状态 | 完成日期 | 总分 | 风险等级 |
|---------|---------|------|---------|------|---------|
| 第 1 次 | 2025-01-15 | 已完成 | 2025-01-15 | 45 | Low |
| 第 2 次 | 2025-01-29 | 已完成 | 2025-01-30 | 42 | Low |
| 第 3 次 | 2025-02-26 | 已完成 | 2025-02-27 | 38 | None |
| 第 4 次 | 2025-03-26 | 待完成 | - | - | - |

**趋势折线图**：

* X 轴：测评次序（1-4）
* Y 轴：总分（0-80）
* 折线展示分数随时间下降趋势，说明康复效果良好

---

## 8. 周期策略的详细设计

### 8.1 等间隔周期（IntervalWeeks / IntervalDays）

**场景**：每 N 周/天测评一次

**Task 生成示例**：

* 开始日期：2025-01-01
* 每 4 周一次，共 5 次
* 生成 Task：
  * Task 1: 2025-01-01
  * Task 2: 2025-01-29
  * Task 3: 2025-02-26
  * Task 4: 2025-03-26
  * Task 5: 2025-04-23

### 8.2 定点触发周期（CustomWeeks）

**场景**：相对基准日期的第 2、4、8、12 周

**示例（术后随访）**：

* 开始日期：2025-01-01（出院日期）
* 定点周次：[2, 4, 8, 12]
* 生成 Task：
  * Task 1: 2025-01-15（第 2 周）
  * Task 2: 2025-01-29（第 4 周）
  * Task 3: 2025-02-26（第 8 周）
  * Task 4: 2025-03-26（第 12 周）

### 8.3 固定日期列表（FixedDate）

**场景**：指定具体日期

**示例（节假日测评）**：

* 固定日期：[2025-01-01, 2025-05-01, 2025-10-01]
* 生成 Task：
  * Task 1: 2025-01-01
  * Task 2: 2025-05-01
  * Task 3: 2025-10-01

---

## 9. 领域服务

### 9.1 PlanLifecycle（计划生命周期管理）

**职责**：控制测评计划的生命周期（激活、暂停、恢复、取消）

**业务规则**：

* 暂停计划时，取消所有未执行的任务（pending 和 opened 状态）
* 恢复计划时，为每个受试者重新生成未完成的任务

**方法**：

* `Activate()` - 开启计划
* `Pause()` - 暂停计划
* `Resume()` - 恢复计划
* `Cancel()` - 取消计划

### 9.2 PlanEnrollment（受试者加入计划）

**职责**：管理受试者加入计划、终止计划

**方法**：

* `EnrollTestee()` - 将受试者加入计划，生成所有任务
* `TerminateEnrollment()` - 终止受试者的计划参与，取消所有待处理任务

### 9.3 TaskGenerator（任务生成器）

**职责**：根据计划的周期策略生成测评任务

**方法**：

* `GenerateTasks()` - 根据 Plan 和 startDate 生成所有任务
* `GenerateTasksUntil()` - 生成直到指定日期的任务（用于定时生成场景）

### 9.4 TaskLifecycle（任务生命周期管理）

**职责**：控制单次测评任务的生命周期（开放、完成、过期、取消）

**方法**：

* `Open()` - 开放任务（生成入口）
* `Complete()` - 完成任务
* `Expire()` - 过期任务
* `Cancel()` - 取消任务

### 9.5 PlanValidator（计划验证器）

**职责**：领域级别的验证

**方法**：

* `ValidateForEnrollment()` - 验证计划是否可以加入受试者
* `ValidateScheduleStrategy()` - 验证周期策略的合法性

## 10. 应用服务

### 10.1 PlanLifecycleService

**行为者**：计划管理员

**方法**：

* `CreatePlan()` - 创建测评计划模板
* `PausePlan()` - 暂停计划
* `ResumePlan()` - 恢复计划
* `CancelPlan()` - 取消计划

### 10.2 PlanEnrollmentService

**行为者**：受试者管理服务

**方法**：

* `EnrollTestee()` - 将受试者加入计划
* `TerminateEnrollment()` - 终止受试者的计划参与

### 10.3 TaskSchedulerService

**行为者**：任务调度服务

**方法**：

* `SchedulePendingTasks()` - 调度待推送的任务（定时任务调用）

### 10.4 TaskManagementService

**行为者**：任务管理服务

**方法**：

* `OpenTask()` - 手动开放任务
* `CompleteTask()` - 完成任务
* `ExpireTask()` - 过期任务
* `CancelTask()` - 取消任务

### 10.5 PlanQueryService

**行为者**：所有用户

**方法**：

* `GetPlan()` - 获取计划详情
* `ListPlans()` - 查询计划列表
* `GetTask()` - 获取任务详情
* `ListTasks()` - 查询任务列表
* `ListTasksByPlan()` - 查询计划下的所有任务
* `ListTasksByTestee()` - 查询受试者的所有任务
* `ListPlansByTestee()` - 查询受试者参与的所有计划
* `ListTasksByTesteeAndPlan()` - 查询受试者在某个计划下的所有任务

## 11. 仓储接口

```go
// AssessmentPlanRepository 测评计划仓储
type AssessmentPlanRepository interface {
    // FindByID 根据 ID 查询计划
    FindByID(ctx context.Context, id AssessmentPlanID) (*AssessmentPlan, error)

    // FindByScaleID 查询某个量表的所有计划
    FindByScaleID(ctx context.Context, scaleID meta.ID) ([]*AssessmentPlan, error)

    // FindActivePlans 查询所有活跃的计划
    FindActivePlans(ctx context.Context) ([]*AssessmentPlan, error)

    // FindByTesteeID 查询某个受试者参与的所有计划
    // 实现方式：通过 Task 反查 Plan，返回去重后的 Plan 列表
    FindByTesteeID(ctx context.Context, testeeID testee.ID) ([]*AssessmentPlan, error)

    // Save 保存计划
    Save(ctx context.Context, plan *AssessmentPlan) error
}

// AssessmentTaskRepository 测评任务仓储
type AssessmentTaskRepository interface {
    // FindByID 根据 ID 查询任务
    FindByID(ctx context.Context, id AssessmentTaskID) (*AssessmentTask, error)

    // FindByPlanID 查询某个计划的所有任务
    FindByPlanID(ctx context.Context, planID AssessmentPlanID) ([]*AssessmentTask, error)

    // FindByTesteeID 查询某个受试者的所有任务
    FindByTesteeID(ctx context.Context, testeeID testee.ID) ([]*AssessmentTask, error)

    // FindByTesteeIDAndPlanID 查询某个受试者在某个计划下的所有任务
    FindByTesteeIDAndPlanID(ctx context.Context, testeeID testee.ID, planID AssessmentPlanID) ([]*AssessmentTask, error)

    // FindPendingTasks 查询待推送的任务（计划时间 <= before）
    FindPendingTasks(ctx context.Context, before time.Time) ([]*AssessmentTask, error)

    // FindExpiredTasks 查询已过期的任务（状态为 opened，截止时间 <= now）
    FindExpiredTasks(ctx context.Context) ([]*AssessmentTask, error)

    // Save 保存任务
    Save(ctx context.Context, task *AssessmentTask) error

    // SaveBatch 批量保存任务
    SaveBatch(ctx context.Context, tasks []*AssessmentTask) error
}
```

---

## 12. 领域事件

```go
// PlanCreatedEvent 计划创建事件
type PlanCreatedEvent struct {
    PlanID    AssessmentPlanID
    ScaleID   meta.ID
    CreatedAt time.Time
}

// TaskOpenedEvent 任务开放事件
type TaskOpenedEvent struct {
    TaskID   AssessmentTaskID
    PlanID   AssessmentPlanID
    TesteeID testee.ID
    EntryURL string
    OpenAt   time.Time
}

// TaskCompletedEvent 任务完成事件
type TaskCompletedEvent struct {
    TaskID       AssessmentTaskID
    PlanID       AssessmentPlanID
    AssessmentID assessment.ID
    CompletedAt  time.Time
}

// TaskExpiredEvent 任务过期事件
type TaskExpiredEvent struct {
    TaskID    AssessmentTaskID
    PlanID    AssessmentPlanID
    ExpiredAt time.Time
}
```

**事件发布时机**：

* `PlanCreatedEvent`：创建计划模板时发布
* `TaskOpenedEvent`：任务被开放（生成入口）时发布
* `TaskCompletedEvent`：任务完成时发布
* `TaskExpiredEvent`：任务过期时发布

**事件处理**：由 `qs-worker` 服务异步处理，详见 [02-领域事件说明.md](./02-领域事件说明.md)

---

## 13. REST API 接口

### 13.1 Plan 生命周期管理

* `POST /api/v1/plans` - 创建计划模板
* `POST /api/v1/plans/:id/pause` - 暂停计划
* `POST /api/v1/plans/:id/resume` - 恢复计划
* `POST /api/v1/plans/:id/cancel` - 取消计划

### 13.2 Plan 受试者管理

* `POST /api/v1/plans/enroll` - 受试者加入计划
* `POST /api/v1/plans/:plan_id/testees/:testee_id/terminate` - 终止受试者的计划参与

### 13.3 Task 调度与管理

* `POST /api/v1/plans/tasks/schedule` - 调度待推送任务（定时任务调用）
* `POST /api/v1/plans/tasks/:id/open` - 手动开放任务
* `POST /api/v1/plans/tasks/:id/complete` - 完成任务
* `POST /api/v1/plans/tasks/:id/expire` - 过期任务
* `POST /api/v1/plans/tasks/:id/cancel` - 取消任务

### 13.4 查询接口

* `GET /api/v1/plans` - 查询计划列表
* `GET /api/v1/plans/:id` - 获取计划详情
* `GET /api/v1/plans/:plan_id/tasks` - 查询计划下的所有任务
* `GET /api/v1/plans/tasks` - 查询任务列表
* `GET /api/v1/plans/tasks/:id` - 获取任务详情
* `GET /api/v1/testees/:testee_id/plans` - 查询受试者参与的所有计划
* `GET /api/v1/testees/:testee_id/tasks` - 查询受试者的所有任务
* `GET /api/v1/testees/:testee_id/plans/:plan_id/tasks` - 查询受试者在某个计划下的所有任务

## 14. 数据库迁移

迁移文件：`internal/pkg/migration/migrations/mysql/000003_init_plan_schema.up.sql`

**表结构**：

* `assessment_plan` - 测评计划表
* `assessment_task` - 测评任务表

**索引设计**：

* 单列索引：`org_id`, `scale_id`, `status`, `testee_id`, `planned_at` 等
* 复合索引：`idx_plan_seq`, `idx_plan_testee_seq`
* 唯一索引：`uk_assessment_id`（确保一个测评只关联一个任务）

## 15. 总结

* **plan 子域**通过 AssessmentPlan（模板）+ AssessmentTask（实例）管理周期性测评
* **Plan 是模板**：不关联 testeeID，多个受试者可以加入同一个 Plan
* **Task 是实例**：关联具体的受试者和计划，记录"某个受试者的第 N 次测评"
* **支持多种周期策略**：等间隔周期（by_week/by_day）、定点触发（custom）、固定日期列表（fixed_date）
* **计划生命周期管理**：支持暂停（取消未执行任务）、恢复（重新生成未完成任务）
* **任务调度**：通过外部定时任务调用 REST API，扫描待推送任务并开放
* **事件驱动**：任务状态变更发布领域事件，由 worker 异步处理（通知、统计等）
* **查询优化**：Task 中冗余 `orgID` 和 `scaleID`，避免 JOIN Plan 表
* **审计字段**：由基础设施层处理，领域对象不包含审计字段
