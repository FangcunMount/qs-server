# Plan 子域任务调度机制说明

> **版本**：V1.0  
> **更新日期**：2025-01-XX  
> **实现状态**：✅ 已实现

## 调度架构

`TaskSchedulerService` 是一个应用服务，需要通过外部调度系统来调用。当前实现采用方式一（推荐）。

### 方式一：定时任务（Cron Job）调用 HTTP/GRPC 接口（推荐）

**架构**：

```text
定时任务（Cron/Systemd Timer）
    │
    ▼
HTTP/GRPC 接口
    │
    ▼
TaskSchedulerService.SchedulePendingTasks()
    │
    ▼
扫描待推送任务 → 生成入口 → 开放任务 → 发布事件
```

**实现步骤**：

1. **REST API 接口**（已实现）：

```go
// internal/apiserver/interface/restful/handler/plan_handler.go
// POST /api/v1/plans/tasks/schedule
func (h *PlanHandler) SchedulePendingTasks(c *gin.Context) {
    before := c.Query("before") // 可选，默认当前时间
    
    tasks, err := h.taskSchedulerService.SchedulePendingTasks(c.Request.Context(), before)
    if err != nil {
        h.Error(c, err)
        return
    }
    
    h.Success(c, response.NewTaskListResponseFromSlice(tasks))
}
```

**实现位置**：

- 接口定义：`internal/apiserver/application/plan/interface.go` (TaskSchedulerService)
- 服务实现：`internal/apiserver/application/plan/task_scheduler_service.go`
- REST Handler：`internal/apiserver/interface/restful/handler/plan.go` (SchedulePendingTasks)
- 路由注册：`internal/apiserver/routers.go` (registerPlanProtectedRoutes)

2. **（可选）配置定时任务**：

**使用 Systemd Timer（Linux）**：

```ini
# /etc/systemd/system/plan-task-scheduler.timer
[Unit]
Description=Plan Task Scheduler Timer
After=network.target

[Timer]
OnCalendar=hourly  # 每小时执行一次
# 或者：OnCalendar=*-*-* *:00:00  # 每小时的整点执行
Persistent=true

[Install]
WantedBy=timers.target
```

```ini
# /etc/systemd/system/plan-task-scheduler.service
[Unit]
Description=Plan Task Scheduler Service
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/bin/curl -X POST http://localhost:8080/api/v1/plan/tasks/schedule?before=$(date +%%Y-%%m-%%d\ %%H:%%M:%%S)
```

**使用 Cron（传统方式）**：

```bash
# 每小时执行一次
0 * * * * curl -X POST http://localhost:8080/api/v1/plan/tasks/schedule
```

**使用 Kubernetes CronJob**：

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: plan-task-scheduler
spec:
  schedule: "0 * * * *"  # 每小时执行一次
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: scheduler
            image: curl:latest
            command:
            - /bin/sh
            - -c
            - curl -X POST http://apiserver:8080/api/v1/plan/tasks/schedule
          restartPolicy: OnFailure
```

### 方式二：独立 Worker 服务（进阶）

创建一个独立的调度 Worker，直接调用应用服务：

```go
// internal/scheduler/app.go
package scheduler

import (
    "context"
    "time"
    
    "github.com/robfig/cron/v3"
    "github.com/FangcunMount/qs-server/internal/apiserver/application/plan"
)

type SchedulerApp struct {
    taskSchedulerService plan.TaskSchedulerService
    cron                 *cron.Cron
}

func NewSchedulerApp(taskSchedulerService plan.TaskSchedulerService) *SchedulerApp {
    return &SchedulerApp{
        taskSchedulerService: taskSchedulerService,
        cron:                 cron.New(),
    }
}

func (app *SchedulerApp) Start() error {
    // 每小时执行一次
    _, err := app.cron.AddFunc("0 * * * *", func() {
        ctx := context.Background()
        before := time.Now().Format("2006-01-02 15:04:05")
        
        tasks, err := app.taskSchedulerService.SchedulePendingTasks(ctx, before)
        if err != nil {
            // 记录错误
            return
        }
        
        // 记录日志
        log.Infof("Scheduled %d pending tasks", len(tasks))
    })
    
    if err != nil {
        return err
    }
    
    app.cron.Start()
    return nil
}
```

## 调度频率建议

- **待推送任务扫描**：每小时执行一次（`SchedulePendingTasks`）
- **过期任务扫描**：每天执行一次（`ExpireTask`）

## 调度流程

### 1. 待推送任务调度（SchedulePendingTasks）

```text
定时任务触发（每小时）
    │
    ▼
POST /api/v1/plans/tasks/schedule
    │
    ▼
TaskSchedulerService.SchedulePendingTasks()
    │
    ▼
taskRepo.FindPendingTasks(before) 查询待推送任务
    │
    ▼
EntryGenerator.GenerateEntry() 生成入口（token、URL、过期时间）
    │
    ▼
TaskLifecycle.Open() 开放任务
    │
    ▼
taskRepo.Save() 持久化任务状态
    │
    ▼
发布 TaskOpenedEvent 事件
    │
    ▼
Worker 消费事件 → 发送通知给受试者（TODO）
```

**实现细节**：

- 入口生成器：`internal/apiserver/infra/plan/entry_generator.go`
- 任务生命周期：`internal/apiserver/domain/plan/task_lifecycle.go`
- 错误处理：单个任务处理失败不影响其他任务

### 2. 过期任务调度（ExpireTask）

```text
定时任务触发（每天）
    │
    ▼
查询 status=opened 且 expireAt <= now 的任务
    │
    ▼
POST /api/v1/plans/tasks/:id/expire（批量调用）
    │
    ▼
TaskManagementService.ExpireTask()
    │
    ▼
TaskLifecycle.Expire() 过期任务
    │
    ▼
taskRepo.Save() 持久化任务状态
    │
    ▼
发布 TaskExpiredEvent 事件
    │
    ▼
Worker 消费事件 → 发送通知、更新统计（TODO）
```

**实现位置**：

- 服务接口：`internal/apiserver/application/plan/interface.go` (TaskManagementService)
- 服务实现：`internal/apiserver/application/plan/task_management_service.go`
- REST Handler：`internal/apiserver/interface/restful/handler/plan.go` (ExpireTask)

**注意**：当前实现支持单个任务过期，批量过期需要定时任务循环调用。

## 实现细节

### EntryGenerator（入口生成器）

**接口定义**：
```go
type EntryGenerator interface {
    GenerateEntry(ctx context.Context, task *AssessmentTask) (token string, url string, expireAt time.Time, err error)
}
```

**实现**：`internal/apiserver/infra/plan/entry_generator.go`

**功能**：

- 生成唯一令牌（UUID）
- 生成入口URL（格式：`{baseURL}?token={token}&task_id={task_id}`）
- 计算过期时间（默认从开放时间起 7 天）

### 错误处理策略

1. **幂等性**：调度任务应该是幂等的，重复执行不应该产生副作用
2. **错误隔离**：单个任务处理失败不影响其他任务（在 `SchedulePendingTasks` 中实现）
3. **监控告警**：调度任务执行失败应该发送告警（TODO）
4. **性能考虑**：如果任务数量很大，考虑分批处理（当前实现一次性处理所有任务）

## 注意事项

1. **外部调度依赖**：`TaskSchedulerService` 需要通过外部定时任务（Cron/Systemd Timer/Kubernetes CronJob）调用
2. **认证授权**：调度接口需要配置适当的认证机制，防止未授权调用
3. **监控告警**：建议监控调度任务的执行情况，失败时发送告警
4. **性能优化**：如果任务数量很大（> 1000），考虑实现分批处理或异步处理
