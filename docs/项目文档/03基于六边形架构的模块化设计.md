# ğŸ”· åŸºäºå…­è¾¹å½¢æ¶æ„çš„æ¨¡å—åŒ–è®¾è®¡

## ğŸ“‹ ç›®å½•

- [å…­è¾¹å½¢æ¶æ„æ¦‚è¿°](#hexagonal-overview)
- [ç«¯å£ä¸é€‚é…å™¨è®¾è®¡](#ports-adapters)
- [æ¨¡å—ç³»ç»Ÿæ¶æ„](#module-system)
- [ä¾èµ–æ³¨å…¥å®¹å™¨](#dependency-injection)
- [æ¨¡å—é—´é€šä¿¡](#inter-module-communication)
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#practical-cases)

## ğŸ¯ å…­è¾¹å½¢æ¶æ„æ¦‚è¿° {#hexagonal-overview}

æœ¬ç³»ç»Ÿé‡‡ç”¨å…­è¾¹å½¢æ¶æ„ï¼ˆHexagonal Architectureï¼‰ï¼Œä¹Ÿç§°ä¸ºç«¯å£å’Œé€‚é…å™¨æ¶æ„ï¼Œå®ç°äº†**ä¸šåŠ¡é€»è¾‘ä¸å¤–éƒ¨ä¾èµ–çš„å®Œå…¨è§£è€¦**ã€‚è¿™ç§æ¶æ„ç¡®ä¿æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ä¸å—å¤–éƒ¨æŠ€æœ¯é€‰æ‹©çš„å½±å“ã€‚

### ğŸ—ï¸ æ¶æ„å±‚æ¬¡å›¾

```mermaid
graph TB
    subgraph "å¤–éƒ¨ä¸–ç•Œ External World"
        CLIENT[å®¢æˆ·ç«¯]
        DB[(æ•°æ®åº“)]
        CACHE[(ç¼“å­˜)]
        MQ[æ¶ˆæ¯é˜Ÿåˆ—]
    end
    
    subgraph "å…­è¾¹å½¢æ¶æ„ Hexagonal Architecture"
        subgraph "é€‚é…å™¨å±‚ Adapters"
            subgraph "å…¥ç«™é€‚é…å™¨ Driving Adapters"
                REST[REST Handler]
                CLI[CLI Handler]
                GRPC[gRPC Handler]
            end
            
            subgraph "å‡ºç«™é€‚é…å™¨ Driven Adapters"
                MYSQL[MySQL Repository]
                MONGO[MongoDB Repository]
                REDIS[Redis Cache]
            end
        end
        
        subgraph "ç«¯å£å±‚ Ports"
            subgraph "å…¥ç«™ç«¯å£ Driving Ports"
                USERPORT[User Service Port]
                AUTHPORT[Auth Service Port]
                QUESPORT[Questionnaire Service Port]
            end
            
            subgraph "å‡ºç«™ç«¯å£ Driven Ports"
                REPOPORT[Repository Port]
                CACHEPORT[Cache Port]
                EVENTPORT[Event Port]
            end
        end
        
        subgraph "æ ¸å¿ƒä¸šåŠ¡å±‚ Core Business"
            subgraph "åº”ç”¨æœåŠ¡å±‚ Application Services"
                USERAPP[User Application]
                AUTHAPP[Auth Application]
                QUESAPP[Questionnaire Application]
            end
            
            subgraph "é¢†åŸŸå±‚ Domain Layer"
                USERDOMAIN[User Domain]
                AUTHDOMAIN[Auth Domain]
                QUESDOMAIN[Questionnaire Domain]
            end
        end
    end
    
    CLIENT --> REST
    CLI --> CLI
    
    REST --> USERPORT
    REST --> AUTHPORT
    REST --> QUESPORT
    
    USERPORT --> USERAPP
    AUTHPORT --> AUTHAPP
    QUESPORT --> QUESAPP
    
    USERAPP --> USERDOMAIN
    AUTHAPP --> AUTHDOMAIN
    QUESAPP --> QUESDOMAIN
    
    USERAPP --> REPOPORT
    AUTHAPP --> REPOPORT
    QUESAPP --> REPOPORT
    
    REPOPORT --> MYSQL
    REPOPORT --> MONGO
    CACHEPORT --> REDIS
    
    MYSQL --> DB
    MONGO --> DB
    REDIS --> CACHE
```

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **ä¾èµ–å€’ç½®**: ä¸šåŠ¡é€»è¾‘å®šä¹‰æ¥å£ï¼Œå¤–éƒ¨å®ç°æ¥å£
2. **ç«¯å£æŠ½è±¡**: é€šè¿‡æ¥å£éš”ç¦»å†…å¤–éƒ¨ä¾èµ–
3. **é€‚é…å™¨å°è£…**: å¤–éƒ¨æŠ€æœ¯ç»†èŠ‚å°è£…åœ¨é€‚é…å™¨ä¸­
4. **ä¸šåŠ¡ä¸­å¿ƒ**: ä¸šåŠ¡é€»è¾‘æ˜¯æ¶æ„çš„æ ¸å¿ƒ

## ğŸ”Œ ç«¯å£ä¸é€‚é…å™¨è®¾è®¡ {#ports-adapters}

### ğŸ“¥ å…¥ç«™ç«¯å£è®¾è®¡

å…¥ç«™ç«¯å£å®šä¹‰äº†å¤–éƒ¨ä¸–ç•Œè°ƒç”¨ä¸šåŠ¡é€»è¾‘çš„æ¥å£å¥‘çº¦ã€‚

#### 1. ç”¨æˆ·æœåŠ¡ç«¯å£

```go
// internal/apiserver/domain/user/port/service.go

package port

import (
    "context"
    "github.com/yshujie/questionnaire-scale/internal/apiserver/domain/user"
)

// UserCreator ç”¨æˆ·åˆ›å»ºæ¥å£
type UserCreator interface {
    CreateUser(ctx context.Context, username, password, nickname, email, phone, introduction string) (*user.User, error)
}

// UserQueryer ç”¨æˆ·æŸ¥è¯¢æ¥å£
type UserQueryer interface {
    GetUser(ctx context.Context, id uint64) (*user.User, error)
    GetUserByUsername(ctx context.Context, username string) (*user.User, error)
    ListUsers(ctx context.Context, page, pageSize int) ([]*user.User, int64, error)
}

// UserEditor ç”¨æˆ·ç¼–è¾‘æ¥å£
type UserEditor interface {
    UpdateBasicInfo(ctx context.Context, id uint64, nickname, email, phone, introduction string) (*user.User, error)
    UpdateAvatar(ctx context.Context, id uint64, avatar string) error
}

// PasswordChanger å¯†ç ç®¡ç†æ¥å£
type PasswordChanger interface {
    ChangePassword(ctx context.Context, id uint64, oldPassword, newPassword string) error
}

// UserActivator ç”¨æˆ·çŠ¶æ€ç®¡ç†æ¥å£
type UserActivator interface {
    ActivateUser(ctx context.Context, id uint64) error
    BlockUser(ctx context.Context, id uint64) error
    DeactivateUser(ctx context.Context, id uint64) error
}
```

#### 2. è®¤è¯æœåŠ¡ç«¯å£

```go
// internal/apiserver/domain/auth/port/service.go

// Authenticator è®¤è¯æ¥å£
type Authenticator interface {
    Authenticate(ctx context.Context, username, password string) (*user.User, error)
    GenerateToken(ctx context.Context, user *user.User) (string, time.Time, error)
    ValidateToken(ctx context.Context, token string) (*user.User, error)
    RefreshToken(ctx context.Context, refreshToken string) (string, time.Time, error)
}

// TokenManager ä»¤ç‰Œç®¡ç†æ¥å£
type TokenManager interface {
    CreateToken(userID uint64, expiration time.Duration) (string, error)
    ValidateToken(token string) (uint64, error)
    RevokeToken(token string) error
    RefreshToken(token string) (string, error)
}
```

### ğŸ“¤ å‡ºç«™ç«¯å£è®¾è®¡

å‡ºç«™ç«¯å£å®šä¹‰äº†ä¸šåŠ¡é€»è¾‘å¯¹å¤–éƒ¨ä¾èµ–çš„æ¥å£éœ€æ±‚ã€‚

#### 1. å­˜å‚¨åº“ç«¯å£

```go
// internal/apiserver/domain/user/port/repository.go

// UserRepository ç”¨æˆ·å­˜å‚¨åº“æ¥å£
type UserRepository interface {
    // åŸºç¡€CRUDæ“ä½œ
    Save(ctx context.Context, user *user.User) error
    FindByID(ctx context.Context, id uint64) (*user.User, error)
    FindByUsername(ctx context.Context, username string) (*user.User, error)
    Update(ctx context.Context, user *user.User) error
    Remove(ctx context.Context, id uint64) error
    
    // æŸ¥è¯¢æ“ä½œ
    List(ctx context.Context, offset, limit int) ([]*user.User, error)
    Count(ctx context.Context) (int64, error)
    
    // å­˜åœ¨æ€§æ£€æŸ¥
    ExistsByUsername(ctx context.Context, username string) bool
    ExistsByEmail(ctx context.Context, email string) bool
    ExistsByPhone(ctx context.Context, phone string) bool
}
```

#### 2. ç¼“å­˜ç«¯å£

```go
// internal/apiserver/domain/shared/port/cache.go

// CacheRepository ç¼“å­˜æ¥å£
type CacheRepository interface {
    Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
    Get(ctx context.Context, key string, dest interface{}) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) bool
    Increment(ctx context.Context, key string) (int64, error)
    Expire(ctx context.Context, key string, expiration time.Duration) error
}
```

### ğŸ”„ é€‚é…å™¨å®ç°

#### 1. RESTé€‚é…å™¨

```go
// internal/apiserver/interface/restful/handler/user.go

type UserHandler struct {
    BaseHandler
    userCreator         port.UserCreator
    userQueryer         port.UserQueryer
    userEditor          port.UserEditor
    userActivator       port.UserActivator
    userPasswordChanger port.PasswordChanger
}

// CreateUser åˆ›å»ºç”¨æˆ·RESTæ¥å£
func (h *UserHandler) CreateUser(c *gin.Context) {
    var req dto.CreateUserRequest
    if err := h.BindJSON(c, &req); err != nil {
        h.ErrorResponse(c, err)
        return
    }

    // è°ƒç”¨åº”ç”¨æœåŠ¡
    user, err := h.userCreator.CreateUser(
        c.Request.Context(),
        req.Username, req.Password, req.Nickname,
        req.Email, req.Phone, req.Introduction,
    )
    if err != nil {
        h.ErrorResponse(c, err)
        return
    }

    // è½¬æ¢ä¸ºDTOå“åº”
    response := &dto.UserResponse{
        ID:           user.ID().Value(),
        Username:     user.Username(),
        Nickname:     user.Nickname(),
        Email:        user.Email(),
        Phone:        user.Phone(),
        Avatar:       user.Avatar(),
        Introduction: user.Introduction(),
        Status:       user.Status().String(),
        CreatedAt:    user.CreatedAt().Format(time.RFC3339),
        UpdatedAt:    user.UpdatedAt().Format(time.RFC3339),
    }

    h.SuccessResponse(c, response)
}
```

#### 2. MySQLé€‚é…å™¨

```go
// internal/apiserver/infra/mysql/user/repo.go

type Repository struct {
    mysql.BaseRepository[*UserPO]
    mapper *UserMapper
}

func NewRepository(db *gorm.DB) port.UserRepository {
    return &Repository{
        BaseRepository: mysql.NewBaseRepository[*UserPO](db),
        mapper:         NewUserMapper(),
    }
}

// Save ä¿å­˜ç”¨æˆ·
func (r *Repository) Save(ctx context.Context, userDomain *user.User) error {
    po := r.mapper.ToPO(userDomain)
    return r.CreateAndSync(ctx, po, func(saved *UserPO) {
        userDomain.SetID(user.NewUserID(saved.ID))
        userDomain.SetCreatedAt(saved.CreatedAt)
        userDomain.SetUpdatedAt(saved.UpdatedAt)
    })
}

// FindByUsername æ ¹æ®ç”¨æˆ·åæŸ¥è¯¢ç”¨æˆ·
func (r *Repository) FindByUsername(ctx context.Context, username string) (*user.User, error) {
    var po UserPO
    err := r.BaseRepository.FindByField(ctx, &po, "username", username)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.WithCode(code.ErrUserNotFound, "user not found: %s", username)
        }
        return nil, err
    }
    return r.mapper.ToBO(&po), nil
}
```

## ğŸ—ï¸ æ¨¡å—ç³»ç»Ÿæ¶æ„ {#module-system}

### ğŸ“¦ æ¨¡å—æ¥å£è®¾è®¡

```go
// internal/apiserver/container/assembler/module.go

// Module æ¨¡å—æ¥å£
type Module interface {
    // Initialize åˆå§‹åŒ–æ¨¡å—
    Initialize(params ...interface{}) error
    
    // CheckHealth å¥åº·æ£€æŸ¥
    CheckHealth() error
    
    // Cleanup æ¸…ç†èµ„æº
    Cleanup() error
    
    // ModuleInfo æ¨¡å—ä¿¡æ¯
    ModuleInfo() ModuleInfo
}

// ModuleInfo æ¨¡å—ä¿¡æ¯
type ModuleInfo struct {
    Name        string `json:"name"`
    Version     string `json:"version"`
    Description string `json:"description"`
}
```

### ğŸ‘¤ ç”¨æˆ·æ¨¡å—å®ç°

```go
// internal/apiserver/container/assembler/user.go

// UserModule ç”¨æˆ·æ¨¡å—
type UserModule struct {
    // åŸºç¡€è®¾æ–½å±‚
    UserRepo port.UserRepository

    // åº”ç”¨æœåŠ¡å±‚
    UserCreator         port.UserCreator
    UserQueryer         port.UserQueryer
    UserEditor          port.UserEditor
    UserActivator       port.UserActivator
    UserPasswordChanger port.PasswordChanger

    // æ¥å£å±‚
    UserHandler *userHandler.Handler
}

// NewUserModule åˆ›å»ºç”¨æˆ·æ¨¡å—
func NewUserModule() *UserModule {
    return &UserModule{}
}

// Initialize åˆå§‹åŒ–ç”¨æˆ·æ¨¡å—
func (m *UserModule) Initialize(params ...interface{}) error {
    if len(params) == 0 {
        return fmt.Errorf("missing required parameter: database connection")
    }

    db, ok := params[0].(*gorm.DB)
    if !ok {
        return fmt.Errorf("invalid parameter type, expected *gorm.DB")
    }

    // 1. åˆå§‹åŒ–åŸºç¡€è®¾æ–½å±‚
    m.UserRepo = userRepo.NewRepository(db)

    // 2. åˆå§‹åŒ–åº”ç”¨æœåŠ¡å±‚
    m.UserCreator = userApp.NewUserCreator(m.UserRepo)
    m.UserQueryer = userApp.NewUserQueryer(m.UserRepo)
    m.UserEditor = userApp.NewUserEditor(m.UserRepo)
    m.UserActivator = userApp.NewUserActivator(m.UserRepo)
    m.UserPasswordChanger = userApp.NewPasswordChanger(m.UserRepo)

    // 3. åˆå§‹åŒ–æ¥å£å±‚
    m.UserHandler = userHandler.NewHandler(
        m.UserCreator,
        m.UserQueryer,
        m.UserEditor,
        m.UserActivator,
        m.UserPasswordChanger,
    )

    return nil
}

// CheckHealth å¥åº·æ£€æŸ¥
func (m *UserModule) CheckHealth() error {
    // æ£€æŸ¥åŸºç¡€è®¾æ–½è¿æ¥çŠ¶æ€
    // è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„å¥åº·æ£€æŸ¥é€»è¾‘
    return nil
}

// Cleanup æ¸…ç†èµ„æº
func (m *UserModule) Cleanup() error {
    // æ¸…ç†æ¨¡å—èµ„æº
    return nil
}

// ModuleInfo è¿”å›æ¨¡å—ä¿¡æ¯
func (m *UserModule) ModuleInfo() ModuleInfo {
    return ModuleInfo{
        Name:        "user",
        Version:     "1.0.0",
        Description: "ç”¨æˆ·ç®¡ç†æ¨¡å—",
    }
}
```

### ğŸ›ï¸ æ¨¡å—ä¾èµ–å…³ç³»

```mermaid
graph TB
    subgraph "ç”¨æˆ·æ¨¡å— User Module"
        USERHANDLER[User Handler<br/>æ¥å£å±‚]
        USERAPP[User Application<br/>åº”ç”¨å±‚]
        USERDOMAIN[User Domain<br/>é¢†åŸŸå±‚]
        USERREPO[User Repository<br/>åŸºç¡€è®¾æ–½å±‚]
    end
    
    subgraph "è®¤è¯æ¨¡å— Auth Module"
        AUTHHANDLER[Auth Handler<br/>æ¥å£å±‚]
        AUTHAPP[Auth Application<br/>åº”ç”¨å±‚]
        AUTHDOMAIN[Auth Domain<br/>é¢†åŸŸå±‚]
    end
    
    subgraph "é—®å·æ¨¡å— Questionnaire Module"
        QUESHANDLER[Questionnaire Handler<br/>æ¥å£å±‚]
        QUESAPP[Questionnaire Application<br/>åº”ç”¨å±‚]
        QUESDOMAIN[Questionnaire Domain<br/>é¢†åŸŸå±‚]
        QUESREPO[Questionnaire Repository<br/>åŸºç¡€è®¾æ–½å±‚]
    end
    
    USERHANDLER --> USERAPP
    USERAPP --> USERDOMAIN
    USERAPP --> USERREPO
    
    AUTHHANDLER --> AUTHAPP
    AUTHAPP --> AUTHDOMAIN
    AUTHAPP --> USERAPP
    
    QUESHANDLER --> QUESAPP
    QUESAPP --> QUESDOMAIN
    QUESAPP --> QUESREPO
```

## ğŸ—ï¸ ä¾èµ–æ³¨å…¥å®¹å™¨ {#dependency-injection}

### ğŸ“¦ å®¹å™¨è®¾è®¡

```go
// internal/apiserver/container/container.go

type Container struct {
    // åŸºç¡€è®¾æ–½
    mysqlDB *gorm.DB
    mongoDB *mongo.Database

    // ä¸šåŠ¡æ¨¡å—
    AuthModule          *assembler.AuthModule
    UserModule          *assembler.UserModule
    QuestionnaireModule *assembler.QuestionnaireModule

    // å®¹å™¨çŠ¶æ€
    initialized bool
}

func NewContainer(mysqlDB *gorm.DB, mongoDB *mongo.Database) *Container {
    return &Container{
        mysqlDB:     mysqlDB,
        mongoDB:     mongoDB,
        initialized: false,
    }
}
```

### ğŸ”§ æ¨¡å—åˆå§‹åŒ–æµç¨‹

```mermaid
sequenceDiagram
    participant Container as å®¹å™¨
    participant UserModule as ç”¨æˆ·æ¨¡å—
    participant AuthModule as è®¤è¯æ¨¡å—
    participant QuesModule as é—®å·æ¨¡å—
    participant DB as æ•°æ®åº“
    
    Container->>Container: NewContainer()
    Container->>UserModule: Initialize(mysqlDB)
    UserModule->>DB: åˆ›å»ºRepository
    UserModule->>UserModule: åˆ›å»ºApplicationService
    UserModule->>UserModule: åˆ›å»ºHandler
    UserModule-->>Container: åˆå§‹åŒ–å®Œæˆ
    
    Container->>AuthModule: Initialize(mysqlDB)
    AuthModule->>AuthModule: æ³¨å…¥UserModuleä¾èµ–
    AuthModule-->>Container: åˆå§‹åŒ–å®Œæˆ
    
    Container->>QuesModule: Initialize(mysqlDB, mongoDB)
    QuesModule->>DB: åˆ›å»ºMySQLå’ŒMongoDB Repository
    QuesModule-->>Container: åˆå§‹åŒ–å®Œæˆ
```

### ğŸ”„ ä¾èµ–æ³¨å…¥å®ç°

```go
// Initialize åˆå§‹åŒ–å®¹å™¨
func (c *Container) Initialize() error {
    if c.initialized {
        return nil
    }

    // 1. åˆå§‹åŒ–ç”¨æˆ·æ¨¡å—
    if err := c.initUserModule(); err != nil {
        return fmt.Errorf("failed to initialize user module: %w", err)
    }

    // 2. åˆå§‹åŒ–è®¤è¯æ¨¡å—ï¼ˆä¾èµ–ç”¨æˆ·æ¨¡å—ï¼‰
    if err := c.initAuthModule(); err != nil {
        return fmt.Errorf("failed to initialize auth module: %w", err)
    }

    // 3. åˆå§‹åŒ–é—®å·æ¨¡å—
    if err := c.initQuestionnaireModule(); err != nil {
        return fmt.Errorf("failed to initialize questionnaire module: %w", err)
    }

    c.initialized = true
    return nil
}

// initAuthModule åˆå§‹åŒ–è®¤è¯æ¨¡å—ï¼ˆå±•ç¤ºæ¨¡å—é—´ä¾èµ–ï¼‰
func (c *Container) initAuthModule() error {
    authModule := assembler.NewAuthModule()
    
    // æ³¨å…¥ç”¨æˆ·æ¨¡å—çš„ä¾èµ–
    if err := authModule.Initialize(c.mysqlDB, c.UserModule.UserQueryer); err != nil {
        return fmt.Errorf("failed to initialize auth module: %w", err)
    }

    c.AuthModule = authModule
    return nil
}
```

## ğŸ“¡ æ¨¡å—é—´é€šä¿¡ {#inter-module-communication}

### ğŸ”„ åŒæ­¥é€šä¿¡

æ¨¡å—é—´é€šè¿‡æ˜ç¡®çš„æ¥å£è¿›è¡ŒåŒæ­¥é€šä¿¡ï¼š

```go
// è®¤è¯æ¨¡å—ä¾èµ–ç”¨æˆ·æ¨¡å—çš„æŸ¥è¯¢åŠŸèƒ½
type AuthApplication struct {
    userQueryer port.UserQueryer  // ä¾èµ–ç”¨æˆ·æ¨¡å—çš„æ¥å£
    tokenManager TokenManager
}

func (a *AuthApplication) Authenticate(ctx context.Context, username, password string) (*user.User, error) {
    // é€šè¿‡ç”¨æˆ·æ¨¡å—æ¥å£æŸ¥è¯¢ç”¨æˆ·
    user, err := a.userQueryer.GetUserByUsername(ctx, username)
    if err != nil {
        return nil, err
    }
    
    // éªŒè¯å¯†ç 
    if !user.ValidatePassword(password) {
        return nil, errors.New("invalid password")
    }
    
    return user, nil
}
```

### ğŸ“¨ äº‹ä»¶é€šä¿¡ï¼ˆæ‰©å±•è®¾è®¡ï¼‰

å¯¹äºæ¾è€¦åˆçš„æ¨¡å—é—´é€šä¿¡ï¼Œå¯ä»¥å¼•å…¥äº‹ä»¶æœºåˆ¶ï¼š

```go
// é¢†åŸŸäº‹ä»¶æ¥å£
type DomainEvent interface {
    EventType() string
    AggregateID() string
    OccurredOn() time.Time
}

// ç”¨æˆ·åˆ›å»ºäº‹ä»¶
type UserCreatedEvent struct {
    userID      string
    username    string
    occurredOn  time.Time
}

// äº‹ä»¶æ€»çº¿
type EventBus interface {
    Publish(event DomainEvent) error
    Subscribe(eventType string, handler EventHandler) error
}
```

## ğŸ“š å®é™…åº”ç”¨æ¡ˆä¾‹ {#practical-cases}

### ğŸ¯ ç”¨æˆ·æ³¨å†Œæµç¨‹

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant Handler as REST Handler
    participant UserApp as User Application
    participant UserDomain as User Domain
    participant UserRepo as User Repository
    participant DB as MySQL
    
    Client->>Handler: POST /users
    Handler->>Handler: éªŒè¯è¯·æ±‚å‚æ•°
    Handler->>UserApp: CreateUser()
    UserApp->>UserApp: æ£€æŸ¥ç”¨æˆ·åå”¯ä¸€æ€§
    UserApp->>UserDomain: NewUser()
    UserDomain->>UserDomain: éªŒè¯ä¸šåŠ¡è§„åˆ™
    UserDomain->>UserDomain: å¯†ç åŠ å¯†
    UserApp->>UserRepo: Save()
    UserRepo->>DB: INSERT
    DB-->>UserRepo: è¿”å›ID
    UserRepo-->>UserApp: ç”¨æˆ·å®ä½“
    UserApp-->>Handler: ç”¨æˆ·å®ä½“
    Handler-->>Client: 201 Created
```

### ğŸ”‘ ç”¨æˆ·è®¤è¯æµç¨‹

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant AuthHandler as Auth Handler
    participant AuthApp as Auth Application
    participant UserApp as User Application
    participant TokenManager as Token Manager
    
    Client->>AuthHandler: POST /auth/login
    AuthHandler->>AuthApp: Authenticate()
    AuthApp->>UserApp: GetUserByUsername()
    UserApp-->>AuthApp: ç”¨æˆ·å®ä½“
    AuthApp->>AuthApp: éªŒè¯å¯†ç 
    AuthApp->>TokenManager: GenerateToken()
    TokenManager-->>AuthApp: JWT Token
    AuthApp-->>AuthHandler: è®¤è¯ç»“æœ
    AuthHandler-->>Client: 200 OK + Token
```

## ğŸ¯ æ¶æ„ä¼˜åŠ¿æ€»ç»“

### âœ… ä¸šåŠ¡ä»·å€¼

1. **ä¸šåŠ¡é€»è¾‘ä¿æŠ¤**: æ ¸å¿ƒä¸šåŠ¡ä¸å—æŠ€æœ¯å˜æ›´å½±å“
2. **å¿«é€Ÿè¿­ä»£**: æ–°åŠŸèƒ½é€šè¿‡æ–°é€‚é…å™¨å¿«é€Ÿæ¥å…¥
3. **æŠ€æœ¯å€ºåŠ¡æ§åˆ¶**: æŠ€æœ¯å˜æ›´å±€é™åœ¨é€‚é…å™¨å±‚
4. **å›¢é˜Ÿåä½œ**: ä¸åŒå›¢é˜Ÿå¯å¹¶è¡Œå¼€å‘ä¸åŒæ¨¡å—

### ğŸ”§ æŠ€æœ¯ä¼˜åŠ¿

1. **é«˜åº¦å¯æµ‹è¯•**: æ¯å±‚éƒ½å¯ç‹¬ç«‹è¿›è¡Œå•å…ƒæµ‹è¯•
2. **çµæ´»æ›¿æ¢**: æ•°æ®åº“ã€æ¶ˆæ¯é˜Ÿåˆ—å¯æ— ç¼åˆ‡æ¢
3. **æ¨¡å—å¤ç”¨**: æ¨¡å—å¯åœ¨ä¸åŒé¡¹ç›®é—´å¤ç”¨
4. **æ¸…æ™°è¾¹ç•Œ**: æ¯ä¸ªæ¨¡å—èŒè´£æ˜ç¡®ï¼Œè¾¹ç•Œæ¸…æ™°

### ğŸ“ˆ æ‰©å±•èƒ½åŠ›

1. **æ–°æ¥å£ç±»å‹**: å¢åŠ GraphQLã€gRPCæ¥å£
2. **æ–°å­˜å‚¨æ–¹æ¡ˆ**: å¢åŠ ElasticSearchã€ClickHouse
3. **æ–°è®¤è¯æ–¹å¼**: å¢åŠ OAuth2ã€SAMLè®¤è¯
4. **å¾®æœåŠ¡æ¼”è¿›**: æ¨¡å—å¯ç‹¬ç«‹éƒ¨ç½²ä¸ºå¾®æœåŠ¡

è¿™ç§åŸºäºå…­è¾¹å½¢æ¶æ„çš„æ¨¡å—åŒ–è®¾è®¡ï¼Œä¸ºç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§åŸºç¡€ã€‚ 