# ğŸ“ æ—¥å¿—æ¨¡å—è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [åŸºäºZapçš„æ—¥å¿—æ¶æ„](#zap-architecture)
- [ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ—¥å¿—](#context-aware-logging)
- [ç»“æ„åŒ–æ—¥å¿—è®¾è®¡](#structured-logging)
- [æ—¥å¿—ä¸­é—´ä»¶ç³»ç»Ÿ](#logging-middleware)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#performance-optimization)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æœ¬é¡¹ç›®çš„æ—¥å¿—æ¨¡å—åŸºäº**Uber Zap**æ„å»ºäº†é«˜æ€§èƒ½ã€ç»“æ„åŒ–çš„æ—¥å¿—ç³»ç»Ÿï¼Œé‡‡ç”¨**ä¸Šä¸‹æ–‡æ„ŸçŸ¥**è®¾è®¡ï¼Œå®ç°äº†**é›¶åˆ†é…**çš„æ—¥å¿—è®°å½•å’Œ**çµæ´»çš„è¾“å‡ºæ ¼å¼**ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **é«˜æ€§èƒ½**: åŸºäºZapçš„é›¶åˆ†é…æ—¥å¿—è®°å½•
2. **ç»“æ„åŒ–**: æ”¯æŒé”®å€¼å¯¹çš„ç»“æ„åŒ–æ—¥å¿—
3. **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**: è‡ªåŠ¨æå–è¯·æ±‚ä¸Šä¸‹æ–‡ä¿¡æ¯
4. **å¤šçº§åˆ«**: æ”¯æŒDebugã€Infoã€Warnã€Errorã€Panicã€Fatalå…­ä¸ªçº§åˆ«
5. **å¤šæ ¼å¼**: æ”¯æŒJSONå’ŒConsoleä¸¤ç§è¾“å‡ºæ ¼å¼
6. **ä¸­é—´ä»¶é›†æˆ**: ä¸HTTPä¸­é—´ä»¶æ— ç¼é›†æˆ

### ğŸ¨ æ¶æ„è®¾è®¡åŸåˆ™

- **å•ä¾‹æ¨¡å¼**: å…¨å±€ç»Ÿä¸€çš„æ—¥å¿—å®ä¾‹
- **å·¥å‚æ¨¡å¼**: åŸºäºé…ç½®åˆ›å»ºä¸åŒçš„æ—¥å¿—å™¨
- **é€‚é…å™¨æ¨¡å¼**: å…¼å®¹æ ‡å‡†åº“logæ¥å£
- **ä¸Šä¸‹æ–‡æ¨¡å¼**: æ”¯æŒè¯·æ±‚é“¾è·¯è¿½è¸ª

## ğŸš€ åŸºäºZapçš„æ—¥å¿—æ¶æ„ {#zap-architecture}

### ğŸ“¦ æ ¸å¿ƒç»“æ„

```go
// pkg/log/log.go

// Logger æ—¥å¿—æ¥å£å®šä¹‰
type Logger interface {
    // åŸºç¡€æ—¥å¿—æ–¹æ³•
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
    Panic(msg string, fields ...Field)
    Fatal(msg string, fields ...Field)
    
    // æ ¼å¼åŒ–æ—¥å¿—æ–¹æ³•
    Debugf(format string, v ...interface{})
    Infof(format string, v ...interface{})
    Warnf(format string, v ...interface{})
    Errorf(format string, v ...interface{})
    Panicf(format string, v ...interface{})
    Fatalf(format string, v ...interface{})
    
    // é”®å€¼å¯¹æ—¥å¿—æ–¹æ³•
    Debugw(msg string, keysAndValues ...interface{})
    Infow(msg string, keysAndValues ...interface{})
    Warnw(msg string, keysAndValues ...interface{})
    Errorw(msg string, keysAndValues ...interface{})
    Panicw(msg string, keysAndValues ...interface{})
    Fatalw(msg string, keysAndValues ...interface{})
    
    // ä¸Šä¸‹æ–‡æ–¹æ³•
    WithValues(keysAndValues ...interface{}) Logger
    WithName(name string) Logger
    WithContext(ctx context.Context) context.Context
    
    // å·¥å…·æ–¹æ³•
    V(level Level) InfoLogger
    Write(p []byte) (n int, err error)
    Flush()
}
```

### ğŸ”§ Zapæ—¥å¿—å™¨å®ç°

```go
// zapLogger Zapæ—¥å¿—å™¨å®ç°
type zapLogger struct {
    zapLogger *zap.Logger
    infoLogger
}

// New åˆ›å»ºæ–°çš„æ—¥å¿—å™¨
func New(opts *Options) *zapLogger {
    if opts == nil {
        opts = NewOptions()
    }

    var zapLevel zapcore.Level
    if err := zapLevel.UnmarshalText([]byte(opts.Level)); err != nil {
        zapLevel = zapcore.InfoLevel
    }
    
    encodeLevel := zapcore.CapitalLevelEncoder
    if opts.Format == consoleFormat && opts.EnableColor {
        encodeLevel = zapcore.CapitalColorLevelEncoder
    }

    encoderConfig := zapcore.EncoderConfig{
        MessageKey:     "message",
        LevelKey:       "level",
        TimeKey:        "timestamp",
        NameKey:        "logger",
        CallerKey:      "caller",
        StacktraceKey:  "stacktrace",
        LineEnding:     zapcore.DefaultLineEnding,
        EncodeLevel:    encodeLevel,
        EncodeTime:     timeEncoder,
        EncodeDuration: milliSecondsDurationEncoder,
        EncodeCaller:   zapcore.ShortCallerEncoder,
    }

    loggerConfig := &zap.Config{
        Level:             zap.NewAtomicLevelAt(zapLevel),
        Development:       opts.Development,
        DisableCaller:     opts.DisableCaller,
        DisableStacktrace: opts.DisableStacktrace,
        Sampling: &zap.SamplingConfig{
            Initial:    100,
            Thereafter: 100,
        },
        Encoding:         opts.Format,
        EncoderConfig:    encoderConfig,
        OutputPaths:      opts.OutputPaths,
        ErrorOutputPaths: opts.ErrorOutputPaths,
    }

    l, err := loggerConfig.Build(zap.AddStacktrace(zapcore.PanicLevel), zap.AddCallerSkip(1))
    if err != nil {
        panic(err)
    }
    
    logger := &zapLogger{
        zapLogger: l.Named(opts.Name),
        infoLogger: infoLogger{
            log:   l,
            level: zap.InfoLevel,
        },
    }
    
    return logger
}
```

### âš™ï¸ é…ç½®é€‰é¡¹

```go
// Options æ—¥å¿—é…ç½®é€‰é¡¹
type Options struct {
    Level             string   `json:"level" mapstructure:"level"`
    Development       bool     `json:"development" mapstructure:"development"`
    Name              string   `json:"name" mapstructure:"name"`
    DisableCaller     bool     `json:"disable-caller" mapstructure:"disable-caller"`
    DisableStacktrace bool     `json:"disable-stacktrace" mapstructure:"disable-stacktrace"`
    Format            string   `json:"format" mapstructure:"format"`
    EnableColor       bool     `json:"enable-color" mapstructure:"enable-color"`
    OutputPaths       []string `json:"output-paths" mapstructure:"output-paths"`
    ErrorOutputPaths  []string `json:"error-output-paths" mapstructure:"error-output-paths"`
}

// NewOptions åˆ›å»ºé»˜è®¤é…ç½®
func NewOptions() *Options {
    return &Options{
        Level:             zapcore.InfoLevel.String(),
        Development:       false,
        Name:              "",
        DisableCaller:     false,
        DisableStacktrace: false,
        Format:            consoleFormat,
        EnableColor:       false,
        OutputPaths:       []string{"stdout"},
        ErrorOutputPaths:  []string{"stderr"},
    }
}
```

## ğŸ§  ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ—¥å¿— {#context-aware-logging}

### ğŸ“¡ ä¸Šä¸‹æ–‡æå–

```go
// L ä»ä¸Šä¸‹æ–‡ä¸­è·å–æ—¥å¿—å™¨
func L(ctx context.Context) *zapLogger {
    return std.L(ctx)
}

func (l *zapLogger) L(ctx context.Context) *zapLogger {
    lg := l.clone()

    if requestID := ctx.Value(KeyRequestID); requestID != nil {
        lg.zapLogger = lg.zapLogger.With(zap.Any(KeyRequestID.String(), requestID))
    }

    if username := ctx.Value(KeyUsername); username != nil {
        lg.zapLogger = lg.zapLogger.With(zap.Any(KeyUsername.String(), username))
    }

    return lg
}

// WithContext å°†æ—¥å¿—å™¨æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
func (l *zapLogger) WithContext(ctx context.Context) context.Context {
    return context.WithValue(ctx, KeyLogger, l)
}
```

### ğŸ”— è¯·æ±‚é“¾è·¯è¿½è¸ª

```go
// ä¸Šä¸‹æ–‡é”®å®šä¹‰
type contextKey string

const (
    KeyRequestID contextKey = "requestID"
    KeyUsername  contextKey = "username"
    KeyUserID    contextKey = "userID"
    KeyLogger    contextKey = "logger"
)

// String å®ç°Stringeræ¥å£
func (c contextKey) String() string {
    return string(c)
}
```

### ğŸ“ ä½¿ç”¨ç¤ºä¾‹

```go
// åœ¨HTTPå¤„ç†å™¨ä¸­ä½¿ç”¨ä¸Šä¸‹æ–‡æ—¥å¿—
func (h *Handler) CreateUser(c *gin.Context) {
    // ä»ä¸Šä¸‹æ–‡è·å–å¢å¼ºçš„æ—¥å¿—å™¨
    logger := log.L(c.Request.Context())
    
    // è®°å½•è¯·æ±‚å¼€å§‹
    logger.Info("Creating user", 
        zap.String("username", req.Username),
        zap.String("email", req.Email),
    )
    
    // ä¸šåŠ¡é€»è¾‘...
    user, err := h.userService.CreateUser(c.Request.Context(), req)
    if err != nil {
        logger.Error("Failed to create user",
            zap.Error(err),
            zap.String("username", req.Username),
        )
        return
    }
    
    // è®°å½•æˆåŠŸç»“æœ
    logger.Info("User created successfully",
        zap.Uint64("userID", user.ID),
        zap.String("username", user.Username),
    )
}
```

## ğŸ—ï¸ ç»“æ„åŒ–æ—¥å¿—è®¾è®¡ {#structured-logging}

### ğŸ“Š å­—æ®µç±»å‹ç³»ç»Ÿ

```go
// Field æ—¥å¿—å­—æ®µç±»å‹åˆ«å
type Field = zap.Field

// å¸¸ç”¨å­—æ®µæ„é€ å‡½æ•°
var (
    Skip        = zap.Skip
    Binary      = zap.Binary
    Bool        = zap.Bool
    Boolp       = zap.Boolp
    ByteString  = zap.ByteString
    Complex128  = zap.Complex128
    Complex128p = zap.Complex128p
    Complex64   = zap.Complex64
    Complex64p  = zap.Complex64p
    Float64     = zap.Float64
    Float64p    = zap.Float64p
    Float32     = zap.Float32
    Float32p    = zap.Float32p
    Int         = zap.Int
    Intp        = zap.Intp
    Int64       = zap.Int64
    Int64p      = zap.Int64p
    Int32       = zap.Int32
    Int32p      = zap.Int32p
    Int16       = zap.Int16
    Int16p      = zap.Int16p
    Int8        = zap.Int8
    Int8p       = zap.Int8p
    String      = zap.String
    Stringp     = zap.Stringp
    Uint        = zap.Uint
    Uintp       = zap.Uintp
    Uint64      = zap.Uint64
    Uint64p     = zap.Uint64p
    Uint32      = zap.Uint32
    Uint32p     = zap.Uint32p
    Uint16      = zap.Uint16
    Uint16p     = zap.Uint16p
    Uint8       = zap.Uint8
    Uint8p      = zap.Uint8p
    Uintptr     = zap.Uintptr
    Uintptrp    = zap.Uintptrp
    Reflect     = zap.Reflect
    Namespace   = zap.Namespace
    Stringer    = zap.Stringer
    Time        = zap.Time
    Timep       = zap.Timep
    Stack       = zap.Stack
    StackSkip   = zap.StackSkip
    Duration    = zap.Duration
    Durationp   = zap.Durationp
    Any         = zap.Any
)
```

### ğŸ¯ ç»“æ„åŒ–æ—¥å¿—ç¤ºä¾‹

```go
// 1. åŸºç¡€ç»“æ„åŒ–æ—¥å¿—
log.Info("User operation completed",
    zap.String("operation", "create"),
    zap.Uint64("userID", 12345),
    zap.String("username", "john_doe"),
    zap.Duration("duration", time.Millisecond*150),
    zap.Int("status_code", 201),
)

// 2. åµŒå¥—ç»“æ„æ—¥å¿—
log.Info("API request processed",
    zap.String("method", "POST"),
    zap.String("path", "/api/v1/users"),
    zap.Namespace("request"),
        zap.String("user_agent", req.UserAgent()),
        zap.String("remote_addr", req.RemoteAddr),
        zap.Int64("content_length", req.ContentLength),
    zap.Namespace("response"),
        zap.Int("status_code", 201),
        zap.Duration("response_time", time.Millisecond*120),
)

// 3. é”™è¯¯æ—¥å¿—
log.Error("Database operation failed",
    zap.Error(err),
    zap.String("operation", "insert"),
    zap.String("table", "users"),
    zap.Any("payload", user),
    zap.Stack("stacktrace"),
)
```

### ğŸ“‹ JSONæ ¼å¼è¾“å‡º

```json
{
    "level": "info",
    "timestamp": "2024-01-15T10:30:45.123Z",
    "caller": "handler/user.go:45",
    "message": "User operation completed",
    "operation": "create",
    "userID": 12345,
    "username": "john_doe",
    "duration": "150ms",
    "status_code": 201,
    "requestID": "req-123456",
    "username": "admin"
}
```

## ğŸ”Œ æ—¥å¿—ä¸­é—´ä»¶ç³»ç»Ÿ {#logging-middleware}

### ğŸ“¡ HTTPè¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶

```go
// internal/pkg/middleware/logger.go

// Logger HTTPè¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
func Logger() gin.HandlerFunc {
    return gin.LoggerWithConfig(gin.LoggerConfig{
        Formatter: func(param gin.LogFormatterParams) string {
            var statusColor, methodColor, resetColor string
            if param.IsOutputColor() {
                statusColor = param.StatusCodeColor()
                methodColor = param.MethodColor()
                resetColor = param.ResetColor()
            }

            if param.Latency > time.Minute {
                param.Latency = param.Latency.Truncate(time.Second)
            }

            return fmt.Sprintf("[GIN] %v |%s %3d %s| %13v | %15s |%s %-7s %s %#v\n%s",
                param.TimeStamp.Format("2006/01/02 - 15:04:05"),
                statusColor, param.StatusCode, resetColor,
                param.Latency,
                param.ClientIP,
                methodColor, param.Method, resetColor,
                param.Path,
                param.ErrorMessage,
            )
        },
        Output: log.StdInfoLogger().Writer(),
    })
}
```

### ğŸ” å¢å¼ºæ—¥å¿—ä¸­é—´ä»¶

```go
// enhanced_logger.go

// Logger å¢å¼ºHTTPæ—¥å¿—ä¸­é—´ä»¶
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        method := c.Request.Method
        
        // ä»ä¸Šä¸‹æ–‡è·å–æ—¥å¿—å™¨
        logger := log.L(c.Request.Context())
        
        // è®°å½•è¯·æ±‚å¼€å§‹
        logger.Info("HTTP request started",
            zap.String("method", method),
            zap.String("path", path),
            zap.String("user_agent", c.Request.UserAgent()),
            zap.String("remote_addr", c.ClientIP()),
            zap.Int64("content_length", c.Request.ContentLength),
        )

        // å¤„ç†è¯·æ±‚
        c.Next()

        // è®¡ç®—å¤„ç†æ—¶é—´
        latency := time.Since(start)
        statusCode := c.Writer.Status()

        // æ ¹æ®çŠ¶æ€ç é€‰æ‹©æ—¥å¿—çº§åˆ«
        logFunc := logger.Info
        if statusCode >= 400 && statusCode < 500 {
            logFunc = logger.Warn
        } else if statusCode >= 500 {
            logFunc = logger.Error
        }

        // è®°å½•è¯·æ±‚å®Œæˆ
        logFunc("HTTP request completed",
            zap.String("method", method),
            zap.String("path", path),
            zap.Int("status_code", statusCode),
            zap.Duration("latency", latency),
            zap.Int("response_size", c.Writer.Size()),
        )
    }
}
```

### ğŸ“Š SQLæ—¥å¿—è®°å½•

```go
// pkg/log/sql.go

// NewGormLogger åˆ›å»ºGORMæ—¥å¿—é€‚é…å™¨
func NewGormLogger() logger.Interface {
    return &gormLogger{
        logger:                    log.ZapLogger(),
        LogLevel:                  logger.Info,
        SlowThreshold:             200 * time.Millisecond,
        IgnoreRecordNotFoundError: false,
    }
}

type gormLogger struct {
    logger                    *zap.Logger
    LogLevel                  logger.LogLevel
    SlowThreshold             time.Duration
    IgnoreRecordNotFoundError bool
}

// LogMode è®¾ç½®æ—¥å¿—çº§åˆ«
func (l *gormLogger) LogMode(level logger.LogLevel) logger.Interface {
    newlogger := *l
    newlogger.LogLevel = level
    return &newlogger
}

// Info è®°å½•Infoçº§åˆ«æ—¥å¿—
func (l *gormLogger) Info(ctx context.Context, msg string, data ...interface{}) {
    if l.LogLevel >= logger.Info {
        l.logger.Sugar().Infof(msg, data...)
    }
}

// Warn è®°å½•Warnçº§åˆ«æ—¥å¿—
func (l *gormLogger) Warn(ctx context.Context, msg string, data ...interface{}) {
    if l.LogLevel >= logger.Warn {
        l.logger.Sugar().Warnf(msg, data...)
    }
}

// Error è®°å½•Errorçº§åˆ«æ—¥å¿—
func (l *gormLogger) Error(ctx context.Context, msg string, data ...interface{}) {
    if l.LogLevel >= logger.Error {
        l.logger.Sugar().Errorf(msg, data...)
    }
}

// Trace è®°å½•SQLæ‰§è¡Œæ—¥å¿—
func (l *gormLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) {
    if l.LogLevel <= logger.Silent {
        return
    }

    elapsed := time.Since(begin)
    sql, rows := fc()

    fields := []zap.Field{
        zap.String("sql", sql),
        zap.Duration("elapsed", elapsed),
        zap.Int64("rows", rows),
    }

    if err != nil && (!errors.Is(err, gorm.ErrRecordNotFound) || !l.IgnoreRecordNotFoundError) {
        fields = append(fields, zap.Error(err))
        l.logger.Error("SQL execution failed", fields...)
    } else if elapsed > l.SlowThreshold && l.SlowThreshold != 0 {
        l.logger.Warn("Slow SQL detected", fields...)
    } else {
        l.logger.Debug("SQL executed", fields...)
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ {#performance-optimization}

### ğŸš€ é›¶åˆ†é…æ—¥å¿—

```go
// ä½¿ç”¨ç»“æ„åŒ–å­—æ®µé¿å…å†…å­˜åˆ†é…
log.Info("User created",
    zap.Uint64("id", user.ID),      // é›¶åˆ†é…
    zap.String("name", user.Name),  // é›¶åˆ†é…
)

// é¿å…ä½¿ç”¨æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼ˆä¼šäº§ç”Ÿåˆ†é…ï¼‰
// log.Infof("User %s created with ID %d", user.Name, user.ID)  // é¿å…è¿™æ ·åš
```

### ğŸ“Š æ¡ä»¶æ—¥å¿—

```go
// V() æ–¹æ³•å®ç°æ¡ä»¶æ—¥å¿—ï¼Œé¿å…ä¸å¿…è¦çš„è®¡ç®—
if log.V(zapcore.DebugLevel).Enabled() {
    expensiveData := calculateExpensiveData()
    log.Debug("Debug info", zap.Any("data", expensiveData))
}
```

### ğŸ”„ å¼‚æ­¥æ—¥å¿—

```go
// é…ç½®å¼‚æ­¥æ—¥å¿—å†™å…¥
func configureAsyncLogging() zapcore.Core {
    // åˆ›å»ºå¼‚æ­¥å†™å…¥å™¨
    writer := &zapcore.BufferedWriteSyncer{
        WS:   zapcore.AddSync(os.Stdout),
        Size: 256 * 1024, // 256KB buffer
    }

    return zapcore.NewCore(
        zapcore.NewJSONEncoder(encoderConfig),
        writer,
        zapcore.InfoLevel,
    )
}
```

### ğŸ’¾ æ—¥å¿—è½®è½¬

```go
// pkg/log/rotation.go

// RotationConfig æ—¥å¿—è½®è½¬é…ç½®
type RotationConfig struct {
    MaxSize    int  // å•ä¸ªæ—¥å¿—æ–‡ä»¶æœ€å¤§å¤§å°ï¼ˆMBï¼‰
    MaxBackups int  // ä¿ç•™çš„æ—§æ—¥å¿—æ–‡ä»¶æœ€å¤§æ•°é‡
    MaxAge     int  // ä¿ç•™æ—§æ—¥å¿—æ–‡ä»¶çš„æœ€å¤§å¤©æ•°
    Compress   bool // æ˜¯å¦å‹ç¼©æ—§æ—¥å¿—æ–‡ä»¶
}

// NewRotationLogger åˆ›å»ºæ”¯æŒè½®è½¬çš„æ—¥å¿—å™¨
func NewRotationLogger(filename string, config RotationConfig) zapcore.WriteSyncer {
    lumberJackLogger := &lumberjack.Logger{
        Filename:   filename,
        MaxSize:    config.MaxSize,
        MaxBackups: config.MaxBackups,
        MaxAge:     config.MaxAge,
        Compress:   config.Compress,
    }
    
    return zapcore.AddSync(lumberJackLogger)
}
```

## ğŸ¯ æœ€ä½³å®è·µæ€»ç»“

### âœ… æ€§èƒ½æœ€ä½³å®è·µ

1. **ä½¿ç”¨ç»“æ„åŒ–å­—æ®µ**: é¿å…å­—ç¬¦ä¸²æ ¼å¼åŒ–
2. **æ¡ä»¶æ—¥å¿—**: ä½¿ç”¨V()æ–¹æ³•è¿›è¡Œæ¡ä»¶åˆ¤æ–­
3. **é€‚å½“çš„æ—¥å¿—çº§åˆ«**: ç”Ÿäº§ç¯å¢ƒä½¿ç”¨Infoçº§åˆ«
4. **æ‰¹é‡å†™å…¥**: é…ç½®åˆé€‚çš„ç¼“å†²åŒºå¤§å°

### ğŸ”§ ä½¿ç”¨æœ€ä½³å®è·µ

1. **ä¸Šä¸‹æ–‡ä¼ é€’**: å§‹ç»ˆä½¿ç”¨ä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„æ—¥å¿—
2. **é”™è¯¯è®°å½•**: é”™è¯¯æ—¥å¿—åŒ…å«å®Œæ•´çš„å †æ ˆä¿¡æ¯
3. **æ•æ„Ÿä¿¡æ¯**: é¿å…è®°å½•å¯†ç ç­‰æ•æ„Ÿä¿¡æ¯
4. **ä¸€è‡´æ€§**: ä½¿ç”¨ç»Ÿä¸€çš„å­—æ®µå‘½åè§„èŒƒ

### ğŸ“Š ç›‘æ§æœ€ä½³å®è·µ

1. **æ—¥å¿—èšåˆ**: ä½¿ç”¨ELKæˆ–ç±»ä¼¼å·¥å…·èšåˆæ—¥å¿—
2. **å‘Šè­¦è®¾ç½®**: å¯¹ERRORçº§åˆ«æ—¥å¿—è®¾ç½®å‘Šè­¦
3. **æ€§èƒ½ç›‘æ§**: ç›‘æ§æ—¥å¿—ç³»ç»Ÿçš„æ€§èƒ½å½±å“
4. **å­˜å‚¨ç®¡ç†**: åˆç†é…ç½®æ—¥å¿—è½®è½¬å’Œæ¸…ç†ç­–ç•¥

è¿™ç§åŸºäºZapçš„é«˜æ€§èƒ½æ—¥å¿—ç³»ç»Ÿä¸ºåº”ç”¨æä¾›äº†å¼ºå¤§çš„å¯è§‚æµ‹æ€§åŸºç¡€ã€‚ 