# ğŸ” è®¤è¯æ¨¡å—è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [è®¤è¯ç­–ç•¥ä½“ç³»](#authentication-strategies)
- [JWTè®¤è¯å®ç°](#jwt-authentication)
- [Basicè®¤è¯å®ç°](#basic-authentication)
- [è®¤è¯ä¸­é—´ä»¶è®¾è®¡](#authentication-middleware)
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#practical-cases)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æœ¬é¡¹ç›®çš„è®¤è¯æ¨¡å—åŸºäº**ç­–ç•¥æ¨¡å¼**æ„å»ºäº†çµæ´»çš„è®¤è¯ä½“ç³»ï¼Œæ”¯æŒ**å¤šç§è®¤è¯æ–¹å¼**ï¼Œå®ç°äº†**æ— çŠ¶æ€è®¤è¯**ã€**è‡ªåŠ¨è®¤è¯é€‰æ‹©**å’Œ**ç»†ç²’åº¦æƒé™æ§åˆ¶**çš„ä¼ä¸šçº§è®¤è¯æœºåˆ¶ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **å¤šç­–ç•¥æ”¯æŒ**: æ”¯æŒJWTã€Basicç­‰å¤šç§è®¤è¯æ–¹å¼
2. **æ— çŠ¶æ€è®¤è¯**: JWT tokenå®ç°æ— çŠ¶æ€ä¼šè¯ç®¡ç†
3. **è‡ªåŠ¨é€‰æ‹©**: æ ¹æ®è¯·æ±‚å¤´è‡ªåŠ¨é€‰æ‹©è®¤è¯ç­–ç•¥
4. **å®‰å…¨å¯é **: å®Œå–„çš„tokenéªŒè¯å’ŒåŠ å¯†æœºåˆ¶
5. **æ˜“äºæ‰©å±•**: ç­–ç•¥æ¨¡å¼æ”¯æŒæ–°è®¤è¯æ–¹å¼çš„å¿«é€Ÿæ¥å…¥

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

- **ç­–ç•¥æ¨¡å¼**: ä¸åŒè®¤è¯æ–¹å¼é‡‡ç”¨ç‹¬ç«‹ç­–ç•¥å®ç°
- **èŒè´£åˆ†ç¦»**: è®¤è¯ä¸æˆæƒé€»è¾‘åˆ†ç¦»
- **å®‰å…¨ä¼˜å…ˆ**: é»˜è®¤æ‹’ç»ï¼Œæ˜ç¡®æˆæƒ
- **å‘åå…¼å®¹**: æ”¯æŒä¼ ç»ŸBasicè®¤è¯æ–¹å¼

## ğŸ›ï¸ è®¤è¯ç­–ç•¥ä½“ç³» {#authentication-strategies}

### ğŸ“¦ è®¤è¯ç­–ç•¥æ¥å£

```go
// internal/pkg/middleware/auth/auth.go

// Strategy è®¤è¯ç­–ç•¥æ¥å£
type Strategy interface {
    // AuthFunc è®¤è¯å‡½æ•°ï¼Œè¿”å›è®¤è¯å¤„ç†å™¨
    AuthFunc() gin.HandlerFunc
}

// AuthzAudience è®¤è¯æˆæƒå—ä¼—ä¿¡æ¯
type AuthzAudience struct {
    Aud string `json:"aud"`
    Iss string `json:"iss"`
}

// è®¤è¯ç­–ç•¥ç®¡ç†å™¨
type authStrategy struct {
    basic AuthStrategy // Basicè®¤è¯ç­–ç•¥
    jwt   AuthStrategy // JWTè®¤è¯ç­–ç•¥
}

// AuthStrategy è®¤è¯ç­–ç•¥åŸºç¡€æ¥å£
type AuthStrategy interface {
    AuthFunc() gin.HandlerFunc
}
```

### ğŸ”§ è‡ªåŠ¨è®¤è¯ç­–ç•¥

```go
// auto.go - è‡ªåŠ¨è®¤è¯ç­–ç•¥å®ç°

// AutoStrategy è‡ªåŠ¨è®¤è¯ç­–ç•¥
type AutoStrategy struct {
    basic Strategy
    jwt   Strategy
}

// NewAutoStrategy åˆ›å»ºè‡ªåŠ¨è®¤è¯ç­–ç•¥
func NewAutoStrategy(basic, jwt Strategy) AutoStrategy {
    return AutoStrategy{
        basic: basic,
        jwt:   jwt,
    }
}

// AuthFunc è‡ªåŠ¨é€‰æ‹©è®¤è¯ç­–ç•¥
func (a AutoStrategy) AuthFunc() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        // è·å–Authorizationå¤´
        authHeader := strings.SplitN(c.Request.Header.Get("Authorization"), " ", 2)

        if len(authHeader) != 2 {
            // æ²¡æœ‰è®¤è¯å¤´ï¼Œè¿”å›æœªæˆæƒ
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrMissingHeader, "Authorization header required"),
                nil,
            )
            c.Abort()
            return
        }

        // æ ¹æ®è®¤è¯ç±»å‹é€‰æ‹©ç­–ç•¥
        switch authHeader[0] {
        case "Basic":
            // ä½¿ç”¨Basicè®¤è¯
            a.basic.AuthFunc()(c)
        case "Bearer":
            // ä½¿ç”¨JWTè®¤è¯
            a.jwt.AuthFunc()(c)
        default:
            // ä¸æ”¯æŒçš„è®¤è¯ç±»å‹
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrSignatureInvalid, "Unsupported authorization type"),
                nil,
            )
            c.Abort()
            return
        }
    })
}
```

### ğŸ¯ è®¤è¯ç­–ç•¥å·¥å‚

```go
// è®¤è¯ç­–ç•¥å·¥å‚
func NewAuthStrategy(authType string) (Strategy, error) {
    switch authType {
    case "basic":
        return NewBasicStrategy(), nil
    case "jwt":
        return NewJWTStrategy(), nil
    case "auto":
        basic := NewBasicStrategy()
        jwt := NewJWTStrategy()
        return NewAutoStrategy(basic, jwt), nil
    default:
        return nil, fmt.Errorf("unsupported auth type: %s", authType)
    }
}
```

## ğŸ”‘ JWTè®¤è¯å®ç° {#jwt-authentication}

### ğŸ“Š JWT Tokenç»“æ„

```go
// pkg/auth/auth.go

// JWTInfo JWT Tokenä¿¡æ¯
type JWTInfo struct {
    UserID   string `json:"userID"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

// Claims JWTå£°æ˜
type Claims struct {
    UserID   string `json:"userID"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}
```

### ğŸ”§ JWTå·¥å…·å‡½æ•°

```go
// JWTå¯†é’¥é…ç½®
var (
    secretKey = []byte("your-secret-key") // å®é™…ä½¿ç”¨æ—¶ä»é…ç½®è¯»å–
)

// Sign ç”ŸæˆJWT token
func Sign(userID, username string, expire time.Duration) (string, error) {
    // è®¾ç½®è¿‡æœŸæ—¶é—´
    now := time.Now()
    expirationTime := now.Add(expire)

    // åˆ›å»ºå£°æ˜
    claims := &Claims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(expirationTime),
            IssuedAt:  jwt.NewNumericDate(now),
            NotBefore: jwt.NewNumericDate(now),
            Issuer:    "questionnaire-scale",
            Subject:   userID,
            ID:        uuid.New().String(),
            Audience:  []string{"api-server"},
        },
    }

    // åˆ›å»ºtoken
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

    // ä½¿ç”¨å¯†é’¥ç­¾å
    tokenString, err := token.SignedString(secretKey)
    if err != nil {
        return "", errors.WithStack(err)
    }

    return tokenString, nil
}

// Verify éªŒè¯JWT token
func Verify(tokenString string) (*Claims, error) {
    // è§£ætoken
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // éªŒè¯ç­¾åæ–¹æ³•
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return secretKey, nil
    })

    if err != nil {
        return nil, errors.WithStack(err)
    }

    // éªŒè¯tokenæœ‰æ•ˆæ€§
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, errors.New("invalid token")
}

// Refresh åˆ·æ–°JWT token
func Refresh(tokenString string, expire time.Duration) (string, error) {
    // éªŒè¯æ—§token
    claims, err := Verify(tokenString)
    if err != nil {
        return "", errors.WithMessage(err, "failed to verify old token")
    }

    // ç”Ÿæˆæ–°token
    return Sign(claims.UserID, claims.Username, expire)
}
```

### ğŸ›¡ï¸ JWTè®¤è¯ç­–ç•¥

```go
// internal/pkg/middleware/auth/strategys/jwt.go

// JWTStrategy JWTè®¤è¯ç­–ç•¥
type JWTStrategy struct{}

// NewJWTStrategy åˆ›å»ºJWTè®¤è¯ç­–ç•¥
func NewJWTStrategy() JWTStrategy {
    return JWTStrategy{}
}

// AuthFunc JWTè®¤è¯å¤„ç†
func (j JWTStrategy) AuthFunc() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        var token string

        // ä»Authorizationå¤´è·å–token
        authHeader := c.Request.Header.Get("Authorization")
        if authHeader != "" {
            // Bearer tokenæ ¼å¼
            fields := strings.SplitN(authHeader, " ", 2)
            if len(fields) == 2 && fields[0] == "Bearer" {
                token = fields[1]
            }
        }

        // ä»æŸ¥è¯¢å‚æ•°è·å–token (ç”¨äºWebSocketç­‰åœºæ™¯)
        if token == "" {
            token = c.Query("token")
        }

        // tokenä¸ºç©ºï¼Œè¿”å›æœªæˆæƒ
        if token == "" {
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrTokenInvalid, "Token required"),
                nil,
            )
            c.Abort()
            return
        }

        // éªŒè¯token
        claims, err := auth.Verify(token)
        if err != nil {
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrTokenInvalid, "Invalid token: %v", err),
                nil,
            )
            c.Abort()
            return
        }

        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°ä¸Šä¸‹æ–‡
        c.Set("UserID", claims.UserID)
        c.Set("Username", claims.Username)

        c.Next()
    })
}
```

## ğŸ” Basicè®¤è¯å®ç° {#basic-authentication}

### ğŸ“Š Basicè®¤è¯ç­–ç•¥

```go
// internal/pkg/middleware/auth/strategys/basic.go

// BasicStrategy Basicè®¤è¯ç­–ç•¥
type BasicStrategy struct {
    compare func(username, password string) bool
}

// NewBasicStrategy åˆ›å»ºBasicè®¤è¯ç­–ç•¥
func NewBasicStrategy() BasicStrategy {
    return BasicStrategy{
        compare: func(username, password string) bool {
            // ä»æ•°æ®åº“æˆ–ç¼“å­˜éªŒè¯ç”¨æˆ·åå¯†ç 
            return validateUserCredentials(username, password)
        },
    }
}

// AuthFunc Basicè®¤è¯å¤„ç†
func (b BasicStrategy) AuthFunc() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        // è·å–Authorizationå¤´
        auth := strings.SplitN(c.Request.Header.Get("Authorization"), " ", 2)

        if len(auth) != 2 || auth[0] != "Basic" {
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrInvalidAuthHeader, "Invalid authorization header"),
                nil,
            )
            c.Abort()
            return
        }

        // Base64è§£ç 
        payload, err := base64.StdEncoding.DecodeString(auth[1])
        if err != nil {
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrInvalidAuthHeader, "Invalid base64 encoding"),
                nil,
            )
            c.Abort()
            return
        }

        // åˆ†å‰²ç”¨æˆ·åå’Œå¯†ç 
        pair := strings.SplitN(string(payload), ":", 2)
        if len(pair) != 2 {
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrInvalidAuthHeader, "Invalid credential format"),
                nil,
            )
            c.Abort()
            return
        }

        username, password := pair[0], pair[1]

        // éªŒè¯ç”¨æˆ·åå¯†ç 
        if !b.compare(username, password) {
            core.WriteResponse(
                c,
                errors.WithCode(code.ErrPasswordIncorrect, "Invalid username or password"),
                nil,
            )
            c.Abort()
            return
        }

        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°ä¸Šä¸‹æ–‡
        c.Set("Username", username)

        c.Next()
    })
}

// validateUserCredentials éªŒè¯ç”¨æˆ·å‡­æ®
func validateUserCredentials(username, password string) bool {
    // å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šæŸ¥è¯¢æ•°æ®åº“éªŒè¯ç”¨æˆ·åå¯†ç 
    // è¿™é‡Œç®€åŒ–ä¸ºç¡¬ç¼–ç éªŒè¯
    users := map[string]string{
        "admin": "admin123",
        "test":  "test123",
    }

    if expectedPassword, exists := users[username]; exists {
        // åœ¨å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨å“ˆå¸Œæ¯”è¾ƒ
        return auth.CompareHashAndPassword(expectedPassword, password)
    }

    return false
}
```

### ğŸ”§ å¯†ç åŠ å¯†å·¥å…·

```go
// pkg/auth/auth.go

// Encrypt åŠ å¯†å¯†ç 
func Encrypt(source string) (string, error) {
    hashedBytes, err := bcrypt.GenerateFromPassword([]byte(source), bcrypt.DefaultCost)
    if err != nil {
        return "", errors.WithStack(err)
    }
    return string(hashedBytes), nil
}

// CompareHashAndPassword æ¯”è¾ƒå¯†ç å“ˆå¸Œ
func CompareHashAndPassword(hashedPassword, password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
    return err == nil
}
```

## ğŸ”’ è®¤è¯ä¸­é—´ä»¶è®¾è®¡ {#authentication-middleware}

### ğŸ“Š è®¤è¯ä¸­é—´ä»¶æ¶æ„

```mermaid
graph TB
    subgraph "HTTP Request"
        REQ[HTTP Request]
        AUTH_HEADER[Authorization Header]
    end
    
    subgraph "è®¤è¯ä¸­é—´ä»¶å±‚"
        AUTH_MW[Auth Middleware]
        AUTO_STRATEGY[Auto Strategy]
        BASIC_STRATEGY[Basic Strategy]
        JWT_STRATEGY[JWT Strategy]
    end
    
    subgraph "è®¤è¯å¤„ç†å±‚"
        BASIC_AUTH[Basic Auth<br/>ç”¨æˆ·åå¯†ç éªŒè¯]
        JWT_AUTH[JWT Auth<br/>TokenéªŒè¯]
        USER_CTX[ç”¨æˆ·ä¸Šä¸‹æ–‡<br/>è®¾ç½®]
    end
    
    subgraph "ä¸šåŠ¡å¤„ç†å±‚"
        HANDLER[Business Handler]
        USER_INFO[ç”¨æˆ·ä¿¡æ¯è·å–]
    end
    
    REQ --> AUTH_MW
    AUTH_HEADER --> AUTO_STRATEGY
    AUTO_STRATEGY --> BASIC_STRATEGY
    AUTO_STRATEGY --> JWT_STRATEGY
    BASIC_STRATEGY --> BASIC_AUTH
    JWT_STRATEGY --> JWT_AUTH
    BASIC_AUTH --> USER_CTX
    JWT_AUTH --> USER_CTX
    USER_CTX --> HANDLER
    HANDLER --> USER_INFO
```

### ğŸ”§ è®¤è¯ä¸­é—´ä»¶å®ç°

```go
// internal/pkg/middleware/auth/auth.go

// Auther è®¤è¯ä¸­é—´ä»¶æ¥å£
type Auther interface {
    AuthFunc() gin.HandlerFunc
}

// authStrategy è®¤è¯ç­–ç•¥ç®¡ç†
type authStrategy struct {
    basic AuthStrategy
    jwt   AuthStrategy
}

// AuthStrategy è®¤è¯ç­–ç•¥æ¥å£
type AuthStrategy interface {
    AuthFunc() gin.HandlerFunc
}

// NewAuth åˆ›å»ºè®¤è¯ä¸­é—´ä»¶
func NewAuth(authType string) gin.HandlerFunc {
    var strategy Strategy

    switch authType {
    case "basic":
        strategy = NewBasicStrategy()
    case "jwt":
        strategy = NewJWTStrategy()
    case "auto":
        strategy = NewAutoStrategy(NewBasicStrategy(), NewJWTStrategy())
    default:
        // é»˜è®¤ä½¿ç”¨è‡ªåŠ¨ç­–ç•¥
        strategy = NewAutoStrategy(NewBasicStrategy(), NewJWTStrategy())
    }

    return strategy.AuthFunc()
}

// AuthFunc è·å–è®¤è¯å¤„ç†å‡½æ•°
func (a authStrategy) AuthFunc() gin.HandlerFunc {
    return NewAuth("auto")
}
```

### ğŸ¯ è®¤è¯ä¸­é—´ä»¶ä½¿ç”¨

```go
// internal/apiserver/routers.go

// InstallAPIServer å®‰è£…APIè·¯ç”±
func InstallAPIServer(g *gin.Engine, options *options.Options) {
    // åˆ›å»ºè®¤è¯ä¸­é—´ä»¶
    authMiddleware := auth.NewAuth("auto")

    // APIè·¯ç”±ç»„
    v1 := g.Group("/v1")
    
    // éœ€è¦è®¤è¯çš„è·¯ç”±
    authGroup := v1.Group("").Use(authMiddleware)
    {
        // ç”¨æˆ·ç›¸å…³è·¯ç”±
        userHandler := handler.NewUserHandler()
        authGroup.POST("/users", userHandler.CreateUser)
        authGroup.GET("/users/:id", userHandler.GetUser)
        authGroup.PUT("/users/:id", userHandler.UpdateUser)
        authGroup.DELETE("/users/:id", userHandler.DeleteUser)
        
        // é—®å·ç›¸å…³è·¯ç”±
        questionnaireHandler := handler.NewQuestionnaireHandler()
        authGroup.POST("/questionnaires", questionnaireHandler.Create)
        authGroup.GET("/questionnaires/:id", questionnaireHandler.Get)
        authGroup.PUT("/questionnaires/:id", questionnaireHandler.Update)
        authGroup.DELETE("/questionnaires/:id", questionnaireHandler.Delete)
    }

    // ä¸éœ€è¦è®¤è¯çš„è·¯ç”±
    publicGroup := v1.Group("")
    {
        // ç”¨æˆ·ç™»å½•
        publicGroup.POST("/login", userHandler.Login)
        // å¥åº·æ£€æŸ¥
        publicGroup.GET("/health", handler.HealthCheck)
    }
}
```

### ğŸ”§ ç”¨æˆ·ä¸Šä¸‹æ–‡å·¥å…·

```go
// internal/pkg/middleware/context.go

// ç”¨æˆ·ä¸Šä¸‹æ–‡é”®
const (
    UserIDKey   = "UserID"
    UsernameKey = "Username"
)

// GetUserID ä»ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·ID
func GetUserID(c *gin.Context) string {
    if userID, exists := c.Get(UserIDKey); exists {
        if id, ok := userID.(string); ok {
            return id
        }
    }
    return ""
}

// GetUsername ä»ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·å
func GetUsername(c *gin.Context) string {
    if username, exists := c.Get(UsernameKey); exists {
        if name, ok := username.(string); ok {
            return name
        }
    }
    return ""
}

// MustGetUserID ä»ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·IDï¼ˆå¿…é¡»å­˜åœ¨ï¼‰
func MustGetUserID(c *gin.Context) string {
    userID := GetUserID(c)
    if userID == "" {
        panic("user id not found in context")
    }
    return userID
}

// SetUserContext è®¾ç½®ç”¨æˆ·ä¸Šä¸‹æ–‡
func SetUserContext(c *gin.Context, userID, username string) {
    c.Set(UserIDKey, userID)
    c.Set(UsernameKey, username)
}
```

## ğŸ“š å®é™…åº”ç”¨æ¡ˆä¾‹ {#practical-cases}

### ğŸ¯ ç”¨æˆ·ç™»å½•è®¤è¯æµç¨‹

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant Handler as Login Handler
    participant Service as User Service
    participant Auth as Auth Module
    participant DB as æ•°æ®åº“
    
    Client->>Handler: POST /login
    Handler->>Service: ValidateCredentials()
    Service->>DB: FindUserByUsername()
    DB-->>Service: User Info
    Service->>Auth: ComparePassword()
    Auth-->>Service: Password Valid
    Service->>Auth: Sign JWT Token
    Auth-->>Service: JWT Token
    Service-->>Handler: Login Success + Token
    Handler-->>Client: 200 OK + Token
    
    Note over Client: åç»­è¯·æ±‚æºå¸¦Bearer Token
    Client->>Handler: GET /users/me (Bearer Token)
    Handler->>Auth: Verify Token
    Auth-->>Handler: User Claims
    Handler-->>Client: User Info
```

### ğŸ’¡ å®Œæ•´ç™»å½•å®ç°

```go
// internal/apiserver/interface/restful/handler/user.go

// LoginRequest ç™»å½•è¯·æ±‚
type LoginRequest struct {
    Username string `json:"username" binding:"required"`
    Password string `json:"password" binding:"required"`
}

// LoginResponse ç™»å½•å“åº”
type LoginResponse struct {
    Token     string    `json:"token"`
    ExpiresAt time.Time `json:"expires_at"`
    User      UserInfo  `json:"user"`
}

// Login ç”¨æˆ·ç™»å½•
func (h *UserHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := h.BindJSON(c, &req); err != nil {
        h.ErrorResponse(c, errors.WithCode(code.ErrBind, err.Error()))
        return
    }

    // éªŒè¯ç”¨æˆ·å‡­æ®
    user, err := h.userService.ValidateCredentials(c, req.Username, req.Password)
    if err != nil {
        h.ErrorResponse(c, err)
        return
    }

    // ç”ŸæˆJWT token
    expire := 24 * time.Hour // 24å°æ—¶è¿‡æœŸ
    token, err := auth.Sign(user.ID, user.Username, expire)
    if err != nil {
        h.ErrorResponse(c, errors.WithCode(code.ErrSignatureInvalid, 
            "Failed to generate token"))
        return
    }

    // æˆåŠŸå“åº”
    response := LoginResponse{
        Token:     token,
        ExpiresAt: time.Now().Add(expire),
        User:      toUserInfo(user),
    }

    h.SuccessResponse(c, response)
}

// GetCurrentUser è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
func (h *UserHandler) GetCurrentUser(c *gin.Context) {
    // ä»è®¤è¯ä¸­é—´ä»¶è®¾ç½®çš„ä¸Šä¸‹æ–‡è·å–ç”¨æˆ·ID
    userID := middleware.GetUserID(c)
    if userID == "" {
        h.ErrorResponse(c, errors.WithCode(code.ErrTokenInvalid, "User not authenticated"))
        return
    }

    // æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
    user, err := h.userService.GetUserByID(c, userID)
    if err != nil {
        h.ErrorResponse(c, err)
        return
    }

    h.SuccessResponse(c, toUserInfo(user))
}
```

### ğŸ”§ ç”¨æˆ·æœåŠ¡è®¤è¯å®ç°

```go
// internal/apiserver/application/user/authenticator.go

// UserAuthenticator ç”¨æˆ·è®¤è¯å™¨
type UserAuthenticator struct {
    userRepo port.UserRepository
}

// NewUserAuthenticator åˆ›å»ºç”¨æˆ·è®¤è¯å™¨
func NewUserAuthenticator(userRepo port.UserRepository) *UserAuthenticator {
    return &UserAuthenticator{
        userRepo: userRepo,
    }
}

// ValidateCredentials éªŒè¯ç”¨æˆ·å‡­æ®
func (a *UserAuthenticator) ValidateCredentials(ctx context.Context, username, password string) (*user.User, error) {
    // æ ¹æ®ç”¨æˆ·åæŸ¥æ‰¾ç”¨æˆ·
    userObj, err := a.userRepo.FindByUsername(ctx, username)
    if err != nil {
        if errors.IsCode(err, code.ErrUserNotFound) {
            return nil, errors.WithCode(code.ErrPasswordIncorrect, "Invalid username or password")
        }
        return nil, err
    }

    // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    if userObj.Status() == user.StatusBlocked {
        return nil, errors.WithCode(code.ErrUserBlocked, "User is blocked")
    }

    if userObj.Status() == user.StatusInactive {
        return nil, errors.WithCode(code.ErrUserInactive, "User is inactive")
    }

    // éªŒè¯å¯†ç 
    if !auth.CompareHashAndPassword(userObj.Password(), password) {
        return nil, errors.WithCode(code.ErrPasswordIncorrect, "Invalid username or password")
    }

    return userObj, nil
}
```

### ğŸ¯ Tokenåˆ·æ–°æœºåˆ¶

```go
// RefreshTokenRequest Tokenåˆ·æ–°è¯·æ±‚
type RefreshTokenRequest struct {
    Token string `json:"token" binding:"required"`
}

// RefreshToken åˆ·æ–°Token
func (h *UserHandler) RefreshToken(c *gin.Context) {
    var req RefreshTokenRequest
    if err := h.BindJSON(c, &req); err != nil {
        h.ErrorResponse(c, errors.WithCode(code.ErrBind, err.Error()))
        return
    }

    // åˆ·æ–°token
    expire := 24 * time.Hour
    newToken, err := auth.Refresh(req.Token, expire)
    if err != nil {
        h.ErrorResponse(c, errors.WithCode(code.ErrTokenInvalid, 
            "Failed to refresh token: %v", err))
        return
    }

    // è¿”å›æ–°token
    response := LoginResponse{
        Token:     newToken,
        ExpiresAt: time.Now().Add(expire),
    }

    h.SuccessResponse(c, response)
}
```

### ğŸ” æƒé™æ§åˆ¶æ‰©å±•

```go
// åŸºäºè§’è‰²çš„æƒé™æ§åˆ¶ä¸­é—´ä»¶
func RequireRole(roles ...string) gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        userID := middleware.GetUserID(c)
        if userID == "" {
            core.WriteResponse(c, errors.WithCode(code.ErrTokenInvalid, "Authentication required"), nil)
            c.Abort()
            return
        }

        // è·å–ç”¨æˆ·è§’è‰²ï¼ˆä»æ•°æ®åº“æˆ–ç¼“å­˜ï¼‰
        userRoles, err := getUserRoles(userID)
        if err != nil {
            core.WriteResponse(c, errors.WithStack(err), nil)
            c.Abort()
            return
        }

        // æ£€æŸ¥æƒé™
        if !hasAnyRole(userRoles, roles) {
            core.WriteResponse(c, errors.WithCode(code.ErrPermissionDenied, "Insufficient permissions"), nil)
            c.Abort()
            return
        }

        c.Next()
    })
}

// ä½¿ç”¨ç¤ºä¾‹
func setupAdminRoutes(g *gin.RouterGroup) {
    // éœ€è¦ç®¡ç†å‘˜æƒé™çš„è·¯ç”±
    adminGroup := g.Group("").Use(RequireRole("admin", "super_admin"))
    {
        adminGroup.DELETE("/users/:id", userHandler.DeleteUser)
        adminGroup.POST("/users/:id/block", userHandler.BlockUser)
    }
}
```

## ğŸ¯ æœ€ä½³å®practicesæ€»ç»“

### âœ… è®¤è¯è®¾è®¡æœ€ä½³å®è·µ

1. **å¤šç­–ç•¥æ”¯æŒ**: åŒæ—¶æ”¯æŒå¤šç§è®¤è¯æ–¹å¼ä»¥é€‚åº”ä¸åŒåœºæ™¯
2. **è‡ªåŠ¨é€‰æ‹©**: æ ¹æ®è¯·æ±‚å¤´è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„è®¤è¯ç­–ç•¥
3. **æ— çŠ¶æ€è®¾è®¡**: ä½¿ç”¨JWTå®ç°æ— çŠ¶æ€è®¤è¯ï¼Œæé«˜æ‰©å±•æ€§
4. **å®‰å…¨å­˜å‚¨**: æ•æ„Ÿä¿¡æ¯å¦‚å¯†é’¥åº”ä»é…ç½®æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡è¯»å–

### ğŸ”§ Tokenç®¡ç†æœ€ä½³å®è·µ

1. **åˆç†è¿‡æœŸ**: è®¾ç½®åˆç†çš„tokenè¿‡æœŸæ—¶é—´ï¼Œå¹³è¡¡å®‰å…¨æ€§å’Œç”¨æˆ·ä½“éªŒ
2. **åˆ·æ–°æœºåˆ¶**: æä¾›tokenåˆ·æ–°æ¥å£ï¼Œé¿å…é¢‘ç¹ç™»å½•
3. **æ’¤é”€æ”¯æŒ**: æ”¯æŒtokenä¸»åŠ¨æ’¤é”€ï¼ˆå¯ç»“åˆRediså®ç°é»‘åå•ï¼‰
4. **å®‰å…¨ä¼ è¾“**: ä½¿ç”¨HTTPSç¡®ä¿tokenä¼ è¾“å®‰å…¨

### ğŸ“Š é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

1. **ç»Ÿä¸€é”™è¯¯ç **: ä½¿ç”¨ç»Ÿä¸€çš„è®¤è¯é”™è¯¯ç ä½“ç³»
2. **å®‰å…¨é”™è¯¯ä¿¡æ¯**: é¿å…åœ¨é”™è¯¯ä¿¡æ¯ä¸­æ³„éœ²æ•æ„Ÿä¿¡æ¯
3. **æ—¥å¿—è®°å½•**: è®°å½•è®¤è¯å¤±è´¥äº‹ä»¶ç”¨äºå®‰å…¨å®¡è®¡
4. **é™æµä¿æŠ¤**: å¯¹è®¤è¯æ¥å£å®æ–½è®¿é—®é™æµé˜²æ­¢æš´åŠ›ç ´è§£

### ğŸ” æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

1. **ç¼“å­˜ç”¨æˆ·ä¿¡æ¯**: ç¼“å­˜ç”¨æˆ·åŸºæœ¬ä¿¡æ¯å‡å°‘æ•°æ®åº“æŸ¥è¯¢
2. **å¯†ç å“ˆå¸Œ**: ä½¿ç”¨é€‚å½“çš„å“ˆå¸Œç®—æ³•å’Œå·¥ä½œå› å­
3. **è¿æ¥å¤ç”¨**: å¤ç”¨æ•°æ®åº“è¿æ¥å‡å°‘è¿æ¥å¼€é”€
4. **å¼‚æ­¥æ—¥å¿—**: ä½¿ç”¨å¼‚æ­¥æ—¥å¿—è®°å½•é¿å…å½±å“å“åº”æ—¶é—´

è¿™ç§å®Œæ•´çš„è®¤è¯ä½“ç³»ä¸ºåº”ç”¨æä¾›äº†å®‰å…¨å¯é ã€çµæ´»æ‰©å±•çš„è®¤è¯æœºåˆ¶ï¼Œæ»¡è¶³ä¼ä¸šçº§åº”ç”¨çš„å®‰å…¨è¦æ±‚ã€‚