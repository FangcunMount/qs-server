# âš ï¸ é”™è¯¯å¤„ç†æ¨¡å—è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [é”™è¯¯ç±»å‹ä½“ç³»](#error-type-system)
- [é”™è¯¯ç ç®¡ç†](#error-code-management)
- [å †æ ˆè·Ÿè¸ªæœºåˆ¶](#stack-trace-mechanism)
- [é”™è¯¯ä¼ æ’­ç­–ç•¥](#error-propagation)
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#practical-cases)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æœ¬é¡¹ç›®çš„é”™è¯¯å¤„ç†æ¨¡å—åŸºäº **pkg/errors** æ„å»ºäº†å®Œæ•´çš„é”™è¯¯å¤„ç†ä½“ç³»ï¼Œé‡‡ç”¨**åˆ†å±‚é”™è¯¯å¤„ç†**å’Œ**é”™è¯¯ç æ ‡å‡†åŒ–**è®¾è®¡ï¼Œå®ç°äº†**å †æ ˆè·Ÿè¸ª**ã€**é”™è¯¯èšåˆ**å’Œ**ä¸Šä¸‹æ–‡ä¿ç•™**çš„ä¼ä¸šçº§é”™è¯¯å¤„ç†æœºåˆ¶ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **å®Œæ•´è¿½è¸ª**: æä¾›å®Œæ•´çš„é”™è¯¯å †æ ˆä¿¡æ¯
2. **åˆ†å±‚å¤„ç†**: ä¸åŒå±‚æ¬¡çš„é”™è¯¯å¤„ç†ç­–ç•¥
3. **æ ‡å‡†åŒ–**: ç»Ÿä¸€çš„é”™è¯¯ç å’Œé”™è¯¯æ ¼å¼
4. **ä¸Šä¸‹æ–‡ä¿ç•™**: ä¿ç•™é”™è¯¯å‘ç”Ÿçš„å®Œæ•´ä¸Šä¸‹æ–‡
5. **ç”¨æˆ·å‹å¥½**: å¯¹å¤–æä¾›å‹å¥½çš„é”™è¯¯ä¿¡æ¯

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

- **é”™è¯¯å³å€¼**: å°†é”™è¯¯ä½œä¸ºè¿”å›å€¼æ˜ç¡®å¤„ç†
- **å¿«é€Ÿå¤±è´¥**: é‡åˆ°é”™è¯¯ç«‹å³è¿”å›ï¼Œä¸éšè—é”™è¯¯
- **ä¸Šä¸‹æ–‡ä¸°å¯Œ**: ä¸ºé”™è¯¯æ·»åŠ æœ‰ç”¨çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
- **åˆ†å±‚è´£ä»»**: ä¸åŒå±‚æ¬¡è´Ÿè´£ä¸åŒçš„é”™è¯¯å¤„ç†

## ğŸ›ï¸ é”™è¯¯ç±»å‹ä½“ç³» {#error-type-system}

### ğŸ“¦ åŸºç¡€é”™è¯¯æ¥å£

```go
// pkg/errors/errors.go

// æ ‡å‡†é”™è¯¯æ¥å£æ‰©å±•
type Error interface {
    error
    Cause() error           // è·å–æ ¹æœ¬åŸå› 
    Format(s fmt.State, verb rune) // æ ¼å¼åŒ–è¾“å‡º
}

// å †æ ˆè·Ÿè¸ªæ¥å£
type StackTracer interface {
    StackTrace() StackTrace
}

// é”™è¯¯åŸå› æ¥å£
type Causer interface {
    Cause() error
}
```

### ğŸ”§ æ ¸å¿ƒé”™è¯¯ç±»å‹

#### 1. **åŸºç¡€é”™è¯¯ (fundamental)**

```go
// fundamental åŸºç¡€é”™è¯¯ç±»å‹
type fundamental struct {
    msg string    // é”™è¯¯æ¶ˆæ¯
    *stack       // å †æ ˆä¿¡æ¯
}

// New åˆ›å»ºæ–°çš„åŸºç¡€é”™è¯¯
func New(message string) error {
    return &fundamental{
        msg:   message,
        stack: callers(),
    }
}

// Errorf æ ¼å¼åŒ–åˆ›å»ºé”™è¯¯
func Errorf(format string, args ...interface{}) error {
    return &fundamental{
        msg:   fmt.Sprintf(format, args...),
        stack: callers(),
    }
}

// Error å®ç°erroræ¥å£
func (f *fundamental) Error() string { 
    return f.msg 
}

// Format å®ç°æ ¼å¼åŒ–æ¥å£
func (f *fundamental) Format(s fmt.State, verb rune) {
    switch verb {
    case 'v':
        if s.Flag('+') {
            io.WriteString(s, f.msg)
            f.stack.Format(s, verb)
            return
        }
        fallthrough
    case 's':
        io.WriteString(s, f.msg)
    case 'q':
        fmt.Fprintf(s, "%q", f.msg)
    }
}
```

#### 2. **åŒ…è£…é”™è¯¯ (withStack)**

```go
// withStack å¸¦å †æ ˆçš„é”™è¯¯åŒ…è£…
type withStack struct {
    error        // åŸå§‹é”™è¯¯
    *stack      // å †æ ˆä¿¡æ¯
}

// WithStack ä¸ºé”™è¯¯æ·»åŠ å †æ ˆä¿¡æ¯
func WithStack(err error) error {
    if err == nil {
        return nil
    }

    if e, ok := err.(*withCode); ok {
        return &withCode{
            err:   e.err,
            code:  e.code,
            cause: err,
            stack: callers(),
        }
    }

    return &withStack{
        err,
        callers(),
    }
}

// Cause è·å–åŸå§‹é”™è¯¯
func (w *withStack) Cause() error { 
    return w.error 
}

// Unwrap Go 1.13 é”™è¯¯é“¾æ”¯æŒ
func (w *withStack) Unwrap() error {
    if e, ok := w.error.(interface{ Unwrap() error }); ok {
        return e.Unwrap()
    }
    return w.error
}
```

#### 3. **æ¶ˆæ¯é”™è¯¯ (withMessage)**

```go
// withMessage å¸¦æ¶ˆæ¯çš„é”™è¯¯åŒ…è£…
type withMessage struct {
    cause error  // åŸå› é”™è¯¯
    msg   string // é™„åŠ æ¶ˆæ¯
}

// WithMessage ä¸ºé”™è¯¯æ·»åŠ æ¶ˆæ¯
func WithMessage(err error, message string) error {
    if err == nil {
        return nil
    }
    return &withMessage{
        cause: err,
        msg:   message,
    }
}

// WithMessagef æ ¼å¼åŒ–æ·»åŠ æ¶ˆæ¯
func WithMessagef(err error, format string, args ...interface{}) error {
    if err == nil {
        return nil
    }
    return &withMessage{
        cause: err,
        msg:   fmt.Sprintf(format, args...),
    }
}

// Error è¿”å›é”™è¯¯æ¶ˆæ¯
func (w *withMessage) Error() string { 
    return w.msg 
}

// Cause è¿”å›åŸå› é”™è¯¯
func (w *withMessage) Cause() error  { 
    return w.cause 
}

// Unwrap Go 1.13 é”™è¯¯é“¾æ”¯æŒ
func (w *withMessage) Unwrap() error { 
    return w.cause 
}
```

#### 4. **é”™è¯¯ç é”™è¯¯ (withCode)**

```go
// withCode å¸¦é”™è¯¯ç çš„é”™è¯¯
type withCode struct {
    err   error  // é”™è¯¯æ¶ˆæ¯
    code  int    // é”™è¯¯ç 
    cause error  // åŸå› é”™è¯¯
    *stack      // å †æ ˆä¿¡æ¯
}

// WithCode åˆ›å»ºå¸¦é”™è¯¯ç çš„é”™è¯¯
func WithCode(code int, format string, args ...interface{}) error {
    return &withCode{
        err:   fmt.Errorf(format, args...),
        code:  code,
        stack: callers(),
    }
}

// WrapC åŒ…è£…é”™è¯¯å¹¶æ·»åŠ é”™è¯¯ç 
func WrapC(err error, code int, format string, args ...interface{}) error {
    if err == nil {
        return nil
    }

    return &withCode{
        err:   fmt.Errorf(format, args...),
        code:  code,
        cause: err,
        stack: callers(),
    }
}

// Error è¿”å›å¤–éƒ¨å®‰å…¨çš„é”™è¯¯æ¶ˆæ¯
func (w *withCode) Error() string { 
    return fmt.Sprintf("%v", w) 
}

// Cause è¿”å›é”™è¯¯åŸå› 
func (w *withCode) Cause() error { 
    return w.cause 
}

// Unwrap Go 1.13 é”™è¯¯é“¾æ”¯æŒ
func (w *withCode) Unwrap() error { 
    return w.cause 
}
```

### ğŸ” é”™è¯¯åŸå› è¿½è¸ª

```go
// Cause é€’å½’è·å–é”™è¯¯çš„æ ¹æœ¬åŸå› 
func Cause(err error) error {
    type causer interface {
        Cause() error
    }

    for err != nil {
        cause, ok := err.(causer)
        if !ok {
            break
        }

        if cause.Cause() == nil {
            break
        }

        err = cause.Cause()
    }
    return err
}
```

## ğŸ·ï¸ é”™è¯¯ç ç®¡ç† {#error-code-management}

### ğŸ“Š é”™è¯¯ç ä½“ç³»è®¾è®¡

```go
// internal/pkg/code/base.go

// åŸºç¡€é”™è¯¯ç å®šä¹‰
const (
    // æˆåŠŸ
    ErrSuccess int = iota + 100001
    
    // é€šç”¨é”™è¯¯ 100001-100099
    ErrUnknown
    ErrBind
    ErrValidation
    ErrTokenInvalid
    ErrPageNotFound
    ErrInternalServerError
    
    // è®¤è¯æˆæƒé”™è¯¯ 100100-100199  
    ErrEncrypt
    ErrSignatureInvalid
    ErrExpired
    ErrInvalidAuthHeader
    ErrMissingHeader
    ErrPasswordIncorrect
    ErrPermissionDenied
)

// é”™è¯¯ç ä¿¡æ¯æ˜ å°„
var codeText = map[int]string{
    ErrSuccess:                 "OK",
    ErrUnknown:                 "Internal server error",
    ErrBind:                    "Error occurred while binding the request body to the struct",
    ErrValidation:              "Validation failed",
    ErrTokenInvalid:            "Token invalid",
    ErrPageNotFound:            "Page not found",
    ErrInternalServerError:     "Internal server error",
    ErrEncrypt:                 "Error occurred while encrypting the user password",
    ErrSignatureInvalid:        "Signature is invalid", 
    ErrExpired:                 "Token expired",
    ErrInvalidAuthHeader:       "Invalid authorization header",
    ErrMissingHeader:           "The Length of the authorization header is zero",
    ErrPasswordIncorrect:       "Password is incorrect",
    ErrPermissionDenied:        "Permission denied",
}
```

### ğŸ¯ ä¸šåŠ¡æ¨¡å—é”™è¯¯ç 

```go
// internal/pkg/code/apiserver.go

// ç”¨æˆ·æ¨¡å—é”™è¯¯ç  110001-110099
const (
    // ErrUserNotFound - 404: User not found.
    ErrUserNotFound int = iota + 110001

    // ErrUserAlreadyExists- 400: User already exist.
    ErrUserAlreadyExists

    // ErrUserBasicInfoInvalid - 400: User basic info is invalid.
    ErrUserBasicInfoInvalid

    // ErrUserStatusInvalid - 400: User status is invalid.
    ErrUserStatusInvalid

    // ErrUserInvalid - 400: User is invalid.
    ErrUserInvalid

    // ErrUserBlocked - 403: User is blocked.
    ErrUserBlocked

    // ErrUserInactive - 403: User is inactive.
    ErrUserInactive
)

// é—®å·æ¨¡å—é”™è¯¯ç  120001-120099
const (
    // ErrQuestionnaireNotFound - 404: Questionnaire not found.
    ErrQuestionnaireNotFound int = iota + 120001
    
    // ErrQuestionnaireCodeExists - 400: Questionnaire code already exists.
    ErrQuestionnaireCodeExists
    
    // ErrQuestionnaireStatusInvalid - 400: Questionnaire status is invalid.
    ErrQuestionnaireStatusInvalid
    
    // ErrQuestionnaireVersionInvalid - 400: Questionnaire version is invalid.
    ErrQuestionnaireVersionInvalid
)
```

### ğŸ”§ é”™è¯¯ç å·¥å…·å‡½æ•°

```go
// pkg/errors/code.go

// GetCode ä»é”™è¯¯ä¸­æå–é”™è¯¯ç 
func GetCode(err error) int {
    if err == nil {
        return ErrSuccess
    }

    if e, ok := err.(*withCode); ok {
        return e.code
    }

    return ErrUnknown
}

// GetMessage è·å–é”™è¯¯ç å¯¹åº”çš„æ¶ˆæ¯
func GetMessage(code int) string {
    if msg, ok := codeText[code]; ok {
        return msg
    }
    return codeText[ErrUnknown]
}

// IsCode æ£€æŸ¥é”™è¯¯æ˜¯å¦ä¸ºæŒ‡å®šé”™è¯¯ç 
func IsCode(err error, code int) bool {
    return GetCode(err) == code
}
```

## ğŸ“š å †æ ˆè·Ÿè¸ªæœºåˆ¶ {#stack-trace-mechanism}

### ğŸ” å †æ ˆä¿¡æ¯æ”¶é›†

```go
// pkg/errors/stack.go

// Frame ä»£è¡¨è°ƒç”¨æ ˆä¸­çš„ä¸€ä¸ªå¸§
type Frame uintptr

// pc è¿”å›ç¨‹åºè®¡æ•°å™¨
func (f Frame) pc() uintptr { return uintptr(f) - 1 }

// file è¿”å›æ–‡ä»¶å
func (f Frame) file() string {
    fn := runtime.FuncForPC(f.pc())
    if fn == nil {
        return "unknown"
    }
    file, _ := fn.FileLine(f.pc())
    return file
}

// line è¿”å›è¡Œå·
func (f Frame) line() int {
    fn := runtime.FuncForPC(f.pc())
    if fn == nil {
        return 0
    }
    _, line := fn.FileLine(f.pc())
    return line
}

// name è¿”å›å‡½æ•°å
func (f Frame) name() string {
    fn := runtime.FuncForPC(f.pc())
    if fn == nil {
        return "unknown"
    }
    return fn.Name()
}

// Format æ ¼å¼åŒ–è¾“å‡ºå¸§ä¿¡æ¯
func (f Frame) Format(s fmt.State, verb rune) {
    switch verb {
    case 's':
        switch {
        case s.Flag('+'):
            io.WriteString(s, f.name())
            io.WriteString(s, "\n\t")
            io.WriteString(s, f.file())
        default:
            io.WriteString(s, path.Base(f.file()))
        }
    case 'd':
        io.WriteString(s, strconv.Itoa(f.line()))
    case 'n':
        io.WriteString(s, funcname(f.name()))
    case 'v':
        f.Format(s, 's')
        io.WriteString(s, ":")
        f.Format(s, 'd')
    }
}

// StackTrace è¡¨ç¤ºç¨‹åºè°ƒç”¨æ ˆ
type StackTrace []Frame

// Format æ ¼å¼åŒ–è¾“å‡ºå †æ ˆè·Ÿè¸ª
func (st StackTrace) Format(s fmt.State, verb rune) {
    switch verb {
    case 'v':
        switch {
        case s.Flag('+'):
            for _, f := range st {
                io.WriteString(s, "\n")
                f.Format(s, verb)
            }
        case s.Flag('#'):
            fmt.Fprintf(s, "%#v", []Frame(st))
        default:
            st.formatSlice(s, verb)
        }
    case 's':
        st.formatSlice(s, verb)
    }
}

// stack å †æ ˆä¿¡æ¯
type stack []uintptr

// callers æ”¶é›†è°ƒç”¨æ ˆä¿¡æ¯
func callers() *stack {
    const depth = 32
    var pcs [depth]uintptr
    n := runtime.Callers(3, pcs[:])
    var st stack = pcs[0:n]
    return &st
}

// StackTrace è¿”å›å †æ ˆè·Ÿè¸ª
func (s *stack) StackTrace() StackTrace {
    f := make([]Frame, len(*s))
    for i := 0; i < len(f); i++ {
        f[i] = Frame((*s)[i])
    }
    return f
}

// Format æ ¼å¼åŒ–è¾“å‡ºå †æ ˆ
func (s *stack) Format(st fmt.State, verb rune) {
    switch verb {
    case 'v':
        switch {
        case st.Flag('+'):
            for _, pc := range *s {
                f := Frame(pc)
                fmt.Fprintf(st, "\n%+v", f)
            }
        }
    }
}
```

### ğŸ“‹ å †æ ˆä¿¡æ¯ä½¿ç”¨

```go
// åˆ›å»ºå¸¦å †æ ˆçš„é”™è¯¯
err := errors.New("something went wrong")

// æ·»åŠ å †æ ˆä¿¡æ¯
err = errors.WithStack(err)

// æ ¼å¼åŒ–è¾“å‡ºè¯¦ç»†å †æ ˆ
fmt.Printf("%+v", err)

// è¾“å‡ºç¤ºä¾‹:
// something went wrong
//     main.doSomething
//         /path/to/main.go:25
//     main.main
//         /path/to/main.go:15
//     runtime.main
//         /usr/local/go/src/runtime/proc.go:250
```

## ğŸ”„ é”™è¯¯ä¼ æ’­ç­–ç•¥ {#error-propagation}

### ğŸ“Š åˆ†å±‚é”™è¯¯å¤„ç†ç­–ç•¥

```mermaid
graph TD
    subgraph "è¡¨ç¤ºå±‚ Presentation Layer"
        HANDLER[HTTP Handler]
        RESPONSE[é”™è¯¯å“åº”]
    end
    
    subgraph "åº”ç”¨å±‚ Application Layer"
        SERVICE[Application Service]
        VALIDATION[å‚æ•°éªŒè¯]
    end
    
    subgraph "é¢†åŸŸå±‚ Domain Layer"
        DOMAIN[Domain Logic]
        BUSINESS[ä¸šåŠ¡è§„åˆ™éªŒè¯]
    end
    
    subgraph "åŸºç¡€è®¾æ–½å±‚ Infrastructure Layer"
        REPO[Repository]
        DATABASE[(æ•°æ®åº“)]
    end
    
    HANDLER --> SERVICE
    SERVICE --> VALIDATION
    SERVICE --> DOMAIN
    DOMAIN --> BUSINESS
    DOMAIN --> REPO
    REPO --> DATABASE
    
    DATABASE -.-> REPO
    REPO -.-> DOMAIN
    BUSINESS -.-> DOMAIN
    DOMAIN -.-> SERVICE
    VALIDATION -.-> SERVICE
    SERVICE -.-> HANDLER
    HANDLER --> RESPONSE
```

### ğŸ¯ é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

#### 1. **é¢†åŸŸå±‚é”™è¯¯å¤„ç†**

```go
// internal/apiserver/domain/user/model.go

// ChangePassword ä¿®æ”¹å¯†ç ï¼ˆé¢†åŸŸå±‚ï¼‰
func (u *User) ChangePassword(newPassword string) error {
    if len(newPassword) < 6 {
        return errors.WithCode(code.ErrUserBasicInfoInvalid, 
            "password must be at least 6 characters")
    }

    hashedPassword, err := auth.Encrypt(newPassword)
    if err != nil {
        return errors.WithCode(code.ErrEncrypt, 
            "failed to encrypt password")
    }

    u.password = hashedPassword
    return nil
}
```

#### 2. **åº”ç”¨å±‚é”™è¯¯å¤„ç†**

```go
// internal/apiserver/application/user/creator.go

// CreateUser åˆ›å»ºç”¨æˆ·ï¼ˆåº”ç”¨å±‚ï¼‰
func (c *UserCreator) CreateUser(ctx context.Context, username, password, nickname, email, phone, introduction string) (*user.User, error) {
    // å‚æ•°éªŒè¯
    if username == "" {
        return nil, errors.WithCode(code.ErrValidation, "username is required")
    }

    // å”¯ä¸€æ€§æ£€æŸ¥
    if c.usernameUnique(ctx, username) {
        return nil, errors.WithCode(code.ErrUserAlreadyExists, "username already exists")
    }

    // åˆ›å»ºç”¨æˆ·é¢†åŸŸå¯¹è±¡
    userObj := user.NewUserBuilder().
        WithUsername(username).
        WithPassword(password).
        WithNickname(nickname).
        WithEmail(email).
        WithPhone(phone).
        WithStatus(user.StatusInit).
        WithIntroduction(introduction).
        Build()

    // ä¿å­˜ç”¨æˆ·ï¼Œä¼ æ’­åº•å±‚é”™è¯¯
    if err := c.userRepo.Save(ctx, userObj); err != nil {
        return nil, errors.WithMessage(err, "failed to save user")
    }

    return userObj, nil
}
```

#### 3. **åŸºç¡€è®¾æ–½å±‚é”™è¯¯å¤„ç†**

```go
// internal/apiserver/infrastructure/mysql/user/repo.go

// FindByUsername æ ¹æ®ç”¨æˆ·åæŸ¥è¯¢ç”¨æˆ·ï¼ˆåŸºç¡€è®¾æ–½å±‚ï¼‰
func (r *Repository) FindByUsername(ctx context.Context, username string) (*user.User, error) {
    var po UserPO
    err := r.BaseRepository.FindByField(ctx, &po, "username", username)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.WithCode(code.ErrUserNotFound, 
                "user not found: %s", username)
        }
        return nil, errors.WithStack(err)
    }
    return r.mapper.ToBO(&po), nil
}
```

#### 4. **æ¥å£å±‚é”™è¯¯å¤„ç†**

```go
// internal/apiserver/interface/restful/handler/user.go

// CreateUser HTTPå¤„ç†å™¨ï¼ˆæ¥å£å±‚ï¼‰
func (h *UserHandler) CreateUser(c *gin.Context) {
    var req dto.CreateUserRequest
    if err := h.BindJSON(c, &req); err != nil {
        h.ErrorResponse(c, errors.WithCode(code.ErrBind, err.Error()))
        return
    }

    // å‚æ•°éªŒè¯
    if ok, err := govalidator.ValidateStruct(req); !ok {
        h.ErrorResponse(c, errors.WithCode(code.ErrValidation, err.Error()))
        return
    }

    // è°ƒç”¨åº”ç”¨æœåŠ¡
    user, err := h.userCreator.CreateUser(c, req.Username, req.Password, 
        req.Nickname, req.Email, req.Phone, req.Introduction)
    if err != nil {
        h.ErrorResponse(c, err)
        return
    }

    // æˆåŠŸå“åº”
    h.SuccessResponse(c, toUserResponse(user))
}

// ErrorResponse ç»Ÿä¸€é”™è¯¯å“åº”å¤„ç†
func (h *BaseHandler) ErrorResponse(c *gin.Context, err error) {
    if err == nil {
        return
    }

    // è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼ˆåŒ…å«å †æ ˆï¼‰
    log.Errorf("Request failed: %+v", err)

    // æå–é”™è¯¯ç 
    code := errors.GetCode(err)
    message := errors.GetMessage(code)

    // è¿”å›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
    core.WriteResponse(c, err, nil)
}
```

### ğŸ”„ é”™è¯¯åŒ…è£…ä¸ä¼ æ’­

```go
// Wrap åŒ…è£…é”™è¯¯å¹¶æ·»åŠ ä¸Šä¸‹æ–‡
func processUser(userID string) error {
    user, err := getUserFromDB(userID)
    if err != nil {
        return errors.Wrap(err, "failed to get user from database")
    }
    
    if err := validateUser(user); err != nil {
        return errors.Wrapf(err, "user validation failed for userID %s", userID)
    }
    
    return nil
}

// è°ƒç”¨æ–¹
func handleRequest() error {
    if err := processUser("123"); err != nil {
        return errors.WithMessage(err, "process user request failed")
    }
    return nil
}
```

## ğŸ“š å®é™…åº”ç”¨æ¡ˆä¾‹ {#practical-cases}

### ğŸ¯ å®Œæ•´çš„é”™è¯¯å¤„ç†æµç¨‹

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant Handler as HTTP Handler
    participant Service as Application Service
    participant Domain as Domain Model
    participant Repo as Repository
    participant DB as æ•°æ®åº“
    
    Client->>Handler: POST /users
    Handler->>Service: CreateUser()
    Service->>Domain: NewUser()
    Domain->>Domain: ValidatePassword()
    Domain-->>Service: ErrUserBasicInfoInvalid
    Service-->>Handler: WithMessage(err, "failed to create user")
    Handler->>Handler: ErrorResponse()
    Handler-->>Client: 400 Bad Request
    
    Note over Handler: è®°å½•å®Œæ•´å †æ ˆ: log.Errorf("%+v", err)
    Note over Handler: è¿”å›ç”¨æˆ·å‹å¥½æ¶ˆæ¯: "password must be at least 6 characters"
```

### ğŸ’¡ é”™è¯¯èšåˆå¤„ç†

```go
// pkg/errors/aggregate.go

// Aggregate é”™è¯¯èšåˆå™¨
type Aggregate interface {
    error
    Errors() []error
    Is(error) bool
}

// aggregate é”™è¯¯èšåˆå®ç°
type aggregate []error

// NewAggregate åˆ›å»ºé”™è¯¯èšåˆå™¨
func NewAggregate(errlist []error) Aggregate {
    if len(errlist) == 0 {
        return nil
    }
    
    var errs []error
    for _, err := range errlist {
        if err != nil {
            errs = append(errs, err)
        }
    }
    
    if len(errs) == 0 {
        return nil
    }
    return aggregate(errs)
}

// Error å®ç°erroræ¥å£
func (agg aggregate) Error() string {
    if len(agg) == 1 {
        return agg[0].Error()
    }
    
    var result []string
    for _, err := range agg {
        result = append(result, err.Error())
    }
    return fmt.Sprintf("[%s]", strings.Join(result, ", "))
}

// Errors è¿”å›æ‰€æœ‰é”™è¯¯
func (agg aggregate) Errors() []error {
    return []error(agg)
}

// Is æ£€æŸ¥æ˜¯å¦åŒ…å«æŒ‡å®šé”™è¯¯
func (agg aggregate) Is(target error) bool {
    for _, err := range agg {
        if errors.Is(err, target) {
            return true
        }
    }
    return false
}

// ä½¿ç”¨ç¤ºä¾‹
func validateUserInput(req *UserCreateRequest) error {
    var errs []error
    
    if req.Username == "" {
        errs = append(errs, errors.WithCode(code.ErrValidation, "username is required"))
    }
    
    if len(req.Password) < 6 {
        errs = append(errs, errors.WithCode(code.ErrValidation, "password too short"))
    }
    
    if !isValidEmail(req.Email) {
        errs = append(errs, errors.WithCode(code.ErrValidation, "invalid email format"))
    }
    
    return errors.NewAggregate(errs)
}
```

### ğŸ”§ é”™è¯¯æ¢å¤æœºåˆ¶

```go
// é”™è¯¯æ¢å¤å’Œé™çº§å¤„ç†
func (s *UserService) GetUserWithFallback(ctx context.Context, userID string) (*User, error) {
    // å°è¯•ä»ä¸»æ•°æ®æºè·å–
    user, err := s.primaryRepo.GetUser(ctx, userID)
    if err == nil {
        return user, nil
    }
    
    // è®°å½•ä¸»æ•°æ®æºé”™è¯¯
    log.Warnf("Primary datasource failed: %+v", err)
    
    // å°è¯•ä»ç¼“å­˜è·å–
    user, cacheErr := s.cacheRepo.GetUser(ctx, userID)
    if cacheErr == nil {
        log.Info("Fallback to cache successful")
        return user, nil
    }
    
    // æ‰€æœ‰æ•°æ®æºéƒ½å¤±è´¥
    return nil, errors.WithMessage(err, 
        "all datasources failed, primary error is the root cause")
}
```

## ğŸ¯ æœ€ä½³å®è·µæ€»ç»“

### âœ… é”™è¯¯åˆ›å»ºæœ€ä½³å®è·µ

1. **ä½¿ç”¨WithCode**: ä¸ºä¸šåŠ¡é”™è¯¯æ·»åŠ é”™è¯¯ç 
2. **ä¿ç•™ä¸Šä¸‹æ–‡**: ä½¿ç”¨WithMessageæ·»åŠ æœ‰ç”¨çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
3. **é¿å…é‡å¤**: ä¸è¦é‡å¤åŒ…è£…åŒä¸€ä¸ªé”™è¯¯
4. **åŠæ—¶å¤„ç†**: åœ¨åˆé€‚çš„å±‚çº§å¤„ç†é”™è¯¯

### ğŸ”§ é”™è¯¯ä¼ æ’­æœ€ä½³å®è·µ

1. **å‘ä¸Šä¼ æ’­**: ä½å±‚é”™è¯¯å‘é«˜å±‚ä¼ æ’­æ—¶æ·»åŠ ä¸Šä¸‹æ–‡
2. **ä¿ç•™åŸå› **: ä½¿ç”¨Wrapè€Œä¸æ˜¯åˆ›å»ºæ–°é”™è¯¯
3. **åˆ†å±‚å¤„ç†**: ä¸åŒå±‚æ¬¡æœ‰ä¸åŒçš„é”™è¯¯å¤„ç†ç­–ç•¥
4. **æ—¥å¿—è®°å½•**: åœ¨åˆé€‚çš„åœ°æ–¹è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯

### ğŸ“Š é”™è¯¯å“åº”æœ€ä½³å®è·µ

1. **ç”¨æˆ·å‹å¥½**: å¯¹å¤–è¿”å›ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
2. **å®‰å…¨è€ƒè™‘**: ä¸è¦æš´éœ²æ•æ„Ÿçš„ç³»ç»Ÿå†…éƒ¨ä¿¡æ¯
3. **ä¸€è‡´æ ¼å¼**: ä¿æŒé”™è¯¯å“åº”æ ¼å¼çš„ä¸€è‡´æ€§
4. **è¿½è¸ªæ”¯æŒ**: æä¾›è¯·æ±‚IDä»¥ä¾¿é—®é¢˜è¿½è¸ª

### ğŸ” é”™è¯¯è°ƒè¯•æœ€ä½³å®è·µ

1. **å®Œæ•´å †æ ˆ**: å¼€å‘ç¯å¢ƒè®°å½•å®Œæ•´çš„é”™è¯¯å †æ ˆ
2. **ç»“æ„åŒ–æ—¥å¿—**: ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—ä¾¿äºåˆ†æ
3. **é”™è¯¯ç›‘æ§**: è®¾ç½®å…³é”®é”™è¯¯çš„ç›‘æ§å’Œå‘Šè­¦
4. **æ€§èƒ½è€ƒè™‘**: åœ¨ç”Ÿäº§ç¯å¢ƒå¹³è¡¡è¯¦ç»†ç¨‹åº¦å’Œæ€§èƒ½

è¿™ç§å®Œæ•´çš„é”™è¯¯å¤„ç†ä½“ç³»ä¸ºåº”ç”¨æä¾›äº†å¼ºå¤§çš„é”™è¯¯ç®¡ç†å’Œè°ƒè¯•èƒ½åŠ›ï¼Œç¡®ä¿ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
