# ğŸ—„ï¸ æ•°æ®åº“æ³¨å†Œå™¨è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [æ³¨å†Œå™¨æ ¸å¿ƒæ¶æ„](#registry-architecture)
- [è¿æ¥ç®¡ç†ç­–ç•¥](#connection-management)
- [å¤šæ•°æ®æºæ”¯æŒ](#multi-datasource)
- [å¥åº·æ£€æŸ¥æœºåˆ¶](#health-check)
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#practical-cases)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æ•°æ®åº“æ³¨å†Œå™¨æ˜¯ä¸€ä¸ªé›†ä¸­åŒ–çš„æ•°æ®åº“è¿æ¥ç®¡ç†ç³»ç»Ÿï¼Œé‡‡ç”¨**æ³¨å†Œå™¨æ¨¡å¼**å’Œ**å·¥å‚æ¨¡å¼**ï¼Œå®ç°äº†å¤šç§æ•°æ®åº“çš„ç»Ÿä¸€ç®¡ç†ã€è¿æ¥æ± ä¼˜åŒ–å’Œå¥åº·ç›‘æ§ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **ç»Ÿä¸€ç®¡ç†**: é›†ä¸­ç®¡ç†å¤šç§æ•°æ®åº“è¿æ¥
2. **ç±»å‹å®‰å…¨**: é€šè¿‡æ³›å‹å’Œæ¥å£ä¿è¯ç±»å‹å®‰å…¨
3. **è¿æ¥å¤ç”¨**: é«˜æ•ˆçš„è¿æ¥æ± ç®¡ç†
4. **å¥åº·ç›‘æ§**: å®æ—¶ç›‘æ§æ•°æ®åº“è¿æ¥çŠ¶æ€
5. **ä¼˜é›…å…³é—­**: æ”¯æŒä¼˜é›…çš„èµ„æºæ¸…ç†

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£**: ä¸“æ³¨äºæ•°æ®åº“è¿æ¥ç®¡ç†
- **å¼€é—­åŸåˆ™**: æ”¯æŒæ–°æ•°æ®åº“ç±»å‹æ‰©å±•
- **ä¾èµ–å€’ç½®**: åŸºäºæ¥å£è€Œéå…·ä½“å®ç°
- **çº¿ç¨‹å®‰å…¨**: æ”¯æŒå¹¶å‘è®¿é—®

## ğŸ›ï¸ æ³¨å†Œå™¨æ ¸å¿ƒæ¶æ„ {#registry-architecture}

### ğŸ“¦ æ ¸å¿ƒç»“æ„

```go
// pkg/database/registry.go

// Registry æ•°æ®åº“æ³¨å†Œå™¨
type Registry struct {
    mu          sync.RWMutex                           // è¯»å†™é”ä¿æŠ¤
    connections map[dbs.DatabaseType]dbs.Connection    // è¿æ¥æ˜ å°„
    configs     map[dbs.DatabaseType]interface{}       // é…ç½®æ˜ å°„
    initialized bool                                   // åˆå§‹åŒ–çŠ¶æ€
}
```

### ğŸ”§ æ•°æ®åº“ç±»å‹ä¸è¿æ¥æ¥å£

```go
// pkg/database/databases/connections.go

// DatabaseType æ•°æ®åº“ç±»å‹æšä¸¾
type DatabaseType string

const (
    MySQL   DatabaseType = "mysql"
    MongoDB DatabaseType = "mongodb"
    Redis   DatabaseType = "redis"
)

// Connection æ•°æ®åº“è¿æ¥æ¥å£
type Connection interface {
    Type() DatabaseType                    // è¿”å›æ•°æ®åº“ç±»å‹
    Connect() error                        // å»ºç«‹è¿æ¥
    Close() error                          // å…³é—­è¿æ¥
    GetClient() interface{}               // è·å–å®¢æˆ·ç«¯å®ä¾‹
    HealthCheck(ctx context.Context) error // å¥åº·æ£€æŸ¥
}
```

### ğŸš€ æ¶æ„æµç¨‹å›¾

```mermaid
graph TB
    subgraph "åº”ç”¨å±‚ Application"
        APP[åº”ç”¨ç¨‹åº]
        CONFIG[é…ç½®ç®¡ç†]
    end
    
    subgraph "æ³¨å†Œå™¨å±‚ Registry Layer"
        REGISTRY[Database Registry<br/>pkg/database/registry.go]
        FACTORY[Connection Factory]
    end
    
    subgraph "è¿æ¥å±‚ Connection Layer"
        MYSQL_CONN[MySQL Connection<br/>pkg/database/databases/mysql.go]
        MONGO_CONN[MongoDB Connection<br/>pkg/database/databases/mongo.go]
        REDIS_CONN[Redis Connection<br/>pkg/database/databases/redis.go]
    end
    
    subgraph "æ•°æ®åº“å±‚ Database Layer"
        MYSQL[(MySQL 8.0)]
        MONGODB[(MongoDB 6.0)]
        REDIS[(Redis 7.0)]
    end
    
    APP --> CONFIG
    APP --> REGISTRY
    CONFIG --> FACTORY
    REGISTRY --> FACTORY
    
    FACTORY --> MYSQL_CONN
    FACTORY --> MONGO_CONN
    FACTORY --> REDIS_CONN
    
    MYSQL_CONN --> MYSQL
    MONGO_CONN --> MONGODB
    REDIS_CONN --> REDIS
    
    style REGISTRY fill:#e3f2fd
    style MYSQL_CONN fill:#e8f5e8
    style MONGO_CONN fill:#fff3e0
    style REDIS_CONN fill:#f3e5f5
```

## ğŸ”— è¿æ¥ç®¡ç†ç­–ç•¥ {#connection-management}

### ğŸ“ æ³¨å†Œå™¨APIè®¾è®¡

#### 1. æ³¨å†Œå™¨åˆ›å»ºå’Œåˆå§‹åŒ–

```go
// NewRegistry åˆ›å»ºæ–°çš„æ•°æ®åº“æ³¨å†Œå™¨
func NewRegistry() *Registry {
    return &Registry{
        connections: make(map[dbs.DatabaseType]dbs.Connection),
        configs:     make(map[dbs.DatabaseType]interface{}),
    }
}

// Register æ³¨å†Œæ•°æ®åº“è¿æ¥
func (r *Registry) Register(dbType dbs.DatabaseType, config interface{}, connection dbs.Connection) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    if r.initialized {
        return fmt.Errorf("registry already initialized, cannot register new connections")
    }

    if connection == nil {
        return fmt.Errorf("connection cannot be nil")
    }

    if connection.Type() != dbType {
        return fmt.Errorf("connection type mismatch: expected %s, got %s", dbType, connection.Type())
    }

    r.connections[dbType] = connection
    r.configs[dbType] = config

    log.Printf("Registered database connection: %s", dbType)
    return nil
}
```

#### 2. è¿æ¥åˆå§‹åŒ–

```go
// Init åˆå§‹åŒ–æ‰€æœ‰å·²æ³¨å†Œçš„æ•°æ®åº“è¿æ¥
func (r *Registry) Init() error {
    r.mu.Lock()
    defer r.mu.Unlock()

    if r.initialized {
        return nil
    }

    for dbType, connection := range r.connections {
        log.Printf("Initializing database connection: %s", dbType)
        if err := connection.Connect(); err != nil {
            return fmt.Errorf("failed to connect to %s: %w", dbType, err)
        }
    }

    r.initialized = true
    log.Println("All database connections initialized successfully")
    return nil
}
```

#### 3. è¿æ¥è·å–

```go
// Get è·å–æŒ‡å®šç±»å‹çš„æ•°æ®åº“è¿æ¥
func (r *Registry) Get(dbType dbs.DatabaseType) (dbs.Connection, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    connection, exists := r.connections[dbType]
    if !exists {
        return nil, fmt.Errorf("database connection not found: %s", dbType)
    }

    return connection, nil
}

// GetClient è·å–æŒ‡å®šç±»å‹çš„æ•°æ®åº“å®¢æˆ·ç«¯
func (r *Registry) GetClient(dbType dbs.DatabaseType) (interface{}, error) {
    connection, err := r.Get(dbType)
    if err != nil {
        return nil, err
    }

    return connection.GetClient(), nil
}
```

## ğŸŒ å¤šæ•°æ®æºæ”¯æŒ {#multi-datasource}

### ğŸ“Š MySQLè¿æ¥å®ç°

```go
// pkg/database/databases/mysql.go

// MySQLConnection MySQLè¿æ¥å®ç°
type MySQLConnection struct {
    config *MySQLConfig
    db     *gorm.DB
}

// MySQLConfig MySQLé…ç½®
type MySQLConfig struct {
    Host            string
    Port            int
    Username        string
    Password        string
    Database        string
    Parameters      string
    MaxIdleConns    int
    MaxOpenConns    int
    MaxLifetime     time.Duration
    LogLevel        int
    SlowThreshold   time.Duration
}

// NewMySQLConnection åˆ›å»ºMySQLè¿æ¥
func NewMySQLConnection(config *MySQLConfig) *MySQLConnection {
    return &MySQLConnection{
        config: config,
    }
}

// Type è¿”å›æ•°æ®åº“ç±»å‹
func (m *MySQLConnection) Type() DatabaseType {
    return MySQL
}

// Connect å»ºç«‹MySQLè¿æ¥
func (m *MySQLConnection) Connect() error {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?%s",
        m.config.Username,
        m.config.Password,
        m.config.Host,
        m.config.Port,
        m.config.Database,
        m.config.Parameters,
    )

    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.LogLevel(m.config.LogLevel)),
        NowFunc: func() time.Time {
            return time.Now().Local()
        },
    })
    if err != nil {
        return fmt.Errorf("failed to connect to MySQL: %w", err)
    }

    // é…ç½®è¿æ¥æ± 
    sqlDB, err := db.DB()
    if err != nil {
        return fmt.Errorf("failed to get underlying sql.DB: %w", err)
    }

    sqlDB.SetMaxIdleConns(m.config.MaxIdleConns)
    sqlDB.SetMaxOpenConns(m.config.MaxOpenConns)
    sqlDB.SetConnMaxLifetime(m.config.MaxLifetime)

    m.db = db
    return nil
}

// GetClient è·å–GORMå®ä¾‹
func (m *MySQLConnection) GetClient() interface{} {
    return m.db
}

// HealthCheck MySQLå¥åº·æ£€æŸ¥
func (m *MySQLConnection) HealthCheck(ctx context.Context) error {
    if m.db == nil {
        return fmt.Errorf("MySQL connection not initialized")
    }

    sqlDB, err := m.db.DB()
    if err != nil {
        return fmt.Errorf("failed to get underlying sql.DB: %w", err)
    }

    return sqlDB.PingContext(ctx)
}

// Close å…³é—­MySQLè¿æ¥
func (m *MySQLConnection) Close() error {
    if m.db == nil {
        return nil
    }

    sqlDB, err := m.db.DB()
    if err != nil {
        return fmt.Errorf("failed to get underlying sql.DB: %w", err)
    }

    return sqlDB.Close()
}
```

### ğŸ“„ MongoDBè¿æ¥å®ç°

```go
// pkg/database/databases/mongo.go

// MongoConnection MongoDBè¿æ¥å®ç°
type MongoConnection struct {
    config *MongoConfig
    client *mongo.Client
    db     *mongo.Database
}

// MongoConfig MongoDBé…ç½®
type MongoConfig struct {
    URI      string
    Database string
    Username string
    Password string
    Timeout  time.Duration
}

// Connect å»ºç«‹MongoDBè¿æ¥
func (m *MongoConnection) Connect() error {
    ctx, cancel := context.WithTimeout(context.Background(), m.config.Timeout)
    defer cancel()

    // æ„å»ºè¿æ¥é€‰é¡¹
    opts := options.Client().ApplyURI(m.config.URI)
    if m.config.Username != "" && m.config.Password != "" {
        credential := options.Credential{
            Username: m.config.Username,
            Password: m.config.Password,
        }
        opts.SetAuth(credential)
    }

    // å»ºç«‹è¿æ¥
    client, err := mongo.Connect(ctx, opts)
    if err != nil {
        return fmt.Errorf("failed to connect to MongoDB: %w", err)
    }

    // æµ‹è¯•è¿æ¥
    if err := client.Ping(ctx, nil); err != nil {
        return fmt.Errorf("failed to ping MongoDB: %w", err)
    }

    m.client = client
    m.db = client.Database(m.config.Database)
    return nil
}

// GetClient è·å–MongoDBæ•°æ®åº“å®ä¾‹
func (m *MongoConnection) GetClient() interface{} {
    return m.db
}

// HealthCheck MongoDBå¥åº·æ£€æŸ¥
func (m *MongoConnection) HealthCheck(ctx context.Context) error {
    if m.client == nil {
        return fmt.Errorf("MongoDB connection not initialized")
    }

    return m.client.Ping(ctx, nil)
}
```

### âš¡ Redisè¿æ¥å®ç°

```go
// pkg/database/databases/redis.go

// RedisConnection Redisè¿æ¥å®ç°
type RedisConnection struct {
    config *RedisConfig
    client *redis.Client
}

// RedisConfig Redisé…ç½®
type RedisConfig struct {
    Host         string
    Port         int
    Password     string
    Database     int
    PoolSize     int
    MinIdleConns int
    DialTimeout  time.Duration
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}

// Connect å»ºç«‹Redisè¿æ¥
func (r *RedisConnection) Connect() error {
    addr := fmt.Sprintf("%s:%d", r.config.Host, r.config.Port)
    
    client := redis.NewClient(&redis.Options{
        Addr:         addr,
        Password:     r.config.Password,
        DB:           r.config.Database,
        PoolSize:     r.config.PoolSize,
        MinIdleConns: r.config.MinIdleConns,
        DialTimeout:  r.config.DialTimeout,
        ReadTimeout:  r.config.ReadTimeout,
        WriteTimeout: r.config.WriteTimeout,
    })

    // æµ‹è¯•è¿æ¥
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := client.Ping(ctx).Err(); err != nil {
        return fmt.Errorf("failed to connect to Redis: %w", err)
    }

    r.client = client
    return nil
}

// GetClient è·å–Rediså®¢æˆ·ç«¯
func (r *RedisConnection) GetClient() interface{} {
    return r.client
}

// HealthCheck Rediså¥åº·æ£€æŸ¥
func (r *RedisConnection) HealthCheck(ctx context.Context) error {
    if r.client == nil {
        return fmt.Errorf("Redis connection not initialized")
    }

    return r.client.Ping(ctx).Err()
}
```

## ğŸ¥ å¥åº·æ£€æŸ¥æœºåˆ¶ {#health-check}

### ğŸ“Š å¥åº·æ£€æŸ¥æ¥å£

```go
// HealthCheck å¯¹æ‰€æœ‰æ•°æ®åº“è¿æ¥è¿›è¡Œå¥åº·æ£€æŸ¥
func (r *Registry) HealthCheck(ctx context.Context) error {
    r.mu.RLock()
    defer r.mu.RUnlock()

    var errs []error

    for dbType, connection := range r.connections {
        if err := connection.HealthCheck(ctx); err != nil {
            errs = append(errs, fmt.Errorf("%s health check failed: %w", dbType, err))
        }
    }

    if len(errs) > 0 {
        return fmt.Errorf("database health check failed: %v", errs)
    }

    return nil
}
```

### ğŸ“ˆ å¥åº·çŠ¶æ€ç›‘æ§

```go
// HealthStatus å¥åº·çŠ¶æ€
type HealthStatus struct {
    DatabaseType DatabaseType `json:"database_type"`
    Status       string      `json:"status"`
    Message      string      `json:"message,omitempty"`
    Timestamp    time.Time   `json:"timestamp"`
}

// GetHealthStatus è·å–æ‰€æœ‰æ•°æ®åº“çš„å¥åº·çŠ¶æ€
func (r *Registry) GetHealthStatus(ctx context.Context) []HealthStatus {
    r.mu.RLock()
    defer r.mu.RUnlock()

    var statuses []HealthStatus

    for dbType, connection := range r.connections {
        status := HealthStatus{
            DatabaseType: dbType,
            Timestamp:    time.Now(),
        }

        if err := connection.HealthCheck(ctx); err != nil {
            status.Status = "unhealthy"
            status.Message = err.Error()
        } else {
            status.Status = "healthy"
        }

        statuses = append(statuses, status)
    }

    return statuses
}
```

### ğŸ”„ å®šæœŸå¥åº·æ£€æŸ¥

```go
// StartHealthChecker å¯åŠ¨å®šæœŸå¥åº·æ£€æŸ¥
func (r *Registry) StartHealthChecker(interval time.Duration) {
    ticker := time.NewTicker(interval)
    go func() {
        for range ticker.C {
            ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
            
            if err := r.HealthCheck(ctx); err != nil {
                log.Printf("Database health check failed: %v", err)
            } else {
                log.Println("All databases are healthy")
            }
            
            cancel()
        }
    }()
}
```

## ğŸ“š å®é™…åº”ç”¨æ¡ˆä¾‹ {#practical-cases}

### ğŸš€ æ³¨å†Œå™¨ä½¿ç”¨ç¤ºä¾‹

```go
// åˆ›å»ºæ•°æ®åº“æ³¨å†Œå™¨
registry := database.NewRegistry()

// æ³¨å†ŒMySQLè¿æ¥
mysqlConfig := &databases.MySQLConfig{
    Host:         "localhost",
    Port:         3306,
    Username:     "root",
    Password:     "password",
    Database:     "questionnaire",
    MaxIdleConns: 10,
    MaxOpenConns: 100,
    MaxLifetime:  time.Hour,
}
mysqlConn := databases.NewMySQLConnection(mysqlConfig)
registry.Register(databases.MySQL, mysqlConfig, mysqlConn)

// æ³¨å†ŒMongoDBè¿æ¥
mongoConfig := &databases.MongoConfig{
    URI:      "mongodb://localhost:27017",
    Database: "questionnaire",
    Timeout:  10 * time.Second,
}
mongoConn := databases.NewMongoConnection(mongoConfig)
registry.Register(databases.MongoDB, mongoConfig, mongoConn)

// åˆå§‹åŒ–æ‰€æœ‰è¿æ¥
if err := registry.Init(); err != nil {
    log.Fatal("Failed to initialize database connections:", err)
}

// è·å–MySQLå®¢æˆ·ç«¯
mysqlClient, err := registry.GetClient(databases.MySQL)
if err != nil {
    log.Fatal("Failed to get MySQL client:", err)
}
db := mysqlClient.(*gorm.DB)

// è·å–MongoDBå®¢æˆ·ç«¯
mongoClient, err := registry.GetClient(databases.MongoDB)
if err != nil {
    log.Fatal("Failed to get MongoDB client:", err)
}
mongoDB := mongoClient.(*mongo.Database)
```

### ğŸ”§ åœ¨åº”ç”¨ä¸­é›†æˆ

```go
// internal/apiserver/database.go

func setupDatabase(cfg *config.Config) (*gorm.DB, *mongo.Database, error) {
    // åˆ›å»ºæ•°æ®åº“æ³¨å†Œå™¨
    registry := database.NewRegistry()

    // æ³¨å†ŒMySQL
    mysqlConn := databases.NewMySQLConnection(cfg.MySQLOptions)
    if err := registry.Register(databases.MySQL, cfg.MySQLOptions, mysqlConn); err != nil {
        return nil, nil, fmt.Errorf("failed to register MySQL: %w", err)
    }

    // æ³¨å†ŒMongoDB
    mongoConn := databases.NewMongoConnection(cfg.MongoDBOptions)
    if err := registry.Register(databases.MongoDB, cfg.MongoDBOptions, mongoConn); err != nil {
        return nil, nil, fmt.Errorf("failed to register MongoDB: %w", err)
    }

    // åˆå§‹åŒ–è¿æ¥
    if err := registry.Init(); err != nil {
        return nil, nil, fmt.Errorf("failed to initialize databases: %w", err)
    }

    // å¯åŠ¨å¥åº·æ£€æŸ¥
    registry.StartHealthChecker(30 * time.Second)

    // è·å–å®¢æˆ·ç«¯
    mysqlClient, _ := registry.GetClient(databases.MySQL)
    mongoClient, _ := registry.GetClient(databases.MongoDB)

    return mysqlClient.(*gorm.DB), mongoClient.(*mongo.Database), nil
}
```

## ğŸ¯ è®¾è®¡ä¼˜åŠ¿æ€»ç»“

### âœ… æ ¸å¿ƒä¼˜åŠ¿

1. **ç»Ÿä¸€ç®¡ç†**: æ‰€æœ‰æ•°æ®åº“è¿æ¥çš„é›†ä¸­åŒ–ç®¡ç†
2. **ç±»å‹å®‰å…¨**: é€šè¿‡æ¥å£å’Œç±»å‹ç³»ç»Ÿä¿è¯å®‰å…¨æ€§
3. **é…ç½®çµæ´»**: æ”¯æŒä¸åŒæ•°æ®åº“çš„ä¸ªæ€§åŒ–é…ç½®
4. **å¥åº·ç›‘æ§**: å®Œæ•´çš„å¥åº·æ£€æŸ¥å’Œç›‘æ§æœºåˆ¶
5. **ä¼˜é›…å…³é—­**: æ”¯æŒèµ„æºçš„ä¼˜é›…é‡Šæ”¾

### ğŸ”§ æŠ€æœ¯ç‰¹æ€§

1. **çº¿ç¨‹å®‰å…¨**: ä½¿ç”¨è¯»å†™é”ä¿æŠ¤å¹¶å‘è®¿é—®
2. **è¿æ¥æ± **: æ¯ç§æ•°æ®åº“éƒ½æœ‰ä¼˜åŒ–çš„è¿æ¥æ± é…ç½®
3. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
4. **æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„æ•°æ®åº“ç±»å‹æ”¯æŒ

### ğŸ“ˆ è¿ç»´ä»·å€¼

1. **æ•…éšœè¯Šæ–­**: å¿«é€Ÿå®šä½æ•°æ®åº“è¿æ¥é—®é¢˜
2. **æ€§èƒ½ç›‘æ§**: è¿æ¥æ± çŠ¶æ€å’Œæ€§èƒ½ç›‘æ§
3. **é…ç½®ç®¡ç†**: é›†ä¸­åŒ–çš„æ•°æ®åº“é…ç½®ç®¡ç†
4. **èµ„æºæ§åˆ¶**: ç²¾ç¡®æ§åˆ¶æ•°æ®åº“è¿æ¥èµ„æº

è¿™ç§æ•°æ®åº“æ³¨å†Œå™¨è®¾è®¡ä¸ºå¤šæ•°æ®æºåº”ç”¨æä¾›äº†ç¨³å®šã€é«˜æ•ˆã€å¯æ‰©å±•çš„æ•°æ®åº“è¿æ¥ç®¡ç†æ–¹æ¡ˆã€‚ 