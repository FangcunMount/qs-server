# ğŸ—„ï¸ æ•°æ®åº“æ³¨å†Œå™¨è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [æ³¨å†Œå™¨æ ¸å¿ƒæ¶æ„](#registry-core-architecture)
- [è¿æ¥ç®¡ç†ç­–ç•¥](#connection-management-strategy)
- [å¥åº·æ£€æŸ¥æœºåˆ¶](#health-check-mechanism)
- [å¤šæ•°æ®æºæ”¯æŒ](#multi-datasource-support)
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#practical-use-cases)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æ•°æ®åº“æ³¨å†Œå™¨æ˜¯ä¸€ä¸ªé›†ä¸­åŒ–çš„æ•°æ®åº“è¿æ¥ç®¡ç†ç³»ç»Ÿï¼Œé‡‡ç”¨**æ³¨å†Œå™¨æ¨¡å¼**å’Œ**å·¥å‚æ¨¡å¼**ï¼Œå®ç°äº†å¤šç§æ•°æ®åº“çš„ç»Ÿä¸€ç®¡ç†ã€è¿æ¥æ± ä¼˜åŒ–å’Œå¥åº·ç›‘æ§ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **ç»Ÿä¸€ç®¡ç†**: é›†ä¸­ç®¡ç†å¤šç§æ•°æ®åº“è¿æ¥
2. **ç±»å‹å®‰å…¨**: é€šè¿‡æ³›å‹å’Œæ¥å£ä¿è¯ç±»å‹å®‰å…¨
3. **è¿æ¥å¤ç”¨**: é«˜æ•ˆçš„è¿æ¥æ± ç®¡ç†
4. **å¥åº·ç›‘æ§**: å®æ—¶ç›‘æ§æ•°æ®åº“è¿æ¥çŠ¶æ€
5. **ä¼˜é›…å…³é—­**: æ”¯æŒä¼˜é›…çš„èµ„æºæ¸…ç†

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£**: ä¸“æ³¨äºæ•°æ®åº“è¿æ¥ç®¡ç†
- **å¼€é—­åŸåˆ™**: æ”¯æŒæ–°æ•°æ®åº“ç±»å‹æ‰©å±•
- **ä¾èµ–å€’ç½®**: åŸºäºæ¥å£è€Œéå…·ä½“å®ç°
- **çº¿ç¨‹å®‰å…¨**: æ”¯æŒå¹¶å‘è®¿é—®

## ğŸ›ï¸ æ³¨å†Œå™¨æ ¸å¿ƒæ¶æ„ {#registry-core-architecture}

### ğŸ“¦ æ ¸å¿ƒç»“æ„

```go
// pkg/database/registry.go

// Registry æ•°æ®åº“æ³¨å†Œå™¨
type Registry struct {
    mu          sync.RWMutex                           // è¯»å†™é”ä¿æŠ¤
    connections map[dbs.DatabaseType]dbs.Connection    // è¿æ¥æ˜ å°„
    configs     map[dbs.DatabaseType]interface{}       // é…ç½®æ˜ å°„
    initialized bool                                   // åˆå§‹åŒ–çŠ¶æ€
}
```

### ğŸ”§ æ•°æ®åº“ç±»å‹ä¸è¿æ¥æ¥å£

```go
// pkg/database/databases/connections.go

// DatabaseType æ•°æ®åº“ç±»å‹æšä¸¾
type DatabaseType string

const (
    MySQL   DatabaseType = "mysql"
    MongoDB DatabaseType = "mongodb"
    Redis   DatabaseType = "redis"
)

// Connection æ•°æ®åº“è¿æ¥æ¥å£
type Connection interface {
    Type() DatabaseType                    // è¿”å›æ•°æ®åº“ç±»å‹
    Connect() error                        // å»ºç«‹è¿æ¥
    Close() error                          // å…³é—­è¿æ¥
    GetClient() interface{}               // è·å–å®¢æˆ·ç«¯å®ä¾‹
    HealthCheck(ctx context.Context) error // å¥åº·æ£€æŸ¥
}
```

### ğŸš€ æ¶æ„æµç¨‹å›¾

```mermaid
graph TB
    subgraph "åº”ç”¨å±‚ Application"
        APP[åº”ç”¨ç¨‹åº]
        CONFIG[é…ç½®ç®¡ç†]
    end
    
    subgraph "æ³¨å†Œå™¨å±‚ Registry Layer"
        REGISTRY[Database Registry<br/>pkg/database/registry.go]
        FACTORY[Connection Factory]
    end
    
    subgraph "è¿æ¥å±‚ Connection Layer"
        MYSQL_CONN[MySQL Connection<br/>pkg/database/databases/mysql.go]
        MONGO_CONN[MongoDB Connection<br/>pkg/database/databases/mongo.go]
        REDIS_CONN[Redis Connection<br/>pkg/database/databases/redis.go]
    end
    
    subgraph "æ•°æ®åº“å±‚ Database Layer"
        MYSQL[(MySQL 8.0)]
        MONGODB[(MongoDB 6.0)]
        REDIS[(Redis 7.0)]
    end
    
    APP --> CONFIG
    APP --> REGISTRY
    CONFIG --> FACTORY
    REGISTRY --> FACTORY
    
    FACTORY --> MYSQL_CONN
    FACTORY --> MONGO_CONN
    FACTORY --> REDIS_CONN
    
    MYSQL_CONN --> MYSQL
    MONGO_CONN --> MONGODB
    REDIS_CONN --> REDIS
    
    style REGISTRY fill:#e3f2fd
    style MYSQL_CONN fill:#e8f5e8
    style MONGO_CONN fill:#fff3e0
    style REDIS_CONN fill:#f3e5f5
```

## ğŸ”— è¿æ¥ç®¡ç†ç­–ç•¥ {#connection-management-strategy}

### ğŸ“ æ³¨å†Œå™¨APIè®¾è®¡

#### 1. æ³¨å†Œå™¨åˆ›å»ºå’Œåˆå§‹åŒ–

```go
// NewRegistry åˆ›å»ºæ–°çš„æ•°æ®åº“æ³¨å†Œå™¨
func NewRegistry() *Registry {
    return &Registry{
        connections: make(map[dbs.DatabaseType]dbs.Connection),
        configs:     make(map[dbs.DatabaseType]interface{}),
    }
}

// Register æ³¨å†Œæ•°æ®åº“è¿æ¥
func (r *Registry) Register(dbType dbs.DatabaseType, config interface{}, connection dbs.Connection) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    // é˜²æ­¢é‡å¤åˆå§‹åŒ–åæ³¨å†Œ
    if r.initialized {
        return fmt.Errorf("registry already initialized, cannot register new connections")
    }

    // éªŒè¯è¿æ¥æœ‰æ•ˆæ€§
    if connection == nil {
        return fmt.Errorf("connection cannot be nil")
    }

    // éªŒè¯ç±»å‹åŒ¹é…
    if connection.Type() != dbType {
        return fmt.Errorf("connection type mismatch: expected %s, got %s", 
            dbType, connection.Type())
    }

    // å­˜å‚¨è¿æ¥å’Œé…ç½®
    r.connections[dbType] = connection
    r.configs[dbType] = config

    log.Printf("Registered database connection: %s", dbType)
    return nil
}
```

#### 2. è¿æ¥è·å–å’Œç®¡ç†

```go
// Get è·å–æŒ‡å®šç±»å‹çš„æ•°æ®åº“è¿æ¥
func (r *Registry) Get(dbType dbs.DatabaseType) (dbs.Connection, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    connection, exists := r.connections[dbType]
    if !exists {
        return nil, fmt.Errorf("database connection not found: %s", dbType)
    }

    return connection, nil
}

// GetClient è·å–æŒ‡å®šç±»å‹çš„æ•°æ®åº“å®¢æˆ·ç«¯
func (r *Registry) GetClient(dbType dbs.DatabaseType) (interface{}, error) {
    connection, err := r.Get(dbType)
    if err != nil {
        return nil, err
    }

    return connection.GetClient(), nil
}
```

#### 3. æ‰¹é‡åˆå§‹åŒ–

```go
// Init åˆå§‹åŒ–æ‰€æœ‰å·²æ³¨å†Œçš„æ•°æ®åº“è¿æ¥
func (r *Registry) Init() error {
    r.mu.Lock()
    defer r.mu.Unlock()

    if r.initialized {
        return nil
    }

    // é€ä¸ªåˆå§‹åŒ–æ•°æ®åº“è¿æ¥
    for dbType, connection := range r.connections {
        log.Printf("Initializing database connection: %s", dbType)
        if err := connection.Connect(); err != nil {
            return fmt.Errorf("failed to connect to %s: %w", dbType, err)
        }
    }

    r.initialized = true
    log.Println("All database connections initialized successfully")
    return nil
}
```

### ğŸ”„ è¿æ¥ç”Ÿå‘½å‘¨æœŸç®¡ç†

```mermaid
sequenceDiagram
    participant App as åº”ç”¨ç¨‹åº
    participant Registry as æ³¨å†Œå™¨
    participant MySQL as MySQLè¿æ¥
    participant MongoDB as MongoDBè¿æ¥
    participant Redis as Redisè¿æ¥
    
    App->>Registry: NewRegistry()
    App->>Registry: Register(MySQL, config, conn)
    App->>Registry: Register(MongoDB, config, conn)
    App->>Registry: Register(Redis, config, conn)
    
    App->>Registry: Init()
    Registry->>MySQL: Connect()
    MySQL-->>Registry: è¿æ¥æˆåŠŸ
    Registry->>MongoDB: Connect()
    MongoDB-->>Registry: è¿æ¥æˆåŠŸ
    Registry->>Redis: Connect()
    Redis-->>Registry: è¿æ¥æˆåŠŸ
    Registry-->>App: åˆå§‹åŒ–å®Œæˆ
    
    App->>Registry: Get(MySQL)
    Registry-->>App: MySQLè¿æ¥å®ä¾‹
    
    App->>Registry: HealthCheck()
    Registry->>MySQL: HealthCheck()
    Registry->>MongoDB: HealthCheck()
    Registry->>Redis: HealthCheck()
    
    App->>Registry: Close()
    Registry->>MySQL: Close()
    Registry->>MongoDB: Close()
    Registry->>Redis: Close()
```

## ğŸ’Š å¥åº·æ£€æŸ¥æœºåˆ¶ {#health-check-mechanism}

### ğŸ” å¥åº·æ£€æŸ¥å®ç°

```go
// HealthCheck å¯¹æ‰€æœ‰æ•°æ®åº“è¿æ¥è¿›è¡Œå¥åº·æ£€æŸ¥
func (r *Registry) HealthCheck(ctx context.Context) error {
    r.mu.RLock()
    defer r.mu.RUnlock()

    var errs []error

    // å¹¶å‘æ£€æŸ¥æ‰€æœ‰è¿æ¥
    for dbType, connection := range r.connections {
        if err := connection.HealthCheck(ctx); err != nil {
            errs = append(errs, fmt.Errorf("%s health check failed: %w", dbType, err))
        }
    }

    if len(errs) > 0 {
        return fmt.Errorf("database health check failed: %v", errs)
    }

    return nil
}
```

### ğŸ“Š å¥åº·æ£€æŸ¥ç­–ç•¥

#### 1. MySQLå¥åº·æ£€æŸ¥

```go
// pkg/database/databases/mysql.go

// HealthCheck MySQLå¥åº·æ£€æŸ¥
func (m *MySQLConnection) HealthCheck(ctx context.Context) error {
    if m.client == nil {
        return fmt.Errorf("mysql client is nil")
    }

    // è·å–åº•å±‚æ•°æ®åº“è¿æ¥
    sqlDB, err := m.client.DB()
    if err != nil {
        return fmt.Errorf("failed to get mysql db: %w", err)
    }

    // Pingæ£€æŸ¥
    if err := sqlDB.PingContext(ctx); err != nil {
        return fmt.Errorf("mysql ping failed: %w", err)
    }

    // è¿æ¥æ± çŠ¶æ€æ£€æŸ¥
    stats := sqlDB.Stats()
    if stats.OpenConnections == 0 {
        return fmt.Errorf("no open mysql connections")
    }

    return nil
}
```

#### 2. MongoDBå¥åº·æ£€æŸ¥

```go
// pkg/database/databases/mongo.go

// HealthCheck MongoDBå¥åº·æ£€æŸ¥  
func (m *MongoConnection) HealthCheck(ctx context.Context) error {
    if m.client == nil {
        return fmt.Errorf("mongodb client is nil")
    }

    // Pingæ£€æŸ¥
    if err := m.client.Ping(ctx, nil); err != nil {
        return fmt.Errorf("mongodb ping failed: %w", err)
    }

    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    if err := m.client.Connect(ctx); err != nil {
        return fmt.Errorf("mongodb connection check failed: %w", err)
    }

    return nil
}
```

#### 3. Rediså¥åº·æ£€æŸ¥

```go
// pkg/database/databases/redis.go

// HealthCheck Rediså¥åº·æ£€æŸ¥
func (r *RedisConnection) HealthCheck(ctx context.Context) error {
    if r.client == nil {
        return fmt.Errorf("redis client is nil")
    }

    // Pingæ£€æŸ¥
    pong, err := r.client.Ping(ctx).Result()
    if err != nil {
        return fmt.Errorf("redis ping failed: %w", err)
    }

    if pong != "PONG" {
        return fmt.Errorf("redis ping response invalid: %s", pong)
    }

    // è¿æ¥æ± çŠ¶æ€æ£€æŸ¥
    stats := r.client.PoolStats()
    if stats.TotalConns == 0 {
        return fmt.Errorf("no redis connections in pool")
    }

    return nil
}
```

## ğŸ”§ å¤šæ•°æ®æºæ”¯æŒ {#multi-datasource-support}

### ğŸ“Š MySQLè¿æ¥å®ç°

```go
// pkg/database/databases/mysql.go

// MySQLConfig MySQLæ•°æ®åº“é…ç½®
type MySQLConfig struct {
    Host                  string        `json:"host" mapstructure:"host"`
    Username              string        `json:"username" mapstructure:"username"`
    Password              string        `json:"password" mapstructure:"password"`
    Database              string        `json:"database" mapstructure:"database"`
    MaxIdleConnections    int           `json:"max-idle-connections" mapstructure:"max-idle-connections"`
    MaxOpenConnections    int           `json:"max-open-connections" mapstructure:"max-open-connections"`
    MaxConnectionLifeTime time.Duration `json:"max-connection-life-time" mapstructure:"max-connection-life-time"`
    LogLevel              int           `json:"log-level" mapstructure:"log-level"`
}

// MySQLConnection MySQLè¿æ¥å®ç°
type MySQLConnection struct {
    config *MySQLConfig
    client *gorm.DB
}

// Connect è¿æ¥MySQLæ•°æ®åº“
func (m *MySQLConnection) Connect() error {
    dsn := fmt.Sprintf("%s:%s@tcp(%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        m.config.Username,
        m.config.Password,
        m.config.Host,
        m.config.Database,
    )

    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.New(
            log.New(os.Stdout, "\r\n", log.LstdFlags),
            logger.Config{
                SlowThreshold: time.Second,
                LogLevel:      logger.LogLevel(m.config.LogLevel),
                Colorful:      true,
            },
        ),
    })
    if err != nil {
        return fmt.Errorf("failed to connect to mysql: %w", err)
    }

    // é…ç½®è¿æ¥æ± 
    sqlDB, err := db.DB()
    if err != nil {
        return fmt.Errorf("failed to get mysql db: %w", err)
    }

    sqlDB.SetMaxIdleConns(m.config.MaxIdleConnections)
    sqlDB.SetMaxOpenConns(m.config.MaxOpenConnections)
    sqlDB.SetConnMaxLifetime(m.config.MaxConnectionLifeTime)

    m.client = db
    return nil
}
```

### ğŸ“„ MongoDBè¿æ¥å®ç°

```go
// pkg/database/databases/mongo.go

// MongoConfig MongoDBé…ç½®
type MongoConfig struct {
    URI          string        `json:"uri" mapstructure:"uri"`
    Database     string        `json:"database" mapstructure:"database"`
    Timeout      time.Duration `json:"timeout" mapstructure:"timeout"`
    MaxPoolSize  uint64        `json:"max-pool-size" mapstructure:"max-pool-size"`
    MinPoolSize  uint64        `json:"min-pool-size" mapstructure:"min-pool-size"`
}

// MongoConnection MongoDBè¿æ¥å®ç°
type MongoConnection struct {
    config   *MongoConfig
    client   *mongo.Client
    database *mongo.Database
}

// Connect è¿æ¥MongoDB
func (m *MongoConnection) Connect() error {
    ctx, cancel := context.WithTimeout(context.Background(), m.config.Timeout)
    defer cancel()

    // å®¢æˆ·ç«¯é€‰é¡¹
    clientOptions := options.Client().
        ApplyURI(m.config.URI).
        SetMaxPoolSize(m.config.MaxPoolSize).
        SetMinPoolSize(m.config.MinPoolSize).
        SetMaxConnIdleTime(30 * time.Second)

    // è¿æ¥æ•°æ®åº“
    client, err := mongo.Connect(ctx, clientOptions)
    if err != nil {
        return fmt.Errorf("failed to connect to mongodb: %w", err)
    }

    // éªŒè¯è¿æ¥
    if err := client.Ping(ctx, nil); err != nil {
        return fmt.Errorf("failed to ping mongodb: %w", err)
    }

    m.client = client
    m.database = client.Database(m.config.Database)
    return nil
}
```

### ğŸ”´ Redisè¿æ¥å®ç°

```go
// pkg/database/databases/redis.go

// RedisConfig Redisé…ç½®
type RedisConfig struct {
    Addr         string        `json:"addr" mapstructure:"addr"`
    Password     string        `json:"password" mapstructure:"password"`
    DB           int           `json:"db" mapstructure:"db"`
    DialTimeout  time.Duration `json:"dial-timeout" mapstructure:"dial-timeout"`
    ReadTimeout  time.Duration `json:"read-timeout" mapstructure:"read-timeout"`
    WriteTimeout time.Duration `json:"write-timeout" mapstructure:"write-timeout"`
    PoolSize     int           `json:"pool-size" mapstructure:"pool-size"`
    MinIdleConns int           `json:"min-idle-conns" mapstructure:"min-idle-conns"`
}

// RedisConnection Redisè¿æ¥å®ç°
type RedisConnection struct {
    config *RedisConfig
    client *redis.Client
}

// Connect è¿æ¥Redis
func (r *RedisConnection) Connect() error {
    rdb := redis.NewClient(&redis.Options{
        Addr:         r.config.Addr,
        Password:     r.config.Password,
        DB:           r.config.DB,
        DialTimeout:  r.config.DialTimeout,
        ReadTimeout:  r.config.ReadTimeout,
        WriteTimeout: r.config.WriteTimeout,
        PoolSize:     r.config.PoolSize,
        MinIdleConns: r.config.MinIdleConns,
    })

    // éªŒè¯è¿æ¥
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := rdb.Ping(ctx).Err(); err != nil {
        return fmt.Errorf("failed to ping redis: %w", err)
    }

    r.client = rdb
    return nil
}
```

## ğŸ› ï¸ æ³¨å†Œå™¨å·¥å…·æ–¹æ³•

### ğŸ“‹ çŠ¶æ€æŸ¥è¯¢

```go
// ListRegistered åˆ—å‡ºæ‰€æœ‰å·²æ³¨å†Œçš„æ•°æ®åº“ç±»å‹
func (r *Registry) ListRegistered() []dbs.DatabaseType {
    r.mu.RLock()
    defer r.mu.RUnlock()

    types := make([]dbs.DatabaseType, 0, len(r.connections))
    for dbType := range r.connections {
        types = append(types, dbType)
    }

    return types
}

// IsRegistered æ£€æŸ¥æŒ‡å®šç±»å‹çš„æ•°æ®åº“æ˜¯å¦å·²æ³¨å†Œ
func (r *Registry) IsRegistered(dbType dbs.DatabaseType) bool {
    r.mu.RLock()
    defer r.mu.RUnlock()

    _, exists := r.connections[dbType]
    return exists
}

// IsInitialized æ£€æŸ¥æ³¨å†Œå™¨æ˜¯å¦å·²åˆå§‹åŒ–
func (r *Registry) IsInitialized() bool {
    r.mu.RLock()
    defer r.mu.RUnlock()

    return r.initialized
}
```

### ğŸ”’ ä¼˜é›…å…³é—­

```go
// Close å…³é—­æ‰€æœ‰æ•°æ®åº“è¿æ¥
func (r *Registry) Close() error {
    r.mu.Lock()
    defer r.mu.Unlock()

    var errs []error

    // é€ä¸ªå…³é—­è¿æ¥
    for dbType, connection := range r.connections {
        log.Printf("Closing database connection: %s", dbType)
        if err := connection.Close(); err != nil {
            errs = append(errs, fmt.Errorf("failed to close %s: %w", dbType, err))
        }
    }

    if len(errs) > 0 {
        return fmt.Errorf("errors closing databases: %v", errs)
    }

    r.initialized = false
    log.Println("All database connections closed successfully")
    return nil
}
```

## ğŸ“š å®é™…åº”ç”¨æ¡ˆä¾‹ {#practical-use-cases}

### ğŸ—ï¸ åœ¨APIæœåŠ¡å™¨ä¸­çš„ä½¿ç”¨

```go
// internal/apiserver/database.go

// æ•°æ®åº“åˆå§‹åŒ–
func initDatabases(cfg *config.Config) (*database.Registry, error) {
    registry := database.NewRegistry()

    // æ³¨å†ŒMySQLè¿æ¥
    if cfg.MySQLOptions != nil {
        mysqlConn := databases.NewMySQLConnection(cfg.MySQLOptions)
        if err := registry.Register(databases.MySQL, cfg.MySQLOptions, mysqlConn); err != nil {
            return nil, fmt.Errorf("failed to register mysql: %w", err)
        }
    }

    // æ³¨å†ŒMongoDBè¿æ¥
    if cfg.MongoDBOptions != nil {
        mongoConn := databases.NewMongoConnection(cfg.MongoDBOptions)
        if err := registry.Register(databases.MongoDB, cfg.MongoDBOptions, mongoConn); err != nil {
            return nil, fmt.Errorf("failed to register mongodb: %w", err)
        }
    }

    // æ³¨å†ŒRedisè¿æ¥
    if cfg.RedisOptions != nil {
        redisConn := databases.NewRedisConnection(cfg.RedisOptions)
        if err := registry.Register(databases.Redis, cfg.RedisOptions, redisConn); err != nil {
            return nil, fmt.Errorf("failed to register redis: %w", err)
        }
    }

    // åˆå§‹åŒ–æ‰€æœ‰è¿æ¥
    if err := registry.Init(); err != nil {
        return nil, fmt.Errorf("failed to initialize databases: %w", err)
    }

    return registry, nil
}
```

### ğŸ¯ åœ¨å®¹å™¨ä¸­çš„é›†æˆ

```go
// internal/apiserver/container/container.go

// Container ä¸»å®¹å™¨
type Container struct {
    registry    *database.Registry
    mysqlDB     *gorm.DB
    mongoClient *mongo.Client
    redisClient *redis.Client
}

// NewContainer åˆ›å»ºå®¹å™¨
func NewContainer(registry *database.Registry) (*Container, error) {
    container := &Container{registry: registry}

    // è·å–MySQLå®¢æˆ·ç«¯
    if registry.IsRegistered(databases.MySQL) {
        mysqlConn, err := registry.Get(databases.MySQL)
        if err != nil {
            return nil, fmt.Errorf("failed to get mysql connection: %w", err)
        }
        container.mysqlDB = mysqlConn.GetClient().(*gorm.DB)
    }

    // è·å–MongoDBå®¢æˆ·ç«¯
    if registry.IsRegistered(databases.MongoDB) {
        mongoConn, err := registry.Get(databases.MongoDB)
        if err != nil {
            return nil, fmt.Errorf("failed to get mongodb connection: %w", err)
        }
        container.mongoClient = mongoConn.GetClient().(*mongo.Client)
    }

    // è·å–Rediså®¢æˆ·ç«¯
    if registry.IsRegistered(databases.Redis) {
        redisConn, err := registry.Get(databases.Redis)
        if err != nil {
            return nil, fmt.Errorf("failed to get redis connection: %w", err)
        }
        container.redisClient = redisConn.GetClient().(*redis.Client)
    }

    return container, nil
}
```

### ğŸ”§ é…ç½®æ–‡ä»¶ç¤ºä¾‹

```yaml
# configs/apiserver.yaml
mysql:
  host: localhost:3306
  username: root
  password: password
  database: questionnaire_scale
  max-idle-connections: 10
  max-open-connections: 100
  max-connection-life-time: 10s
  log-level: 4

mongodb:
  uri: mongodb://localhost:27017
  database: questionnaire_scale
  timeout: 10s
  max-pool-size: 100
  min-pool-size: 10

redis:
  addr: localhost:6379
  password: ""
  db: 0
  dial-timeout: 5s
  read-timeout: 3s
  write-timeout: 3s
  pool-size: 10
  min-idle-conns: 5
```

## ğŸ¯ è®¾è®¡æ€»ç»“

æ•°æ®åº“æ³¨å†Œå™¨è®¾è®¡å®ç°äº†ï¼š

### 1. **ç»Ÿä¸€ç®¡ç†**

- å¤šç§æ•°æ®åº“ç±»å‹çš„ç»Ÿä¸€æ¥å£
- é›†ä¸­åŒ–çš„è¿æ¥é…ç½®å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- ä¸€è‡´çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•

### 2. **é«˜å¯ç”¨æ€§**

- å®Œå–„çš„å¥åº·æ£€æŸ¥æœºåˆ¶
- è¿æ¥æ± ä¼˜åŒ–é…ç½®
- ä¼˜é›…çš„æ•…éšœæ¢å¤

### 3. **æ˜“æ‰©å±•æ€§**

- åŸºäºæ¥å£çš„è®¾è®¡æ”¯æŒæ–°æ•°æ®åº“ç±»å‹
- æ’ä»¶åŒ–çš„è¿æ¥å®ç°
- é…ç½®é©±åŠ¨çš„è¿æ¥ç®¡ç†

### 4. **çº¿ç¨‹å®‰å…¨**

- è¯»å†™é”ä¿æŠ¤å¹¶å‘è®¿é—®
- åŸå­æ“ä½œä¿è¯æ•°æ®ä¸€è‡´æ€§
- æ— é”è®¾è®¡çš„æ€§èƒ½ä¼˜åŒ–

### 5. **ç”Ÿäº§å°±ç»ª**

- å®Œæ•´çš„é”™è¯¯å¤„ç†
- è¯¦ç»†çš„æ“ä½œæ—¥å¿—
- èµ„æºæ¸…ç†å’Œå†…å­˜ç®¡ç†

è¿™ç§è®¾è®¡ä¸ºæ„å»ºä¼ä¸šçº§åº”ç”¨çš„æ•°æ®å±‚æä¾›äº†åšå®çš„åŸºç¡€ã€‚
