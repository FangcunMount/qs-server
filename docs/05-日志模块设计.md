# ğŸ“ æ—¥å¿—æ¨¡å—è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [åŸºäºZapçš„æ—¥å¿—æ¶æ„](#zap-based-logging-architecture)
- [ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ—¥å¿—](#context-aware-logging)
- [ç»“æ„åŒ–æ—¥å¿—è®¾è®¡](#structured-logging-design)
- [æ—¥å¿—ä¸­é—´ä»¶ç³»ç»Ÿ](#logging-middleware-system)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#performance-optimization-strategies)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æœ¬é¡¹ç›®çš„æ—¥å¿—æ¨¡å—åŸºäº**Uber Zap**æ„å»ºäº†é«˜æ€§èƒ½ã€ç»“æ„åŒ–çš„æ—¥å¿—ç³»ç»Ÿï¼Œé‡‡ç”¨**ä¸Šä¸‹æ–‡æ„ŸçŸ¥**è®¾è®¡ï¼Œå®ç°äº†**é›¶åˆ†é…**çš„æ—¥å¿—è®°å½•å’Œ**çµæ´»çš„è¾“å‡ºæ ¼å¼**ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **é«˜æ€§èƒ½**: åŸºäºZapçš„é›¶åˆ†é…æ—¥å¿—è®°å½•
2. **ç»“æ„åŒ–**: æ”¯æŒé”®å€¼å¯¹çš„ç»“æ„åŒ–æ—¥å¿—
3. **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**: è‡ªåŠ¨æå–è¯·æ±‚ä¸Šä¸‹æ–‡ä¿¡æ¯
4. **å¤šçº§åˆ«**: æ”¯æŒDebugã€Infoã€Warnã€Errorã€Panicã€Fatalå…­ä¸ªçº§åˆ«
5. **å¤šæ ¼å¼**: æ”¯æŒJSONå’ŒConsoleä¸¤ç§è¾“å‡ºæ ¼å¼
6. **ä¸­é—´ä»¶é›†æˆ**: ä¸HTTPä¸­é—´ä»¶æ— ç¼é›†æˆ

### ğŸ¨ æ¶æ„è®¾è®¡åŸåˆ™

- **å•ä¾‹æ¨¡å¼**: å…¨å±€ç»Ÿä¸€çš„æ—¥å¿—å®ä¾‹
- **å·¥å‚æ¨¡å¼**: åŸºäºé…ç½®åˆ›å»ºä¸åŒçš„æ—¥å¿—å™¨
- **é€‚é…å™¨æ¨¡å¼**: å…¼å®¹æ ‡å‡†åº“logæ¥å£
- **ä¸Šä¸‹æ–‡æ¨¡å¼**: æ”¯æŒè¯·æ±‚é“¾è·¯è¿½è¸ª

## ğŸš€ åŸºäºZapçš„æ—¥å¿—æ¶æ„ {#zap-based-logging-architecture}

### ğŸ“¦ æ ¸å¿ƒç»“æ„

```go
// pkg/log/log.go

// Logger æ—¥å¿—æ¥å£å®šä¹‰
type Logger interface {
    // åŸºç¡€æ—¥å¿—æ–¹æ³•
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
    Panic(msg string, fields ...Field)
    Fatal(msg string, fields ...Field)
    
    // æ ¼å¼åŒ–æ—¥å¿—æ–¹æ³•
    Debugf(format string, v ...interface{})
    Infof(format string, v ...interface{})
    // ... å…¶ä»–æ ¼å¼åŒ–æ–¹æ³•
    
    // é”®å€¼å¯¹æ—¥å¿—æ–¹æ³•
    Debugw(msg string, keysAndValues ...interface{})
    Infow(msg string, keysAndValues ...interface{})
    // ... å…¶ä»–é”®å€¼å¯¹æ–¹æ³•
    
    // ä¸Šä¸‹æ–‡å’Œé…ç½®æ–¹æ³•
    V(level Level) InfoLogger
    WithValues(keysAndValues ...interface{}) Logger
    WithName(name string) Logger
    WithContext(ctx context.Context) context.Context
    Flush()
}

// zapLogger åŸºäºZapçš„æ—¥å¿—å®ç°
type zapLogger struct {
    zapLogger *zap.Logger    // åº•å±‚Zapæ—¥å¿—å™¨
    infoLogger               // åµŒå…¥InfoLogger
}
```

### ğŸ”§ æ—¥å¿—å™¨å·¥å‚

```go
// New åˆ›å»ºæ—¥å¿—å™¨
func New(opts *Options) *zapLogger {
    if opts == nil {
        opts = NewOptions()
    }

    // è§£ææ—¥å¿—çº§åˆ«
    var zapLevel zapcore.Level
    if err := zapLevel.UnmarshalText([]byte(opts.Level)); err != nil {
        zapLevel = zapcore.InfoLevel
    }

    // é…ç½®ç¼–ç å™¨
    encoderConfig := zapcore.EncoderConfig{
        MessageKey:     "message",
        LevelKey:       "level",
        TimeKey:        "timestamp",
        NameKey:        "logger",
        CallerKey:      "caller",
        StacktraceKey:  "stacktrace",
        LineEnding:     zapcore.DefaultLineEnding,
        EncodeLevel:    encodeLevel,
        EncodeTime:     timeEncoder,
        EncodeDuration: milliSecondsDurationEncoder,
        EncodeCaller:   zapcore.ShortCallerEncoder,
    }

    // æ„å»ºZapé…ç½®
    loggerConfig := &zap.Config{
        Level:             zap.NewAtomicLevelAt(zapLevel),
        Development:       opts.Development,
        DisableCaller:     opts.DisableCaller,
        DisableStacktrace: opts.DisableStacktrace,
        Sampling: &zap.SamplingConfig{
            Initial:    100,
            Thereafter: 100,
        },
        Encoding:         opts.Format,
        EncoderConfig:    encoderConfig,
        OutputPaths:      opts.OutputPaths,
        ErrorOutputPaths: opts.ErrorOutputPaths,
    }

    // åˆ›å»ºZapæ—¥å¿—å™¨
    l, err := loggerConfig.Build(
        zap.AddStacktrace(zapcore.PanicLevel), 
        zap.AddCallerSkip(1),
    )
    if err != nil {
        panic(err)
    }

    logger := &zapLogger{
        zapLogger: l.Named(opts.Name),
        infoLogger: infoLogger{
            log:   l,
            level: zap.InfoLevel,
        },
    }

    // é›†æˆklog
    klog.InitLogger(l)
    zap.RedirectStdLog(l)

    return logger
}
```

### âš™ï¸ é…ç½®é€‰é¡¹è®¾è®¡

```go
// pkg/log/options.go

// Options æ—¥å¿—é…ç½®é€‰é¡¹
type Options struct {
    Level               string   `json:"level" mapstructure:"level"`                               // æ—¥å¿—çº§åˆ«
    Format              string   `json:"format" mapstructure:"format"`                           // è¾“å‡ºæ ¼å¼
    EnableColor         bool     `json:"enable-color" mapstructure:"enable-color"`               // å¯ç”¨é¢œè‰²
    DisableCaller       bool     `json:"disable-caller" mapstructure:"disable-caller"`           // ç¦ç”¨è°ƒç”¨è€…ä¿¡æ¯
    DisableStacktrace   bool     `json:"disable-stacktrace" mapstructure:"disable-stacktrace"`   // ç¦ç”¨å †æ ˆè·Ÿè¸ª
    OutputPaths         []string `json:"output-paths" mapstructure:"output-paths"`               // è¾“å‡ºè·¯å¾„
    ErrorOutputPaths    []string `json:"error-output-paths" mapstructure:"error-output-paths"`   // é”™è¯¯è¾“å‡ºè·¯å¾„
    Development         bool     `json:"development" mapstructure:"development"`                 // å¼€å‘æ¨¡å¼
    Name                string   `json:"name" mapstructure:"name"`                               // æ—¥å¿—å™¨åç§°
}

// NewOptions åˆ›å»ºé»˜è®¤é…ç½®
func NewOptions() *Options {
    return &Options{
        Level:               "info",
        Format:              "console",
        EnableColor:         true,
        DisableCaller:       false,
        DisableStacktrace:   true,
        OutputPaths:         []string{"stdout"},
        ErrorOutputPaths:    []string{"stderr"},
        Development:         false,
        Name:                "",
    }
}
```

## ğŸŒ ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ—¥å¿— {#context-aware-logging}

### ğŸ“ ä¸Šä¸‹æ–‡æ—¥å¿—è®¾è®¡

æ—¥å¿—ç³»ç»Ÿçš„æ ¸å¿ƒç‰¹æ€§æ˜¯**ä¸Šä¸‹æ–‡æ„ŸçŸ¥**ï¼Œèƒ½è‡ªåŠ¨ä»è¯·æ±‚ä¸Šä¸‹æ–‡ä¸­æå–ä¿¡æ¯ï¼ˆå¦‚RequestIDã€Usernameç­‰ï¼‰å¹¶æ·»åŠ åˆ°æ—¥å¿—ä¸­ã€‚

#### 1. ä¸Šä¸‹æ–‡Loggerè·å–

```go
// L ä»ä¸Šä¸‹æ–‡è·å–Logger
func L(ctx context.Context) *zapLogger {
    return std.L(ctx)
}

func (l *zapLogger) L(ctx context.Context) *zapLogger {
    if ctx == nil {
        return l
    }

    // å…‹éš†Loggeré¿å…å¹¶å‘é—®é¢˜
    logger := l.clone()

    // ä»ä¸Šä¸‹æ–‡æå–å­—æ®µ
    fields := make([]zap.Field, 0)

    // æå–RequestID
    if requestID := getRequestIDFromContext(ctx); requestID != "" {
        fields = append(fields, zap.String("requestID", requestID))
    }

    // æå–Username
    if username := getUsernameFromContext(ctx); username != "" {
        fields = append(fields, zap.String("username", username))
    }

    // æå–å…¶ä»–ä¸Šä¸‹æ–‡å­—æ®µ
    if traceID := getTraceIDFromContext(ctx); traceID != "" {
        fields = append(fields, zap.String("traceID", traceID))
    }

    if len(fields) > 0 {
        logger.zapLogger = logger.zapLogger.With(fields...)
    }

    return logger
}
```

#### 2. ä¸Šä¸‹æ–‡å­—æ®µæå–

```go
// ä»Gin Contextæå–RequestID
func getRequestIDFromContext(ctx context.Context) string {
    if ginCtx, ok := ctx.(*gin.Context); ok {
        if requestID, exists := ginCtx.Get("X-Request-ID"); exists {
            if id, ok := requestID.(string); ok {
                return id
            }
        }
    }
    return ""
}

// ä»Contextæå–Username
func getUsernameFromContext(ctx context.Context) string {
    if ginCtx, ok := ctx.(*gin.Context); ok {
        if username, exists := ginCtx.Get("X-Username"); exists {
            if name, ok := username.(string); ok {
                return name
            }
        }
    }
    return ""
}
```

### ğŸ”„ ä¸Šä¸‹æ–‡ä¼ æ’­æœºåˆ¶

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant MW as ä¸­é—´ä»¶
    participant Gin as Gin Context
    participant Log as æ—¥å¿—ç³»ç»Ÿ
    participant Handler as ä¸šåŠ¡å¤„ç†å™¨
    
    Client->>MW: HTTPè¯·æ±‚
    MW->>Gin: ç”ŸæˆRequestID
    Gin->>Gin: è®¾ç½®X-Request-ID
    MW->>MW: è®¤è¯ç”¨æˆ·
    MW->>Gin: è®¾ç½®X-Username
    
    Gin->>Handler: è°ƒç”¨ä¸šåŠ¡é€»è¾‘
    Handler->>Log: log.L(ctx).Info("å¤„ç†è¯·æ±‚")
    Log->>Gin: æå–X-Request-ID
    Log->>Gin: æå–X-Username
    Log->>Log: ç”Ÿæˆç»“æ„åŒ–æ—¥å¿—
    Log-->>Handler: è®°å½•å®Œæˆ
    
    note over Log: æ—¥å¿—è¾“å‡ºåŒ…å«<br/>requestIDå’Œusername
```

## ğŸ—ï¸ ç»“æ„åŒ–æ—¥å¿—è®¾è®¡ {#structured-logging-design}

### ğŸ“Š å­—æ®µç±»å‹ç³»ç»Ÿ

```go
// pkg/log/types.go

// Field æ—¥å¿—å­—æ®µç±»å‹åˆ«å
type Field = zap.Field

// Level æ—¥å¿—çº§åˆ«ç±»å‹
type Level = zapcore.Level

// ä¾¿æ·å­—æ®µæ„é€ å‡½æ•°
func String(key, val string) Field {
    return zap.String(key, val)
}

func Int(key string, val int) Field {
    return zap.Int(key, val)
}

func Int64(key string, val int64) Field {
    return zap.Int64(key, val)
}

func Bool(key string, val bool) Field {
    return zap.Bool(key, val)
}

func Error(err error) Field {
    return zap.Error(err)
}

func Duration(key string, val time.Duration) Field {
    return zap.Duration(key, val)
}

func Any(key string, val interface{}) Field {
    return zap.Any(key, val)
}
```

### ğŸ“ å¤šç§æ—¥å¿—è®°å½•æ–¹å¼

#### 1. ç»“æ„åŒ–å­—æ®µæ—¥å¿—

```go
// ä½¿ç”¨ç»“æ„åŒ–å­—æ®µ
log.Info("ç”¨æˆ·ç™»å½•æˆåŠŸ", 
    String("username", "alice"),
    String("ip", "192.168.1.100"),
    Duration("duration", time.Millisecond*150),
    Int("status_code", 200),
)

// è¾“å‡º (JSONæ ¼å¼):
// {
//   "level": "info",
//   "timestamp": "2024-01-15T10:30:00.123Z",
//   "message": "ç”¨æˆ·ç™»å½•æˆåŠŸ",
//   "username": "alice",
//   "ip": "192.168.1.100", 
//   "duration": "150ms",
//   "status_code": 200
// }
```

#### 2. æ ¼å¼åŒ–å­—ç¬¦ä¸²æ—¥å¿—

```go
// ä½¿ç”¨æ ¼å¼åŒ–å­—ç¬¦ä¸²
log.Infof("ç”¨æˆ· %s ä» %s ç™»å½•æˆåŠŸï¼Œè€—æ—¶ %v", 
    "alice", "192.168.1.100", time.Millisecond*150)

// è¾“å‡º:
// 2024-01-15 10:30:00.123  INFO  ç”¨æˆ· alice ä» 192.168.1.100 ç™»å½•æˆåŠŸï¼Œè€—æ—¶ 150ms
```

#### 3. é”®å€¼å¯¹æ—¥å¿—

```go
// ä½¿ç”¨é”®å€¼å¯¹
log.Infow("ç”¨æˆ·ç™»å½•æˆåŠŸ",
    "username", "alice",
    "ip", "192.168.1.100",
    "duration", time.Millisecond*150,
    "status_code", 200,
)
```

### ğŸ¨ è‡ªå®šä¹‰ç¼–ç å™¨

```go
// æ—¶é—´ç¼–ç å™¨
func timeEncoder(t time.Time, enc zapcore.PrimitiveArrayEncoder) {
    enc.AppendString(t.Format("2006-01-02 15:04:05.000"))
}

// æ¯«ç§’æŒç»­æ—¶é—´ç¼–ç å™¨
func milliSecondsDurationEncoder(d time.Duration, enc zapcore.PrimitiveArrayEncoder) {
    enc.AppendFloat64(float64(d) / float64(time.Millisecond))
}

// å½©è‰²çº§åˆ«ç¼–ç å™¨
func colorLevelEncoder(level zapcore.Level, enc zapcore.PrimitiveArrayEncoder) {
    switch level {
    case zapcore.DebugLevel:
        enc.AppendString("ğŸ› DEBUG")
    case zapcore.InfoLevel:
        enc.AppendString("â„¹ï¸ INFO")
    case zapcore.WarnLevel:
        enc.AppendString("âš ï¸ WARN")
    case zapcore.ErrorLevel:
        enc.AppendString("âŒ ERROR")
    case zapcore.PanicLevel:
        enc.AppendString("ğŸ’¥ PANIC")
    case zapcore.FatalLevel:
        enc.AppendString("ğŸ’€ FATAL")
    }
}
```

## ğŸŒ æ—¥å¿—ä¸­é—´ä»¶ç³»ç»Ÿ {#logging-middleware-system}

### ğŸ“ HTTPæ—¥å¿—ä¸­é—´ä»¶

æ—¥å¿—ä¸­é—´ä»¶è´Ÿè´£è®°å½•HTTPè¯·æ±‚çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¹¶å°†ä¸Šä¸‹æ–‡ä¿¡æ¯æ³¨å…¥åˆ°åç»­çš„æ—¥å¿—ä¸­ã€‚

#### 1. åŸºç¡€æ—¥å¿—ä¸­é—´ä»¶

```go
// internal/pkg/middleware/logger.go

// Logger æ—¥å¿—ä¸­é—´ä»¶
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        raw := c.Request.URL.RawQuery

        // å¤„ç†è¯·æ±‚
        c.Next()

        // è®¡ç®—è€—æ—¶
        latency := time.Since(start)
        
        // è·å–ä¸Šä¸‹æ–‡ç›¸å…³çš„æ—¥å¿—å™¨
        logger := log.L(c)
        
        // è®°å½•è¯·æ±‚æ—¥å¿—
        if raw != "" {
            path = path + "?" + raw
        }

        logger.Infow("HTTPè¯·æ±‚å¤„ç†å®Œæˆ",
            "method", c.Request.Method,
            "path", path,
            "status", c.Writer.Status(),
            "latency", latency,
            "client_ip", c.ClientIP(),
            "user_agent", c.Request.UserAgent(),
            "body_size", c.Writer.Size(),
        )
    }
}
```

#### 2. å¢å¼ºæ—¥å¿—ä¸­é—´ä»¶

```go
// internal/pkg/middleware/enhanced_logger.go

// EnhancedLogger å¢å¼ºæ—¥å¿—ä¸­é—´ä»¶
func EnhancedLogger() gin.HandlerFunc {
    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        var statusColor, methodColor, resetColor string
        if param.IsOutputColor() {
            statusColor = param.StatusCodeColor()
            methodColor = param.MethodColor()
            resetColor = param.ResetColor()
        }

        if param.Latency > time.Minute {
            param.Latency = param.Latency.Truncate(time.Second)
        }

        // ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—è®°å½•
        log.L(param.Keys).Infow("HTTPè¯·æ±‚",
            "timestamp", param.TimeStamp.Format("2006/01/02 - 15:04:05"),
            "status", param.StatusCode,
            "method", param.Method,
            "path", param.Path,
            "latency", param.Latency,
            "client_ip", param.ClientIP,
            "error", param.ErrorMessage,
        )

        return fmt.Sprintf("%v |%s %3d %s| %13v | %15s |%s %-7s %s %#v\n%s",
            param.TimeStamp.Format("2006/01/02 - 15:04:05"),
            statusColor, param.StatusCode, resetColor,
            param.Latency,
            param.ClientIP,
            methodColor, param.Method, resetColor,
            param.Path,
            param.ErrorMessage,
        )
    })
}
```

### ğŸ”§ SQLæ—¥å¿—è®°å½•

```go
// pkg/logger/sql.go

// SQLLogger GORMæ—¥å¿—é€‚é…å™¨
type SQLLogger struct {
    logger *zap.Logger
}

// NewSQLLogger åˆ›å»ºSQLæ—¥å¿—å™¨
func NewSQLLogger(logger *zap.Logger) *SQLLogger {
    return &SQLLogger{logger: logger}
}

// LogMode è®¾ç½®æ—¥å¿—æ¨¡å¼
func (l *SQLLogger) LogMode(level logger.LogLevel) logger.Interface {
    return l
}

// Info è®°å½•ä¿¡æ¯æ—¥å¿—
func (l *SQLLogger) Info(ctx context.Context, msg string, data ...interface{}) {
    l.logger.Sugar().Infof(msg, data...)
}

// Warn è®°å½•è­¦å‘Šæ—¥å¿—
func (l *SQLLogger) Warn(ctx context.Context, msg string, data ...interface{}) {
    l.logger.Sugar().Warnf(msg, data...)
}

// Error è®°å½•é”™è¯¯æ—¥å¿—
func (l *SQLLogger) Error(ctx context.Context, msg string, data ...interface{}) {
    l.logger.Sugar().Errorf(msg, data...)
}

// Trace è®°å½•SQLæ‰§è¡Œè·Ÿè¸ª
func (l *SQLLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) {
    elapsed := time.Since(begin)
    sql, rows := fc()
    
    fields := []zap.Field{
        zap.String("sql", sql),
        zap.Duration("elapsed", elapsed),
        zap.Int64("rows", rows),
    }
    
    if err != nil {
        fields = append(fields, zap.Error(err))
        l.logger.Error("SQLæ‰§è¡Œé”™è¯¯", fields...)
    } else if elapsed > 200*time.Millisecond {
        l.logger.Warn("æ…¢SQLæŸ¥è¯¢", fields...)
    } else {
        l.logger.Debug("SQLæ‰§è¡Œ", fields...)
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ {#performance-optimization-strategies}

### ğŸš€ é›¶åˆ†é…ä¼˜åŒ–

#### 1. å­—æ®µé¢„åˆ†é…

```go
// é¿å…: é¢‘ç¹åˆ†é…ä¸´æ—¶å­—æ®µ
func logUserAction(userID int64, action string, details map[string]interface{}) {
    // æ¯æ¬¡è°ƒç”¨éƒ½ä¼šåˆ†é…æ–°çš„slice
    fields := []zap.Field{
        zap.Int64("user_id", userID),
        zap.String("action", action),
    }
    for k, v := range details {
        fields = append(fields, zap.Any(k, v))
    }
    log.Info("ç”¨æˆ·æ“ä½œ", fields...)
}

// ä¼˜åŒ–: ä½¿ç”¨é¢„åˆ†é…çš„å­—æ®µåˆ‡ç‰‡
func logUserActionOptimized(userID int64, action string, details map[string]interface{}) {
    // é¢„åˆ†é…å®¹é‡ï¼Œå‡å°‘å†…å­˜åˆ†é…
    fields := make([]zap.Field, 0, 2+len(details))
    fields = append(fields,
        zap.Int64("user_id", userID),
        zap.String("action", action),
    )
    for k, v := range details {
        fields = append(fields, zap.Any(k, v))
    }
    log.Info("ç”¨æˆ·æ“ä½œ", fields...)
}
```

#### 2. å­—ç¬¦ä¸²æ± ä¼˜åŒ–

```go
// å­—ç¬¦ä¸²ç¼“å­˜æ± 
var stringPool = sync.Pool{
    New: func() interface{} {
        return make([]string, 0, 10)
    },
}

// å¤ç”¨å­—ç¬¦ä¸²åˆ‡ç‰‡
func logWithStringPool(messages []string) {
    strs := stringPool.Get().([]string)
    defer stringPool.Put(strs[:0])
    
    for _, msg := range messages {
        log.Info("æ‰¹é‡æ—¥å¿—", zap.String("message", msg))
    }
}
```

### ğŸ“Š å¼‚æ­¥æ—¥å¿—è®°å½•

```go
// å¼‚æ­¥æ—¥å¿—ç¼“å†²åŒº
type AsyncLogger struct {
    logger   *zapLogger
    buffer   chan LogEntry
    batchSize int
    ticker   *time.Ticker
}

type LogEntry struct {
    Level   zapcore.Level
    Message string
    Fields  []zap.Field
}

// NewAsyncLogger åˆ›å»ºå¼‚æ­¥æ—¥å¿—å™¨
func NewAsyncLogger(logger *zapLogger, bufferSize, batchSize int, flushInterval time.Duration) *AsyncLogger {
    al := &AsyncLogger{
        logger:    logger,
        buffer:    make(chan LogEntry, bufferSize),
        batchSize: batchSize,
        ticker:    time.NewTicker(flushInterval),
    }
    
    go al.flushLoop()
    return al
}

// å¼‚æ­¥åˆ·æ–°å¾ªç¯
func (al *AsyncLogger) flushLoop() {
    batch := make([]LogEntry, 0, al.batchSize)
    
    for {
        select {
        case entry := <-al.buffer:
            batch = append(batch, entry)
            if len(batch) >= al.batchSize {
                al.flushBatch(batch)
                batch = batch[:0]
            }
        case <-al.ticker.C:
            if len(batch) > 0 {
                al.flushBatch(batch)
                batch = batch[:0]
            }
        }
    }
}

// æ‰¹é‡åˆ·æ–°æ—¥å¿—
func (al *AsyncLogger) flushBatch(batch []LogEntry) {
    for _, entry := range batch {
        switch entry.Level {
        case zapcore.InfoLevel:
            al.logger.Info(entry.Message, entry.Fields...)
        case zapcore.WarnLevel:
            al.logger.Warn(entry.Message, entry.Fields...)
        case zapcore.ErrorLevel:
            al.logger.Error(entry.Message, entry.Fields...)
        }
    }
}
```

### ğŸ” æ¡ä»¶æ—¥å¿—è®°å½•

```go
// æ¡ä»¶æ—¥å¿—è®°å½•é¿å…ä¸å¿…è¦çš„å­—ç¬¦ä¸²æ ¼å¼åŒ–
func ConditionalLog(condition bool, level zapcore.Level, msg string, fields ...zap.Field) {
    if !log.CheckIntLevel(int32(level)) {
        return // æ—¥å¿—çº§åˆ«ä¸æ»¡è¶³ï¼Œç›´æ¥è¿”å›
    }
    
    if condition {
        switch level {
        case zapcore.DebugLevel:
            log.Debug(msg, fields...)
        case zapcore.InfoLevel:
            log.Info(msg, fields...)
        case zapcore.WarnLevel:
            log.Warn(msg, fields...)
        case zapcore.ErrorLevel:
            log.Error(msg, fields...)
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
ConditionalLog(user.IsVIP(), zapcore.InfoLevel, "VIPç”¨æˆ·æ“ä½œ",
    zap.String("username", user.Username),
    zap.String("action", "premium_feature_access"),
)
```

## ğŸ“š å®é™…åº”ç”¨ç¤ºä¾‹

### ğŸ”§ åœ¨ä¸šåŠ¡ä»£ç ä¸­çš„ä½¿ç”¨

```go
// internal/apiserver/application/user/creator.go

func (c *UserCreator) CreateUser(ctx context.Context, req port.UserCreateRequest) (*port.UserResponse, error) {
    // è·å–ä¸Šä¸‹æ–‡ç›¸å…³çš„æ—¥å¿—å™¨
    logger := log.L(ctx)
    
    // è®°å½•ä¸šåŠ¡å¼€å§‹
    logger.Infow("å¼€å§‹åˆ›å»ºç”¨æˆ·",
        "username", req.Username,
        "email", req.Email,
    )
    
    // ä¸šåŠ¡é€»è¾‘éªŒè¯
    if c.usernameExists(ctx, req.Username) {
        logger.Warnw("ç”¨æˆ·åå·²å­˜åœ¨",
            "username", req.Username,
        )
        return nil, errors.WithCode(code.ErrUserAlreadyExists, "username already exists")
    }
    
    // åˆ›å»ºç”¨æˆ·
    user := user.NewUserBuilder().
        WithUsername(req.Username).
        WithPassword(req.Password).
        WithEmail(req.Email).
        Build()
    
    // ä¿å­˜ç”¨æˆ·
    start := time.Now()
    if err := c.userRepo.Save(ctx, user); err != nil {
        logger.Errorw("ç”¨æˆ·ä¿å­˜å¤±è´¥",
            "username", req.Username,
            "error", err,
            "duration", time.Since(start),
        )
        return nil, fmt.Errorf("failed to save user: %w", err)
    }
    
    // è®°å½•æˆåŠŸ
    logger.Infow("ç”¨æˆ·åˆ›å»ºæˆåŠŸ",
        "user_id", user.ID().Value(),
        "username", user.Username(),
        "duration", time.Since(start),
    )
    
    return &port.UserResponse{
        ID:       user.ID().Value(),
        Username: user.Username(),
        // ... å…¶ä»–å­—æ®µ
    }, nil
}
```

### ğŸ“Š æ—¥å¿—è¾“å‡ºç¤ºä¾‹

#### JSONæ ¼å¼è¾“å‡º

```json
{
  "level": "info",
  "timestamp": "2024-01-15T10:30:00.123Z",
  "requestID": "req-123456789",
  "username": "alice",
  "message": "ç”¨æˆ·åˆ›å»ºæˆåŠŸ",
  "user_id": 12345,
  "username": "bob",
  "duration": 45.6,
  "caller": "user/creator.go:89"
}
```

#### Consoleæ ¼å¼è¾“å‡º

```text
2024-01-15 10:30:00.123  INFO  [req-123456789] [alice] ç”¨æˆ·åˆ›å»ºæˆåŠŸ  user_id=12345 username=bob duration=45.6ms  user/creator.go:89
```

## ğŸ¯ è®¾è®¡æ€»ç»“

æ—¥å¿—æ¨¡å—è®¾è®¡å®ç°äº†ï¼š

### 1. **é«˜æ€§èƒ½æ¶æ„**

- åŸºäºZapçš„é›¶åˆ†é…æ—¥å¿—è®°å½•
- å¼‚æ­¥æ—¥å¿—æ‰¹é‡å¤„ç†
- æ¡ä»¶æ—¥å¿—é¿å…ä¸å¿…è¦å¼€é”€

### 2. **ç»“æ„åŒ–è®¾è®¡**

- ç»Ÿä¸€çš„å­—æ®µç±»å‹ç³»ç»Ÿ
- å¤šç§æ—¥å¿—è®°å½•æ–¹å¼
- è‡ªå®šä¹‰ç¼–ç å™¨æ”¯æŒ

### 3. **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**

- è‡ªåŠ¨æå–è¯·æ±‚ä¸Šä¸‹æ–‡
- é“¾è·¯è¿½è¸ªä¿¡æ¯ä¼ æ’­
- ç”¨æˆ·èº«ä»½å…³è”

### 4. **çµæ´»é…ç½®**

- å¤šç§è¾“å‡ºæ ¼å¼æ”¯æŒ
- å¯é…ç½®çš„æ—¥å¿—çº§åˆ«
- åŠ¨æ€è¾“å‡ºè·¯å¾„

### 5. **ç”Ÿäº§å°±ç»ª**

- å®Œæ•´çš„é”™è¯¯å¤„ç†
- ä¼˜é›…çš„èµ„æºç®¡ç†
- æ€§èƒ½ç›‘æ§æ”¯æŒ

è¿™ç§è®¾è®¡ä¸ºæ„å»ºå¯è§‚æµ‹æ€§å¼ºçš„ä¼ä¸šçº§åº”ç”¨æä¾›äº†åšå®åŸºç¡€ã€‚
