# 架构决策：独立 Sync 服务 vs Crontab

> **版本**：V1.0  
> **更新日期**：2025-01-XX  
> **决策状态**：✅ 已决策

## 问题

是否有必要独立 `qs-sync` 服务组件？

## 当前情况

### 方案A：独立 Sync 服务（已实现）

```text
┌─────────────┐
│  Sync服务    │
│  (Cron)     │
└──────┬──────┘
       │ gRPC
       ▼
┌─────────────┐
│  APIServer  │
│  (业务服务) │
└─────────────┘
```

**特点**：

- 独立服务，使用内置 Cron 调度器
- 通过 gRPC 调用 apiserver 的内部接口
- 需要维护独立的代码、配置、部署

### 方案B：Crontab + HTTP 接口（已实现）

```text
Crontab/Systemd Timer/Kubernetes CronJob
    │
    ▼
直接调用业务HTTP接口
    │
    ▼
业务Handler（PlanHandler/StatisticsHandler等）
    │
    ▼
应用服务层（TaskSchedulerService/SyncService等）
```

**特点**：

- 使用外部 Crontab 工具
- 直接调用 apiserver 的 REST API
- 业务逻辑集中在 apiserver

## 对比分析

| 维度 | 独立 Sync 服务 | Crontab + HTTP |
|------|--------------|----------------|
| **复杂度** | 高（需要独立服务、gRPC 客户端、配置） | 低（只需配置 Crontab） |
| **部署成本** | 高（需要额外的容器/进程） | 低（利用操作系统能力） |
| **维护成本** | 高（需要维护两套代码） | 低（只需维护业务接口） |
| **资源消耗** | 高（独立进程、gRPC 连接） | 低（按需调用） |
| **职责分离** | ✅ 好（定时任务独立） | ⚠️ 一般（定时任务在 apiserver） |
| **资源隔离** | ✅ 好（不影响 API 性能） | ⚠️ 一般（可能影响 API） |
| **扩展性** | ✅ 好（可独立扩展） | ⚠️ 一般（依赖 apiserver） |
| **监控** | ✅ 好（独立日志和监控） | ⚠️ 一般（日志在 apiserver） |
| **容器友好** | ⚠️ 一般（需要额外容器） | ✅ 好（Kubernetes CronJob） |
| **简单性** | ❌ 复杂 | ✅ 简单 |
| **成熟度** | ⚠️ 需要自己实现 | ✅ 成熟稳定 |

## 业务场景分析

### 当前定时任务

1. **统计同步**（每小时）
   - 同步每日统计：Redis → MySQL
   - 同步累计统计：Redis → MySQL
   - 同步计划统计：Redis → MySQL
   - 校验数据一致性：Redis vs MySQL

2. **计划任务调度**（每小时）
   - 扫描待推送任务
   - 生成入口并开放

### 任务特点

- **执行频率**：每小时一次（低频）
- **执行时间**：通常几秒到几十秒（短时间）
- **资源消耗**：中等（数据库操作）
- **业务逻辑**：全部在 apiserver 中
- **依赖关系**：需要访问 MySQL、Redis

## 决策建议

### 推荐：使用 Crontab + HTTP 接口

**理由**：

1. **简单直接**
   - 不需要额外的服务组件
   - 利用成熟的 Crontab 工具
   - 配置简单，易于理解

2. **业务逻辑集中**
   - 所有业务逻辑都在 apiserver 中
   - 不需要通过 gRPC 调用
   - 减少网络开销

3. **容器友好**
   - Kubernetes CronJob 是标准做法
   - 容器编排工具原生支持
   - 易于监控和告警

4. **维护成本低**
   - 不需要维护独立的 sync 服务
   - 不需要维护 gRPC 客户端代码
   - 减少部署复杂度

5. **资源消耗低**
   - 不需要常驻进程
   - 按需执行，用完即走
   - 不占用额外资源

### 独立 Sync 服务的适用场景

独立 Sync 服务适合以下场景：

1. **高频任务**（每分钟或更频繁）
   - 需要常驻进程避免启动开销
   - 需要连接池复用

2. **复杂调度逻辑**
   - 需要动态调整调度策略
   - 需要任务依赖管理
   - 需要任务重试和失败处理

3. **大量定时任务**
   - 任务数量多（几十个以上）
   - 需要统一管理和监控
   - 需要任务编排

4. **资源隔离要求高**
   - 定时任务可能影响 API 性能
   - 需要完全隔离的资源

## 当前项目的实际情况

### 任务特点

- ✅ 任务数量少（5个）
- ✅ 执行频率低（每小时）
- ✅ 执行时间短（几秒到几十秒）
- ✅ 业务逻辑简单（主要是数据同步）
- ✅ 所有业务逻辑都在 apiserver 中

### 结论

**当前项目不需要独立的 sync 服务**，使用 Crontab + HTTP 接口更合适。

## 迁移建议

如果决定移除独立 sync 服务，可以：

1. **保留 REST API 接口**（已实现）
   - `/api/v1/statistics/sync/daily`
   - `/api/v1/statistics/sync/accumulated`
   - `/api/v1/statistics/sync/plan`
   - `/api/v1/statistics/validate`
   - `/api/v1/plans/tasks/schedule`

2. **配置 Crontab**
   - 使用 Systemd Timer 或 Kubernetes CronJob
   - 直接调用上述 HTTP 接口

3. **移除 sync 服务代码**
   - 删除 `internal/sync/` 目录
   - 删除 `cmd/qs-sync/` 目录
   - 删除相关的 Docker 文件
   - 删除 gRPC 接口中的同步相关方法（或保留作为备用）

4. **保留 gRPC 接口（可选）**
   - 可以保留 gRPC 接口作为备用
   - 或者完全移除，只保留 REST API

## 最终决策

**建议采用 Crontab + HTTP 接口方案**，原因：

- 更简单、更直接
- 维护成本更低
- 容器友好
- 符合当前业务场景

独立 sync 服务可以作为**备选方案**保留，但不作为主要方案。
