# ğŸ” è®¤è¯æ¨¡å—è®¾è®¡

## ğŸ“‹ ç›®å½•

- [è®¾è®¡æ¦‚è¿°](#design-overview)
- [å¤šç­–ç•¥è®¤è¯æ¶æ„](#multi-strategy-auth-architecture)
- [JWTè®¤è¯æœºåˆ¶](#jwt-authentication-mechanism)
- [Basicè®¤è¯æ”¯æŒ](#basic-auth-support)
- [è®¤è¯ä¸­é—´ä»¶ç³»ç»Ÿ](#auth-middleware-system)
- [å®‰å…¨ç­–ç•¥ä¸å®è·µ](#security-strategies-practices)

## ğŸ¯ è®¾è®¡æ¦‚è¿° {#design-overview}

æœ¬é¡¹ç›®çš„è®¤è¯æ¨¡å—é‡‡ç”¨**å¤šç­–ç•¥è®¤è¯æ¶æ„**ï¼Œæ”¯æŒ**JWT**ã€**Basic Auth**å’Œ**è‡ªåŠ¨é€‰æ‹©**ç­‰å¤šç§è®¤è¯æ–¹å¼ï¼Œé€šè¿‡**ç­–ç•¥æ¨¡å¼**å’Œ**ä¸­é—´ä»¶ç³»ç»Ÿ**å®ç°äº†çµæ´»ã€å®‰å…¨ã€å¯æ‰©å±•çš„èº«ä»½è®¤è¯æœºåˆ¶ã€‚

### ğŸ—ï¸ è®¾è®¡ç›®æ ‡

1. **å¤šç­–ç•¥æ”¯æŒ**: æ”¯æŒå¤šç§è®¤è¯æ–¹å¼çš„æ— ç¼åˆ‡æ¢
2. **å®‰å…¨æ€§**: ä¼ä¸šçº§çš„å®‰å…¨è®¤è¯æœºåˆ¶
3. **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„è®¤è¯ç­–ç•¥
4. **æ€§èƒ½ä¼˜åŒ–**: é«˜æ•ˆçš„è®¤è¯å¤„ç†
5. **ç”¨æˆ·å‹å¥½**: ç®€å•æ˜“ç”¨çš„APIæ¥å£
6. **æ ‡å‡†å…¼å®¹**: éµå¾ªOAuth 2.0ã€JWTç­‰æ ‡å‡†

### ğŸ¨ æ ¸å¿ƒè®¾è®¡åŸåˆ™

- **ç­–ç•¥æ¨¡å¼**: ä¸åŒè®¤è¯æ–¹å¼çš„ç»Ÿä¸€æŠ½è±¡
- **ä¸­é—´ä»¶æ¨¡å¼**: è®¤è¯é€»è¾‘ä¸ä¸šåŠ¡é€»è¾‘åˆ†ç¦»
- **æœ€å°æƒé™**: è®¤è¯åçš„æœ€å°æƒé™æˆäºˆ
- **ä»¤ç‰Œç®¡ç†**: å®Œæ•´çš„ä»¤ç‰Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- **å®‰å…¨ä¼˜å…ˆ**: å®‰å…¨æ€§æ˜¯é¦–è¦è€ƒè™‘å› ç´ 

## ğŸ›ï¸ å¤šç­–ç•¥è®¤è¯æ¶æ„ {#multi-strategy-auth-architecture}

### ğŸ“¦ è®¤è¯ç­–ç•¥æ¥å£

```go
// internal/pkg/middleware/auth/strategys/strategy.go

// Strategy è®¤è¯ç­–ç•¥æ¥å£
type Strategy interface {
    // AuthFunc è¿”å›Ginä¸­é—´ä»¶å‡½æ•°
    AuthFunc() gin.HandlerFunc
    
    // Authenticate æ‰§è¡Œè®¤è¯
    Authenticate(c *gin.Context) (bool, error)
    
    // GetUserInfo è·å–ç”¨æˆ·ä¿¡æ¯
    GetUserInfo(c *gin.Context) (interface{}, error)
    
    // StrategyName ç­–ç•¥åç§°
    StrategyName() string
}

// BasicStrategy Basicè®¤è¯ç­–ç•¥æ¥å£
type BasicStrategy interface {
    Strategy
    ValidateUser(username, password string) bool
}

// JWTStrategy JWTè®¤è¯ç­–ç•¥æ¥å£  
type JWTStrategy interface {
    Strategy
    GenerateToken(userInfo interface{}) (string, time.Time, error)
    RefreshToken(c *gin.Context) (string, time.Time, error)
    ValidateToken(tokenString string) (interface{}, error)
}
```

### ğŸ”„ è®¤è¯æ¶æ„å›¾

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚ Client Layer"
        WEB[Webåº”ç”¨]
        MOBILE[ç§»åŠ¨åº”ç”¨] 
        API[APIå®¢æˆ·ç«¯]
    end
    
    subgraph "è®¤è¯ç½‘å…³å±‚ Auth Gateway"
        MIDDLEWARE[è®¤è¯ä¸­é—´ä»¶<br/>internal/pkg/middleware/auth]
        AUTO[è‡ªåŠ¨ç­–ç•¥<br/>AutoStrategy]
    end
    
    subgraph "ç­–ç•¥å±‚ Strategy Layer"
        JWT[JWTç­–ç•¥<br/>JWTStrategy]
        BASIC[Basicç­–ç•¥<br/>BasicStrategy]
        OAUTH[OAuthç­–ç•¥<br/>OAuthStrategy]
    end
    
    subgraph "è®¤è¯æœåŠ¡å±‚ Auth Service"
        AUTHSVC[è®¤è¯æœåŠ¡<br/>Authenticator]
        USERSVC[ç”¨æˆ·æœåŠ¡<br/>UserService]
    end
    
    subgraph "å­˜å‚¨å±‚ Storage Layer"
        TOKENSTORE[ä»¤ç‰Œå­˜å‚¨<br/>Redis/Memory]
        USERSTORE[ç”¨æˆ·å­˜å‚¨<br/>MySQL]
    end
    
    WEB --> MIDDLEWARE
    MOBILE --> MIDDLEWARE
    API --> MIDDLEWARE
    
    MIDDLEWARE --> AUTO
    AUTO --> JWT
    AUTO --> BASIC
    AUTO --> OAUTH
    
    JWT --> AUTHSVC
    BASIC --> AUTHSVC
    OAUTH --> AUTHSVC
    
    AUTHSVC --> USERSVC
    AUTHSVC --> TOKENSTORE
    USERSVC --> USERSTORE
    
    style MIDDLEWARE fill:#e3f2fd
    style JWT fill:#e8f5e8
    style BASIC fill:#fff3e0
    style AUTHSVC fill:#f3e5f5
```

### ğŸ”§ è‡ªåŠ¨ç­–ç•¥é€‰æ‹©å™¨

```go
// internal/pkg/middleware/auth/auto.go

// AutoStrategy è‡ªåŠ¨é€‰æ‹©è®¤è¯ç­–ç•¥
type AutoStrategy struct {
    strategies []Strategy
    logger     *zap.Logger
}

// NewAutoStrategy åˆ›å»ºè‡ªåŠ¨ç­–ç•¥
func NewAutoStrategy(strategies ...Strategy) *AutoStrategy {
    return &AutoStrategy{
        strategies: strategies,
        logger:     log.ZapLogger(),
    }
}

// AuthFunc è¿”å›è®¤è¯ä¸­é—´ä»¶
func (a *AutoStrategy) AuthFunc() gin.HandlerFunc {
    return func(c *gin.Context) {
        // å°è¯•æ¯ç§ç­–ç•¥è¿›è¡Œè®¤è¯
        for _, strategy := range a.strategies {
            success, err := strategy.Authenticate(c)
            if err != nil {
                a.logger.Warn("è®¤è¯ç­–ç•¥æ‰§è¡Œå¤±è´¥",
                    zap.String("strategy", strategy.StrategyName()),
                    zap.Error(err),
                )
                continue
            }
            
            if success {
                a.logger.Debug("è®¤è¯æˆåŠŸ",
                    zap.String("strategy", strategy.StrategyName()),
                    zap.String("path", c.Request.URL.Path),
                )
                
                // è®¾ç½®è®¤è¯ç­–ç•¥ä¿¡æ¯
                c.Set("auth_strategy", strategy.StrategyName())
                c.Next()
                return
            }
        }
        
        // æ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥
        a.logger.Warn("æ‰€æœ‰è®¤è¯ç­–ç•¥éƒ½å¤±è´¥",
            zap.String("path", c.Request.URL.Path),
            zap.String("client_ip", c.ClientIP()),
        )
        
        c.JSON(http.StatusUnauthorized, gin.H{
            "code":    code.ErrTokenInvalid.Code(),
            "message": "Authentication required",
        })
        c.Abort()
    }
}
```

## ğŸ« JWTè®¤è¯æœºåˆ¶ {#jwt-authentication-mechanism}

### ğŸ“¦ JWTç­–ç•¥å®ç°

```go
// internal/pkg/middleware/auth/strategys/jwt.go

// JWTStrategy JWTè®¤è¯ç­–ç•¥
type JWTStrategy struct {
    *jwt.GinJWTMiddleware
}

// NewJWTStrategy åˆ›å»ºJWTç­–ç•¥
func NewJWTStrategy(middleware jwt.GinJWTMiddleware) *JWTStrategy {
    return &JWTStrategy{&middleware}
}

// AuthFunc è¿”å›JWTè®¤è¯ä¸­é—´ä»¶
func (j *JWTStrategy) AuthFunc() gin.HandlerFunc {
    return j.MiddlewareFunc()
}

// Authenticate æ‰§è¡ŒJWTè®¤è¯
func (j *JWTStrategy) Authenticate(c *gin.Context) (bool, error) {
    // å°è¯•ä»ä¸åŒä½ç½®è·å–token
    token := j.extractToken(c)
    if token == "" {
        return false, nil
    }
    
    // éªŒè¯token
    claims, err := j.ParseToken(token)
    if err != nil {
        return false, err
    }
    
    // è®¾ç½®ç”¨æˆ·ä¿¡æ¯åˆ°ä¸Šä¸‹æ–‡
    c.Set("jwt_claims", claims)
    c.Set("X-Username", claims[j.IdentityKey])
    
    return true, nil
}

// extractToken ä»å¤šä¸ªä½ç½®æå–token
func (j *JWTStrategy) extractToken(c *gin.Context) string {
    // 1. ä»Authorization headeræå–
    authHeader := c.GetHeader("Authorization")
    if authHeader != "" {
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) == 2 && parts[0] == "Bearer" {
            return parts[1]
        }
    }
    
    // 2. ä»queryå‚æ•°æå–
    if token := c.Query("token"); token != "" {
        return token
    }
    
    // 3. ä»cookieæå–
    if token, err := c.Cookie("jwt"); err == nil && token != "" {
        return token
    }
    
    return ""
}
```

### ğŸ”‘ JWTé…ç½®ä¸ç”Ÿæˆ

```go
// internal/apiserver/auth.go

// NewJWTAuth åˆ›å»ºJWTè®¤è¯ç­–ç•¥
func (cfg *Auth) NewJWTAuth() authStrategys.JWTStrategy {
    ginjwt, _ := jwt.New(&jwt.GinJWTMiddleware{
        Realm:            viper.GetString("jwt.realm"),
        SigningAlgorithm: "HS256",
        Key:              []byte(viper.GetString("jwt.key")),
        Timeout:          viper.GetDuration("jwt.timeout"),
        MaxRefresh:       viper.GetDuration("jwt.max-refresh"),
        
        // è®¤è¯å™¨
        Authenticator:    cfg.createAuthenticator(),
        
        // ç™»å½•å“åº”
        LoginResponse:    cfg.createLoginResponse(),
        
        // æ³¨é”€å“åº”
        LogoutResponse: func(c *gin.Context, code int) {
            c.JSON(http.StatusOK, gin.H{"message": "Successfully logged out"})
        },
        
        // åˆ·æ–°å“åº”
        RefreshResponse: cfg.createRefreshResponse(),
        
        // è´Ÿè½½ç”Ÿæˆ
        PayloadFunc:     cfg.createPayloadFunc(),
        
        // èº«ä»½å¤„ç†
        IdentityHandler: func(c *gin.Context) interface{} {
            claims := jwt.ExtractClaims(c)
            return claims[jwt.IdentityKey]
        },
        
        IdentityKey:  middleware.UsernameKey,
        
        // æˆæƒå™¨
        Authorizator: cfg.createAuthorizator(),
        
        // æœªæˆæƒå¤„ç†
        Unauthorized: func(c *gin.Context, code int, message string) {
            c.JSON(code, gin.H{
                "code":    code,
                "message": message,
            })
        },
        
        TokenLookup:   "header: Authorization, query: token, cookie: jwt",
        TokenHeadName: "Bearer",
        SendCookie:    true,
        TimeFunc:      time.Now,
    })

    return authStrategys.NewJWTStrategy(*ginjwt)
}
```

### ğŸ”„ JWTç”Ÿå‘½å‘¨æœŸç®¡ç†

```go
// JWTè´Ÿè½½ç”Ÿæˆ
func (cfg *Auth) createPayloadFunc() func(data interface{}) jwt.MapClaims {
    return func(data interface{}) jwt.MapClaims {
        APIServerIssuer := "questionnaire-scale-apiserver"
        APIServerAudience := "questionnaire-scale.com"
        
        claims := jwt.MapClaims{
            "iss": APIServerIssuer,
            "aud": APIServerAudience,
            "iat": time.Now().Unix(),
            "exp": time.Now().Add(viper.GetDuration("jwt.timeout")).Unix(),
        }

        if user, ok := data.(*port.UserResponse); ok {
            claims[jwt.IdentityKey] = user.Username
            claims["sub"] = user.Username
            claims["user_id"] = user.ID
            claims["nickname"] = user.Nickname
            claims["roles"] = user.Roles // ç”¨æˆ·è§’è‰²
            claims["permissions"] = user.Permissions // ç”¨æˆ·æƒé™
        }

        return claims
    }
}

// JWTæˆæƒå™¨
func (cfg *Auth) createAuthorizator() func(data interface{}, c *gin.Context) bool {
    return func(data interface{}, c *gin.Context) bool {
        if username, ok := data.(string); ok {
            log.L(c).Infof("User `%s` is authorized.", username)
            
            // å°†ç”¨æˆ·åè®¾ç½®åˆ°ä¸Šä¸‹æ–‡ä¸­
            c.Set(middleware.UsernameKey, username)
            
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤æ‚çš„æˆæƒé€»è¾‘
            // ä¾‹å¦‚ï¼šåŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)
            if err := cfg.checkPermissions(c, username); err != nil {
                log.L(c).Warnf("User `%s` permission check failed: %v", username, err)
                return false
            }
            
            return true
        }

        return false
    }
}

// æƒé™æ£€æŸ¥
func (cfg *Auth) checkPermissions(c *gin.Context, username string) error {
    // è·å–ç”¨æˆ·è§’è‰²å’Œæƒé™
    claims := jwt.ExtractClaims(c)
    roles, _ := claims["roles"].([]string)
    permissions, _ := claims["permissions"].([]string)
    
    // è·å–è¯·æ±‚çš„èµ„æºå’Œæ“ä½œ
    resource := extractResource(c.Request.URL.Path)
    action := strings.ToLower(c.Request.Method)
    
    // æ£€æŸ¥æƒé™
    if hasPermission(roles, permissions, resource, action) {
        return nil
    }
    
    return errors.WithCode(code.ErrAuthorizationFailed, 
        "ç”¨æˆ· %s æ²¡æœ‰æƒé™è®¿é—®èµ„æº %s", username, resource)
}
```

## ğŸ”‘ Basicè®¤è¯æ”¯æŒ {#basic-auth-support}

### ğŸ“¦ Basicè®¤è¯ç­–ç•¥

```go
// internal/pkg/middleware/auth/strategys/basic.go

// BasicStrategy Basicè®¤è¯ç­–ç•¥
type BasicStrategy struct {
    validator func(username, password string) bool
    realm     string
}

// NewBasicStrategy åˆ›å»ºBasicè®¤è¯ç­–ç•¥
func NewBasicStrategy(validator func(username, password string) bool) *BasicStrategy {
    return &BasicStrategy{
        validator: validator,
        realm:     "Questionnaire Scale API",
    }
}

// AuthFunc è¿”å›Basicè®¤è¯ä¸­é—´ä»¶
func (b *BasicStrategy) AuthFunc() gin.HandlerFunc {
    return gin.BasicAuth(gin.Accounts{
        // åŠ¨æ€éªŒè¯ï¼Œé€šè¿‡validatorå‡½æ•°
    })
}

// Authenticate æ‰§è¡ŒBasicè®¤è¯
func (b *BasicStrategy) Authenticate(c *gin.Context) (bool, error) {
    // è·å–Authorization header
    authHeader := c.GetHeader("Authorization")
    if authHeader == "" {
        return false, nil
    }
    
    // è§£æBasicè®¤è¯
    username, password, ok := b.parseBasicAuth(authHeader)
    if !ok {
        return false, errors.New("invalid basic auth format")
    }
    
    // éªŒè¯ç”¨æˆ·
    if !b.validator(username, password) {
        return false, errors.New("invalid credentials")
    }
    
    // è®¾ç½®ç”¨æˆ·ä¿¡æ¯åˆ°ä¸Šä¸‹æ–‡
    c.Set("X-Username", username)
    c.Set("auth_method", "basic")
    
    return true, nil
}

// parseBasicAuth è§£æBasicè®¤è¯header
func (b *BasicStrategy) parseBasicAuth(auth string) (username, password string, ok bool) {
    const prefix = "Basic "
    if len(auth) < len(prefix) || !strings.EqualFold(auth[:len(prefix)], prefix) {
        return "", "", false
    }
    
    c, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
    if err != nil {
        return "", "", false
    }
    
    cs := string(c)
    username, password, ok = strings.Cut(cs, ":")
    if !ok {
        return "", "", false
    }
    
    return username, password, true
}

// StrategyName è¿”å›ç­–ç•¥åç§°
func (b *BasicStrategy) StrategyName() string {
    return "basic"
}
```

### ğŸ” Basicè®¤è¯é…ç½®

```go
// internal/apiserver/auth.go

// NewBasicAuth åˆ›å»ºBasicè®¤è¯ç­–ç•¥
func (cfg *Auth) NewBasicAuth() authStrategys.BasicStrategy {
    return authStrategys.NewBasicStrategy(func(username string, password string) bool {
        // ä½¿ç”¨Authenticatorè¿›è¡Œè®¤è¯
        authResp, err := cfg.authenticator.Authenticate(context.Background(), port.AuthenticateRequest{
            Username: username,
            Password: password,
        })
        if err != nil {
            log.Warnf("Basic auth failed for user %s: %v", username, err)
            return false
        }
        
        log.Infof("Basic auth successful for user: %s", authResp.User.Username)
        return true
    })
}
```

## ğŸŒ è®¤è¯ä¸­é—´ä»¶ç³»ç»Ÿ {#auth-middleware-system}

### ğŸ“ è®¤è¯ä¸­é—´ä»¶æ³¨å†Œ

```go
// internal/pkg/middleware/middleware.go

// Middlewares ä¸­é—´ä»¶æ³¨å†Œè¡¨
var Middlewares = map[string]gin.HandlerFunc{
    "recovery":        gin.Recovery(),
    "cors":            Cors(),
    "logger":          Logger(),
    "enhanced-logger": EnhancedLogger(),
    "limit":           Limit(),
    "auth":            Auth(), // è®¤è¯ä¸­é—´ä»¶
}

// Auth è®¤è¯ä¸­é—´ä»¶å·¥å‚
func Auth() gin.HandlerFunc {
    // è¿™é‡Œå¯ä»¥æ ¹æ®é…ç½®é€‰æ‹©ä¸åŒçš„è®¤è¯ç­–ç•¥
    authType := viper.GetString("auth.type")
    
    switch authType {
    case "jwt":
        return createJWTAuth()
    case "basic":
        return createBasicAuth()
    case "auto":
        return createAutoAuth()
    default:
        return createAutoAuth() // é»˜è®¤ä½¿ç”¨è‡ªåŠ¨é€‰æ‹©
    }
}
```

### ğŸ”„ è·¯ç”±çº§è®¤è¯é…ç½®

```go
// internal/apiserver/routers.go

func (s *apiserver) installAPIServerRoutes() {
    // å…¬å¼€è·¯ç”±ï¼ˆæ— éœ€è®¤è¯ï¼‰
    s.registerPublicRoutes()
    
    // å—ä¿æŠ¤è·¯ç”±ï¼ˆéœ€è¦è®¤è¯ï¼‰
    s.registerProtectedRoutes()
}

// æ³¨å†Œå…¬å¼€è·¯ç”±
func (s *apiserver) registerPublicRoutes() {
    publicGroup := s.Group("/api/v1")
    
    // è®¤è¯ç›¸å…³è·¯ç”±
    authGroup := publicGroup.Group("/auth")
    {
        // ç™»å½•ï¼ˆä½¿ç”¨JWTä¸­é—´ä»¶å¤„ç†ï¼‰
        authGroup.POST("/login", s.container.AuthModule.JWTMiddleware.LoginHandler)
        
        // åˆ·æ–°token
        authGroup.POST("/refresh", s.container.AuthModule.JWTMiddleware.RefreshHandler)
        
        // æ³¨é”€
        authGroup.POST("/logout", s.container.AuthModule.JWTMiddleware.LogoutHandler)
    }
    
    // å¥åº·æ£€æŸ¥
    publicGroup.GET("/health", s.healthCheck)
}

// æ³¨å†Œå—ä¿æŠ¤è·¯ç”±
func (s *apiserver) registerProtectedRoutes() {
    // åº”ç”¨è®¤è¯ä¸­é—´ä»¶
    protectedGroup := s.Group("/api/v1")
    protectedGroup.Use(s.container.AuthModule.AuthMiddleware.AuthFunc())
    
    // ç”¨æˆ·ç›¸å…³è·¯ç”±
    userGroup := protectedGroup.Group("/users")
    {
        userGroup.GET("/:id", s.container.UserModule.UserHandler.GetUser)
        userGroup.PUT("/:id", s.container.UserModule.UserHandler.UpdateUser)
        userGroup.DELETE("/:id", s.container.UserModule.UserHandler.DeleteUser)
        userGroup.GET("", s.container.UserModule.UserHandler.ListUsers)
    }
    
    // é—®å·ç›¸å…³è·¯ç”±
    questionnaireGroup := protectedGroup.Group("/questionnaires")
    {
        // éœ€è¦ç‰¹å®šæƒé™çš„è·¯ç”±å¯ä»¥æ·»åŠ é¢å¤–çš„æˆæƒä¸­é—´ä»¶
        questionnaireGroup.Use(RequirePermission("questionnaire:read"))
        questionnaireGroup.GET("", s.getQuestionnaires)
        
        questionnaireGroup.Use(RequirePermission("questionnaire:write"))
        questionnaireGroup.POST("", s.createQuestionnaire)
        questionnaireGroup.PUT("/:id", s.updateQuestionnaire)
        questionnaireGroup.DELETE("/:id", s.deleteQuestionnaire)
    }
}
```

### ğŸ”’ æƒé™æ§åˆ¶ä¸­é—´ä»¶

```go
// internal/pkg/middleware/permission.go

// RequirePermission æƒé™æ£€æŸ¥ä¸­é—´ä»¶
func RequirePermission(permission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // è·å–ç”¨æˆ·ä¿¡æ¯
        username, exists := c.Get("X-Username")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{
                "code":    code.ErrTokenInvalid.Code(),
                "message": "ç”¨æˆ·æœªè®¤è¯",
            })
            c.Abort()
            return
        }
        
        // æ£€æŸ¥æƒé™
        if !hasUserPermission(username.(string), permission) {
            log.L(c).Warnw("æƒé™æ£€æŸ¥å¤±è´¥",
                "username", username,
                "permission", permission,
                "path", c.Request.URL.Path,
            )
            
            c.JSON(http.StatusForbidden, gin.H{
                "code":    code.ErrAuthorizationFailed.Code(),
                "message": fmt.Sprintf("ç¼ºå°‘æƒé™: %s", permission),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æŒ‡å®šæƒé™
func hasUserPermission(username, permission string) bool {
    // è¿™é‡Œå¯ä»¥å®ç°åŸºäºè§’è‰²çš„æƒé™æ£€æŸ¥(RBAC)
    // 1. ä»æ•°æ®åº“æˆ–ç¼“å­˜è·å–ç”¨æˆ·è§’è‰²
    // 2. è·å–è§’è‰²å¯¹åº”çš„æƒé™åˆ—è¡¨
    // 3. æ£€æŸ¥æ˜¯å¦åŒ…å«æ‰€éœ€æƒé™
    
    // ç¤ºä¾‹å®ç°
    userRoles := getUserRoles(username)
    for _, role := range userRoles {
        if roleHasPermission(role, permission) {
            return true
        }
    }
    
    return false
}

// RequireRole è§’è‰²æ£€æŸ¥ä¸­é—´ä»¶
func RequireRole(role string) gin.HandlerFunc {
    return func(c *gin.Context) {
        username, exists := c.Get("X-Username")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{
                "code":    code.ErrTokenInvalid.Code(),
                "message": "ç”¨æˆ·æœªè®¤è¯",
            })
            c.Abort()
            return
        }
        
        if !hasUserRole(username.(string), role) {
            c.JSON(http.StatusForbidden, gin.H{
                "code":    code.ErrAuthorizationFailed.Code(),
                "message": fmt.Sprintf("éœ€è¦è§’è‰²: %s", role),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

## ğŸ›¡ï¸ å®‰å…¨ç­–ç•¥ä¸å®è·µ {#security-strategies-practices}

### ğŸ” å¯†ç å®‰å…¨

```go
// pkg/auth/auth.go

// Encrypt å¯†ç åŠ å¯†
func Encrypt(source string) (string, error) {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(source), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(hashedPassword), nil
}

// Compare å¯†ç æ¯”è¾ƒ
func Compare(hashedPassword, password string) error {
    return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}

// å¯†ç å¼ºåº¦æ£€æŸ¥
func ValidatePasswordStrength(password string) error {
    if len(password) < 8 {
        return errors.New("å¯†ç é•¿åº¦è‡³å°‘8ä½")
    }
    
    var (
        hasUpper   = false
        hasLower   = false
        hasNumber  = false
        hasSpecial = false
    )
    
    for _, char := range password {
        switch {
        case unicode.IsUpper(char):
            hasUpper = true
        case unicode.IsLower(char):
            hasLower = true
        case unicode.IsNumber(char):
            hasNumber = true
        case unicode.IsPunct(char) || unicode.IsSymbol(char):
            hasSpecial = true
        }
    }
    
    if !hasUpper {
        return errors.New("å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯")
    }
    if !hasLower {
        return errors.New("å¯†ç å¿…é¡»åŒ…å«å°å†™å­—æ¯")
    }
    if !hasNumber {
        return errors.New("å¯†ç å¿…é¡»åŒ…å«æ•°å­—")
    }
    if !hasSpecial {
        return errors.New("å¯†ç å¿…é¡»åŒ…å«ç‰¹æ®Šå­—ç¬¦")
    }
    
    return nil
}
```

### ğŸš« å®‰å…¨é˜²æŠ¤æœºåˆ¶

```go
// é˜²æ­¢æš´åŠ›ç ´è§£
type LoginAttemptTracker struct {
    mu       sync.RWMutex
    attempts map[string]*AttemptInfo
    cleanup  *time.Ticker
}

type AttemptInfo struct {
    Count     int
    LastAttempt time.Time
    BlockedUntil time.Time
}

// NewLoginAttemptTracker åˆ›å»ºç™»å½•å°è¯•è·Ÿè¸ªå™¨
func NewLoginAttemptTracker() *LoginAttemptTracker {
    tracker := &LoginAttemptTracker{
        attempts: make(map[string]*AttemptInfo),
        cleanup:  time.NewTicker(1 * time.Hour),
    }
    
    // æ¸…ç†è¿‡æœŸè®°å½•
    go tracker.cleanupLoop()
    
    return tracker
}

// IsBlocked æ£€æŸ¥æ˜¯å¦è¢«é˜»æ­¢
func (t *LoginAttemptTracker) IsBlocked(identifier string) bool {
    t.mu.RLock()
    defer t.mu.RUnlock()
    
    info, exists := t.attempts[identifier]
    if !exists {
        return false
    }
    
    return time.Now().Before(info.BlockedUntil)
}

// RecordFailedAttempt è®°å½•å¤±è´¥å°è¯•
func (t *LoginAttemptTracker) RecordFailedAttempt(identifier string) {
    t.mu.Lock()
    defer t.mu.Unlock()
    
    now := time.Now()
    info, exists := t.attempts[identifier]
    if !exists {
        info = &AttemptInfo{}
        t.attempts[identifier] = info
    }
    
    info.Count++
    info.LastAttempt = now
    
    // è¶…è¿‡5æ¬¡å¤±è´¥ï¼Œé˜»æ­¢30åˆ†é’Ÿ
    if info.Count >= 5 {
        info.BlockedUntil = now.Add(30 * time.Minute)
    }
}

// RecordSuccessfulLogin è®°å½•æˆåŠŸç™»å½•
func (t *LoginAttemptTracker) RecordSuccessfulLogin(identifier string) {
    t.mu.Lock()
    defer t.mu.Unlock()
    
    delete(t.attempts, identifier)
}
```

### ğŸ”„ Tokenå®‰å…¨ç®¡ç†

```go
// JWT Tokené»‘åå•æœºåˆ¶
type TokenBlacklist struct {
    redis  *redis.Client
    prefix string
}

// NewTokenBlacklist åˆ›å»ºTokené»‘åå•
func NewTokenBlacklist(redis *redis.Client) *TokenBlacklist {
    return &TokenBlacklist{
        redis:  redis,
        prefix: "token_blacklist:",
    }
}

// AddToBlacklist æ·»åŠ åˆ°é»‘åå•
func (tb *TokenBlacklist) AddToBlacklist(token string, expiration time.Duration) error {
    key := tb.prefix + token
    return tb.redis.Set(context.Background(), key, "1", expiration).Err()
}

// IsBlacklisted æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•
func (tb *TokenBlacklist) IsBlacklisted(token string) bool {
    key := tb.prefix + token
    result := tb.redis.Get(context.Background(), key)
    return result.Err() == nil
}

// Tokenåˆ·æ–°ç­–ç•¥
type TokenRefreshStrategy struct {
    accessTokenTTL  time.Duration
    refreshTokenTTL time.Duration
    redis          *redis.Client
}

// RefreshTokens åˆ·æ–°ä»¤ç‰Œ
func (trs *TokenRefreshStrategy) RefreshTokens(refreshToken string) (accessToken, newRefreshToken string, err error) {
    // éªŒè¯refresh token
    claims, err := validateRefreshToken(refreshToken)
    if err != nil {
        return "", "", err
    }
    
    // ç”Ÿæˆæ–°çš„access token
    accessToken, err = generateAccessToken(claims.UserID)
    if err != nil {
        return "", "", err
    }
    
    // ç”Ÿæˆæ–°çš„refresh token
    newRefreshToken, err = generateRefreshToken(claims.UserID)
    if err != nil {
        return "", "", err
    }
    
    // å°†æ—§çš„refresh tokenåŠ å…¥é»‘åå•
    err = trs.blacklistToken(refreshToken)
    if err != nil {
        return "", "", err
    }
    
    return accessToken, newRefreshToken, nil
}
```

### ğŸ“Š å®‰å…¨å®¡è®¡

```go
// å®‰å…¨äº‹ä»¶è®°å½•
type SecurityEvent struct {
    Timestamp   time.Time `json:"timestamp"`
    EventType   string    `json:"event_type"`
    UserID      string    `json:"user_id"`
    Username    string    `json:"username"`
    ClientIP    string    `json:"client_ip"`
    UserAgent   string    `json:"user_agent"`
    Resource    string    `json:"resource"`
    Action      string    `json:"action"`
    Result      string    `json:"result"`
    Details     string    `json:"details"`
}

// SecurityAuditor å®‰å…¨å®¡è®¡å™¨
type SecurityAuditor struct {
    logger *zap.Logger
    store  SecurityEventStore
}

// LogSecurityEvent è®°å½•å®‰å…¨äº‹ä»¶
func (sa *SecurityAuditor) LogSecurityEvent(event SecurityEvent) {
    // è®°å½•åˆ°æ—¥å¿—
    sa.logger.Info("å®‰å…¨äº‹ä»¶",
        zap.String("event_type", event.EventType),
        zap.String("username", event.Username),
        zap.String("client_ip", event.ClientIP),
        zap.String("result", event.Result),
    )
    
    // å­˜å‚¨åˆ°æ•°æ®åº“
    if err := sa.store.Save(event); err != nil {
        sa.logger.Error("ä¿å­˜å®‰å…¨äº‹ä»¶å¤±è´¥", zap.Error(err))
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
    if sa.shouldAlert(event) {
        sa.sendSecurityAlert(event)
    }
}

// å®‰å…¨äº‹ä»¶ç±»å‹å¸¸é‡
const (
    EventTypeLogin          = "login"
    EventTypeLogout         = "logout"
    EventTypeLoginFailed    = "login_failed"
    EventTypeTokenRefresh   = "token_refresh"
    EventTypePasswordChange = "password_change"
    EventTypePermissionDenied = "permission_denied"
    EventTypeSuspiciousActivity = "suspicious_activity"
)
```

## ğŸ“š å®é™…åº”ç”¨æ¡ˆä¾‹

### ğŸ”§ å®Œæ•´è®¤è¯æµç¨‹

```go
// 1. ç”¨æˆ·ç™»å½•
func (h *AuthHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        core.WriteResponse(c, errors.WithCode(code.ErrBind, err.Error()), nil)
        return
    }
    
    // æ£€æŸ¥æ˜¯å¦è¢«é˜»æ­¢
    if loginTracker.IsBlocked(req.Username) {
        securityAuditor.LogSecurityEvent(SecurityEvent{
            EventType: EventTypeLoginFailed,
            Username:  req.Username,
            ClientIP:  c.ClientIP(),
            Result:    "blocked",
            Details:   "too many failed attempts",
        })
        
        core.WriteResponse(c, errors.WithCode(code.ErrAuthenticationFailed, 
            "è´¦æˆ·å·²è¢«æš‚æ—¶é”å®š"), nil)
        return
    }
    
    // è®¤è¯ç”¨æˆ·
    user, err := h.authenticator.Authenticate(c.Request.Context(), port.AuthenticateRequest{
        Username: req.Username,
        Password: req.Password,
    })
    if err != nil {
        // è®°å½•å¤±è´¥å°è¯•
        loginTracker.RecordFailedAttempt(req.Username)
        
        securityAuditor.LogSecurityEvent(SecurityEvent{
            EventType: EventTypeLoginFailed,
            Username:  req.Username,
            ClientIP:  c.ClientIP(),
            Result:    "failed",
            Details:   err.Error(),
        })
        
        core.WriteResponse(c, err, nil)
        return
    }
    
    // ç”Ÿæˆtokens
    accessToken, refreshToken, err := h.tokenService.GenerateTokens(user)
    if err != nil {
        core.WriteResponse(c, err, nil)
        return
    }
    
    // è®°å½•æˆåŠŸç™»å½•
    loginTracker.RecordSuccessfulLogin(req.Username)
    
    securityAuditor.LogSecurityEvent(SecurityEvent{
        EventType: EventTypeLogin,
        UserID:    fmt.Sprintf("%d", user.ID),
        Username:  user.Username,
        ClientIP:  c.ClientIP(),
        Result:    "success",
    })
    
    core.WriteResponse(c, nil, gin.H{
        "access_token":  accessToken,
        "refresh_token": refreshToken,
        "user":          user,
    })
}

// 2. Tokenåˆ·æ–°
func (h *AuthHandler) RefreshToken(c *gin.Context) {
    var req RefreshTokenRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        core.WriteResponse(c, errors.WithCode(code.ErrBind, err.Error()), nil)
        return
    }
    
    // åˆ·æ–°tokens
    accessToken, newRefreshToken, err := h.tokenRefreshStrategy.RefreshTokens(req.RefreshToken)
    if err != nil {
        core.WriteResponse(c, err, nil)
        return
    }
    
    core.WriteResponse(c, nil, gin.H{
        "access_token":  accessToken,
        "refresh_token": newRefreshToken,
    })
}

// 3. ç”¨æˆ·æ³¨é”€
func (h *AuthHandler) Logout(c *gin.Context) {
    // ä»headerè·å–token
    token := extractTokenFromHeader(c)
    if token != "" {
        // æ·»åŠ åˆ°é»‘åå•
        tokenBlacklist.AddToBlacklist(token, time.Hour*24)
    }
    
    username, _ := c.Get("X-Username")
    securityAuditor.LogSecurityEvent(SecurityEvent{
        EventType: EventTypeLogout,
        Username:  username.(string),
        ClientIP:  c.ClientIP(),
        Result:    "success",
    })
    
    core.WriteResponse(c, nil, gin.H{"message": "Successfully logged out"})
}
```

## ğŸ¯ è®¾è®¡æ€»ç»“

è®¤è¯æ¨¡å—è®¾è®¡å®ç°äº†ï¼š

### 1. **å¤šç­–ç•¥æ¶æ„**

- æ”¯æŒJWTã€Basic Authç­‰å¤šç§è®¤è¯æ–¹å¼
- è‡ªåŠ¨ç­–ç•¥é€‰æ‹©æœºåˆ¶
- æ˜“äºæ‰©å±•æ–°çš„è®¤è¯ç­–ç•¥

### 2. **ä¼ä¸šçº§å®‰å…¨**

- å¯†ç å¼ºåº¦æ£€æŸ¥å’ŒåŠ å¯†å­˜å‚¨
- é˜²æš´åŠ›ç ´è§£æœºåˆ¶
- Tokené»‘åå•ç®¡ç†

### 3. **ç»†ç²’åº¦æƒé™æ§åˆ¶**

- åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)
- èµ„æºçº§æƒé™æ£€æŸ¥
- åŠ¨æ€æƒé™éªŒè¯

### 4. **å®‰å…¨å®¡è®¡**

- å®Œæ•´çš„å®‰å…¨äº‹ä»¶è®°å½•
- å®æ—¶å®‰å…¨ç›‘æ§
- å¼‚å¸¸è¡Œä¸ºå‘Šè­¦

### 5. **æ€§èƒ½ä¼˜åŒ–**

- Tokenç¼“å­˜æœºåˆ¶
- æƒé™ä¿¡æ¯ç¼“å­˜
- é«˜æ•ˆçš„è®¤è¯å¤„ç†

### 6. **ç”¨æˆ·ä½“éªŒ**

- ç»Ÿä¸€çš„è®¤è¯æ¥å£
- çµæ´»çš„Tokenç®¡ç†
- å‹å¥½çš„é”™è¯¯æç¤º

è¿™ç§è®¾è®¡ä¸ºæ„å»ºå®‰å…¨å¯é çš„ä¼ä¸šçº§åº”ç”¨æä¾›äº†å®Œæ•´çš„è®¤è¯å’Œæˆæƒè§£å†³æ–¹æ¡ˆã€‚
