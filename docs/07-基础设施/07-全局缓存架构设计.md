# 全局缓存架构设计

> **最后更新**：2025-01-XX  
> **实现状态**：核心缓存、高优先级和中优先级功能已完成  
> **相关文档**：
>
> - `09-缓存实现总结.md` - 实现总结和当前状态
> - `08-Redis双实例架构说明.md` - Redis 双实例说明
> - `10-统计模块缓存预热说明.md` - 统计缓存预热
> - `11-缓存位置决策：apiserver vs collection-server.md` - 缓存位置决策

> ⚠️ 2024 Q1 更新：工程已移除 redis-store，现阶段仅保留单实例 Redis（原 redis-cache）。下文仅描述现用的单实例缓存形态；历史双实例设计已归档，不再实施。
> - `12-Redis存储空间评估.md` - 存储空间评估（历史）
> - `14-Worker事件处理必要性分析.md` - Worker 事件处理分析

## 1. 缓存需求分析

### 1.1 数据访问模式分类

| 数据类型 | 读频率 | 写频率 | 数据大小 | 一致性要求 | 当前状态 |
|---------|--------|--------|---------|-----------|---------|
| **量表（Scale）** | 极高 | 极低 | 中（~50KB） | 最终一致 | ✅ 已实现 |
| **问卷（Questionnaire）** | 极高 | 低 | 中（~30KB） | 最终一致 | ✅ 已实现 |
| **统计查询结果** | 高 | 低 | 小（~10KB） | 弱一致（5分钟） | ✅ 已实现 |
| **Assessment 状态** | 极高 | 中 | 极小（~1KB） | 强一致 | ✅ 已实现 |
| **测评详情** | 高 | 低 | 中（~30KB） | 最终一致 | ✅ 已实现 |
| **受试者信息** | 中 | 低 | 小（~5KB） | 最终一致 | ✅ 已实现 |
| **计划（Plan）信息** | 中 | 低 | 小（~10KB） | 最终一致 | ✅ 已实现 |
| **事件幂等性** | 中 | 中 | 极小（~100B） | 强一致 | ✅ 已实现 |

### 1.2 缓存策略选择

**Cache-Aside（旁路缓存）** - 适用于大部分场景：

- 量表、问卷、测评详情、受试者、计划
- 优点：简单、灵活、容错性好
- 缺点：首次访问需要查库

**Write-Through（写透）** - 适用于强一致性场景：

- Assessment 状态（需要实时更新）

**Read-Through（读透）** - 适用于热点数据：

- 量表、问卷（通过预热实现）

## 2. Redis 实例选择

### 2.1 单实例架构（现状）

- **redis**：单实例承担缓存/短期数据，TTL 管控；丢失可从 MySQL/Mongo 重建。
- 队列/持久化需求暂不落在 Redis；若未来需要，再单独规划专用实例。

### 2.2 使用约定

- 所有缓存装饰器、幂等标记、统计预聚合统一使用当前单实例 Redis。
- 必须设置合理 TTL（带抖动），避免长尾膨胀。
- 需要强一致的持久化数据请直接落库，避免将 Redis 视为存储。

## 3. 统一缓存接口设计

### 3.1 核心接口抽象

```go
// internal/apiserver/infra/cache/interface.go

// Cache 统一缓存接口
type Cache interface {
    // Get 获取缓存
    Get(ctx context.Context, key string) ([]byte, error)
    
    // Set 设置缓存
    Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
    
    // Delete 删除缓存
    Delete(ctx context.Context, key string) error
    
    // Exists 检查是否存在
    Exists(ctx context.Context, key string) (bool, error)
    
    // MGet 批量获取
    MGet(ctx context.Context, keys []string) (map[string][]byte, error)
    
    // MSet 批量设置
    MSet(ctx context.Context, items map[string][]byte, ttl time.Duration) error
}

// TypedCache 类型化缓存接口（泛型，Go 1.18+）
type TypedCache[T any] interface {
    Get(ctx context.Context, key string) (*T, error)
    Set(ctx context.Context, key string, value *T, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
}
```

### 3.2 缓存键命名规范

```
{domain}:{type}:{identifier}[:{subtype}]

示例：
scale:{code}                          # 量表数据
questionnaire:{code}:{version}         # 问卷数据
assessment:status:{id}                 # 测评状态
assessment:detail:{id}                 # 测评详情
testee:info:{id}                       # 受试者信息
plan:info:{id}                         # 计划信息
stats:query:{type}:{key}               # 统计查询结果
event:processed:{event_id}             # 事件幂等性
```

**规则**：

- 使用冒号 `:` 分隔层级
- 小写字母和数字
- 避免特殊字符
- 保持简洁但可读

## 4. 多级缓存架构

### 4.1 三级缓存架构

```text
                    [客户端请求]
                          ↓
                  [qs-apiserver]
                          ↓
        ┌─────────────────┴─────────────────┐
        ↓                                   ↓
[L1: 本地内存缓存]                  [L2: Redis 缓存]
- sync.Map / LRU                      - 分布式缓存
- 热点数据（~100项）                  - 全量数据
- TTL: 进程生命周期                   - TTL: 按需配置
        ↓                                   ↓
        └─────────────────┬─────────────────┘
                          ↓
                    [持久层：MySQL/MongoDB]
```

### 4.2 缓存层级选择

| 数据类型 | L1 本地缓存 | L2 Redis | 理由 |
|---------|------------|----------|------|
| 量表 | ✅ 可选 | ✅ 必须 | 高频访问，L1 可减少网络开销 |
| 问卷 | ❌ 不推荐 | ✅ 必须 | 数据大，L1 占用内存多 |
| Assessment 状态 | ✅ 推荐 | ✅ 必须 | 访问极频繁，L1 提升明显 |
| Assessment 详情 | ❌ 不推荐 | ✅ 必须 | 数据中等，L2 足够 |
| Testee 信息 | ❌ 不推荐 | ✅ 必须 | 访问频率中等 |
| Plan 信息 | ❌ 不推荐 | ✅ 必须 | 访问频率中等 |
| 统计查询 | ❌ 不推荐 | ✅ 必须 | 数据变化快，L1 命中率低 |
| 测评详情 | ❌ 不推荐 | ✅ 可选 | 访问频率中等 |

## 5. 缓存策略实现

### 5.1 Repository 层缓存装饰器（统一模式）

**注意**：所有缓存装饰器都使用当前单实例 Redis。

所有 Repository 都支持可选的缓存装饰器：

```go
// 基础 Repository（无缓存）
baseRepo := mongo.NewRepository(db)

// 带缓存的 Repository（可选）
cachedRepo := cache.NewCachedRepository(baseRepo, redisClient)
```

**优势**：

- 统一模式，易于维护
- 可选启用，灵活配置
- 不侵入 domain 层

### 5.2 应用层查询缓存（结果缓存）

对于复杂查询结果，在应用层缓存：

```go
// 统计查询结果缓存（已实现）
cacheKey := fmt.Sprintf("stats:query:questionnaire:%d:%s", orgID, code)
cached := cache.GetQueryCache(ctx, cacheKey)
if cached != nil {
    return cached
}
// ... 查询数据库 ...
cache.SetQueryCache(ctx, cacheKey, result, 5*time.Minute)
```

## 6. 缓存失效策略

### 6.1 失效时机

| 操作 | 失效范围 | 实现位置 |
|------|---------|---------|
| 量表更新 | `scale:{code}` | Repository 层自动失效 |
| 量表下架 | `scale:{code}*` | Repository 层自动失效 |
| 问卷更新 | `questionnaire:{code}:*` | Repository 层自动失效 |
| 测评提交/更新 | `assessment:status:{id}` | Application Service（Write-Through） |
| 测评保存/删除 | `assessment:detail:{id}` | Repository 层自动失效 |
| 受试者更新/删除 | `testee:info:{id}` | Repository 层自动失效 |
| 计划保存 | `plan:info:{id}` | Repository 层自动失效 |
| 统计更新 | `stats:query:*` | 统计服务（TTL 自动失效） |

### 6.2 失效模式

**精确失效**（推荐）：

- 更新时删除对应的缓存键
- 适用于：量表、问卷、测评详情

**模式失效**（批量）：

- 使用 `SCAN` 或 `KEYS` 匹配模式删除
- 适用于：量表下架（删除所有版本）

**TTL 失效**（自动）：

- 设置合理的 TTL，自动过期
- 适用于：统计查询、临时数据

## 7. 缓存预热策略

### 7.1 启动时预热

**必预热**（高频访问）：

- 已发布的常用量表（SDS、SAS、Conners 等）
- 系统配置数据

**可选预热**（按需）：

- 最近 7 天活跃的问卷
- 热门受试者的基本信息

### 6.2 事件驱动预热

- 量表发布时立即预热
- 问卷创建时预热关联量表

### 6.3 定时预热

- 每天凌晨预热当日热点数据
- 根据访问日志动态调整预热列表

## 7. 缓存监控与管理

### 8.1 监控指标

```go
// 缓存指标
type CacheMetrics struct {
    HitRate      float64  // 命中率
    MissRate     float64  // 未命中率
    AvgLatency   float64  // 平均延迟（ms）
    ErrorRate    float64  // 错误率
    MemoryUsage  int64    // 内存使用（bytes）
    KeyCount     int64    // 键数量
}
```

### 8.2 缓存管理接口

```go
// CacheManager 缓存管理器
type CacheManager interface {
    // 获取缓存统计
    GetStats(ctx context.Context) (*CacheMetrics, error)
    
    // 清空指定模式的缓存
    ClearPattern(ctx context.Context, pattern string) error
    
    // 预热指定数据
    Warmup(ctx context.Context, keys []string) error
    
    // 健康检查
    HealthCheck(ctx context.Context) error
}
```

## 9. 当前实现状态（2025-01-XX 更新）

### 9.1 已实现功能 ✅

**核心缓存（Repository 装饰器）**：

- ✅ **量表缓存**：`CachedScaleRepository`，Cache-Aside 模式，TTL=24h
- ✅ **问卷缓存**：`CachedQuestionnaireRepository`，Cache-Aside 模式，TTL=12h
- ✅ **Assessment 状态缓存**：`AssessmentStatusCache`，Write-Through 模式，TTL=30m，已集成到应用服务
- ✅ **Assessment 详情缓存**：`CachedAssessmentRepository`，Cache-Aside 模式，TTL=2h
- ✅ **Testee 信息缓存**：`CachedTesteeRepository`，Cache-Aside 模式，TTL=2h
- ✅ **Plan 信息缓存**：`CachedPlanRepository`，Cache-Aside 模式，TTL=2h

**应用层缓存**：

- ✅ **统计查询缓存**：`StatisticsCache.GetQueryCache/SetQueryCache`，TTL=5m
- ✅ **事件幂等性**：`StatisticsCache.IsEventProcessed/MarkEventProcessed`，TTL=7d

**基础设施**：

- ✅ **统一缓存接口**：`Cache`、`TypedCache`、`CacheKeyBuilder`
- ✅ **Redis 实现**：`RedisCache` 实现 `Cache` 接口
- ✅ **TypedCache 实现**：`TypedRedisCache[T]`，类型安全的缓存操作
- ✅ **缓存监控**：`MetricsCollector`、`MetricsCache`，支持命中率、延迟、错误率统计
- ✅ **缓存管理**：`CacheManagerImpl` 实现 `CacheManager` 接口
- ✅ **缓存预热**：`WarmupService` 支持量表、问卷、统计预热

**模块集成**：

- ✅ Scale 模块自动使用缓存装饰器
- ✅ Survey 模块自动使用缓存装饰器
- ✅ Assessment 应用服务集成状态缓存（Write-Through）
- ✅ 服务启动时自动预热热点数据

### 9.2 待实现功能 ❌

**低优先级**：

- [ ] L1 本地内存缓存（热点数据，sync.Map 或 LRU）
- [ ] 缓存压缩（大数据场景使用 gzip）
- [ ] 智能预热（基于访问日志的预热策略）
- [ ] 集成新缓存到容器（Assessment、Testee、Plan 缓存的容器集成）

## 10. 实现优先级

### Phase 1（已完成）✅

- [x] 量表缓存（Repository 装饰器）
- [x] 问卷缓存（Repository 装饰器）
- [x] 统计查询结果缓存
- [x] 事件幂等性缓存
- [x] 启动时预热

### Phase 2（已完成）✅

- [x] Assessment 状态缓存（Write-Through）
- [x] Assessment 详情缓存（Cache-Aside）
- [x] Testee 信息缓存（Cache-Aside）
- [x] Plan 信息缓存（Cache-Aside）
- [x] 统一缓存接口抽象（Cache、TypedCache）
- [x] TypedCache 类型化缓存实现
- [x] 缓存监控指标（MetricsCollector、MetricsCache）
- [x] 缓存管理接口（CacheManager）

### Phase 3（待实现）

- [ ] L1 本地内存缓存（热点数据）
- [ ] 测评详情缓存
- [ ] 缓存管理接口
- [ ] 缓存预热优化（事件驱动）

### Phase 4（长期）

- [ ] 分布式缓存一致性（多实例）
- [ ] 缓存降级策略优化
- [ ] 智能预热（基于访问日志）
- [ ] 缓存压缩（大数据场景）

## 11. 最佳实践

### 10.1 缓存使用原则

1. **只缓存读多写少的数据**
2. **设置合理的 TTL**，避免数据过期
3. **失效策略要明确**，保证数据一致性
4. **监控缓存命中率**，优化缓存策略
5. **降级策略要完善**，Redis 不可用时不影响业务

### 10.2 避免的陷阱

1. ❌ **缓存穿透**：查询不存在的数据
   - 解决：空值缓存 + 布隆过滤器

2. ❌ **缓存击穿**：热点数据过期
   - 解决：互斥锁 + 异步刷新

3. ❌ **缓存雪崩**：大量缓存同时过期
   - 解决：随机 TTL + 多级缓存

4. ❌ **过度缓存**：缓存不必要的数据
   - 解决：根据访问频率决定

### 10.3 性能优化建议

1. **批量操作**：使用 `MGet`/`MSet` 减少网络往返
2. **Pipeline**：预热时使用 Redis Pipeline
3. **压缩**：大数据使用压缩（如 gzip）
4. **序列化优化**：选择高效的序列化格式（JSON/MessagePack）

## 12. 配置示例

```yaml
# configs/apiserver.prod.yaml
redis:
  # Cache Redis - 用于缓存（量表、问卷、统计查询等）
  cache:
    host: redis-cache.example.com
    port: 6379
    database: 0
    max-idle: 50
    max-active: 100
  
  # Store Redis - 用于持久化存储（CodesService、队列等）
  store:
    host: redis.example.com
    port: 6380
    database: 1
    max-idle: 50
    max-active: 100

cache:
  
  # 缓存策略配置
  strategies:
    scale:
      enabled: true
      ttl: 24h
      warmup: true
      warmup_keys: ["SDS", "SAS", "Conners"]
    
    questionnaire:
      enabled: true
      ttl: 12h
      warmup: false
    
    assessment_status:
      enabled: true
      ttl: 30m
      write_through: true  # 写透模式
    
    statistics:
      enabled: true
      ttl: 5m
      auto_refresh: true  # 自动刷新
  
  # L1 本地缓存（可选）
  local:
    enabled: false
    max_size: 100
    ttl: 1h
```
