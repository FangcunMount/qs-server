# 提交排队与限流策略说明

> 适用范围：collection-server（提交入口）  
> 目标：在高峰下保护服务、平滑突发流量、避免请求堆积拖垮下游

---

## 1. 背景

在提交类请求（如答卷提交）高峰时，直接同步处理会导致：

- gRPC 与数据库瞬时负载过高
- 请求排队在网络层，最终放大延迟
- 服务被打满后进入雪崩

因此我们采用**限流 + 排队 + 202 返回**的方式：

- 限流：保护服务不被打穿
- 排队：短时缓冲突发流量
- 202 返回：快速释放请求资源，避免阻塞

---

## 2. 处理流程（提交类）

以 `POST /api/v1/answersheets` 为例：

1. 入口限流（429 + Retry-After）
2. 提交进入队列（内存有界队列）
3. 如果在 `wait_timeout_ms` 内处理完成 → 返回 200
4. 如果超过等待阈值 → 返回 202（queued）
5. 队列满 → 返回 429（queue full）

简化流程图：

```
客户端 --> 限流(429) --> 通过 --> 入队
                         |--> 200 (短时完成)
                         |--> 202 (排队中)
                         |--> 429 (队列满)
```

---

## 3. 返回结果

### 3.1 正常完成（HTTP 200）

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": "123456",
    "message": "ok"
  }
}
```

### 3.2 排队中（HTTP 202）

```json
{
  "code": 0,
  "message": "accepted",
  "data": {
    "status": "queued",
    "request_id": "c6a0b5f2-acde-4a87-8d86-6f0c3b9d1f5e"
  }
}
```

### 3.3 提交状态查询（HTTP 200）

接口：`GET /api/v1/answersheets/submit-status?request_id=...`

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "status": "queued",
    "updated_at": 1737512345
  }
}
```

当状态为 `done` 时会返回 `answersheet_id`：

```json
{
  "code": 0,
  "message": "success",
  "data": {
    "status": "done",
    "answersheet_id": "123456",
    "updated_at": 1737512399
  }
}
```

### 3.4 队列满（HTTP 429）

```json
{
  "code": 429,
  "message": "submit queue full"
}
```

### 3.5 限流（HTTP 429）

限流会返回 `Retry-After`，客户端应退避重试：

```
Retry-After: 1
```

---

## 4. 配置参数

### 4.1 限流配置（collection-server）

配置文件：`configs/collection-server.dev.yaml` / `configs/collection-server.prod.yaml`

```yaml
rate_limit:
  enabled: true
  submit_global_qps: 200
  submit_global_burst: 300
  submit_user_qps: 5
  submit_user_burst: 10
  query_global_qps: 200
  query_global_burst: 300
  query_user_qps: 10
  query_user_burst: 20
  wait_report_global_qps: 80
  wait_report_global_burst: 120
  wait_report_user_qps: 2
  wait_report_user_burst: 5
```

### 4.2 提交排队配置

```yaml
submit_queue:
  enabled: true
  queue_size: 1000
  worker_count: 8
  wait_timeout_ms: 200
```

含义：

- `queue_size`：队列容量（请求数上限）
- `worker_count`：并发处理工作协程数
- `wait_timeout_ms`：服务端等待结果的最大时间，超过则返回 202

---

## 5. 客户端建议

### 提交类

- 遇到 202：提示“已受理，请稍后查询状态”
- 使用 `request_id` 调用提交状态查询接口，状态 `done` 后再拉取答卷详情
- 遇到 429：读取 `Retry-After`，退避重试（1s/2s/4s…）

### 查询类

- 高频查询建议退避或使用已有长轮询接口

---

## 6. 风险与限制

- 队列是内存实现，进程重启会丢失队列
- 202 返回不包含最终结果，需要客户端后续查询
- 该方案适合“短时突发”，不适合“持续超载”

---

## 7. 监控建议（可选）

建议统计：

- 排队命中率（202 次数）
- 队列满次数（429 queue full）
- 真实限流次数（429 limit exceeded）
- 平均排队时间与处理时长

---

## 8. 变更位置（代码）

- 排队逻辑：`internal/collection-server/application/answersheet/submit_queue.go`
- 提交服务：`internal/collection-server/application/answersheet/submission_service.go`
- 提交接口：`internal/collection-server/interface/restful/handler/answersheet_handler.go`
- 配置项：`internal/collection-server/options/options.go`

---

## 9. 常见问题

**Q: 为什么不在服务端 sleep 等待？**  
A: 会占用 worker，放大资源压力，不能保护系统。

**Q: 202 的 request_id 有什么用？**  
A: 用于客户端侧追踪；可扩展为“排队状态查询接口”。

**Q: 队列满了怎么办？**  
A: 返回 429，客户端退避重试；必要时调大 `queue_size` 或扩容实例。
