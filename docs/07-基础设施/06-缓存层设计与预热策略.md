# 缓存层设计与预热策略

## 1. 缓存架构设计

### 1.1 两级缓存架构

```text
                    [客户端请求]
                          ↓
                  [qs-apiserver]
                          ↓
            ┌─────────────┴─────────────┐
            ↓                           ↓
    [L1: 本地内存缓存]          [L2: Redis 缓存]
    - 热点量表配置              - 量表完整数据
    - 常用问卷模板              - 统计查询结果
    - 配置数据                  - Assessment 状态
            ↓                           ↓
            └─────────────┬─────────────┘
                          ↓
                    [持久层：MySQL/MongoDB]
```

### 1.2 缓存分类

| 缓存类型 | 存储位置 | TTL | 用途 |
|---------|---------|-----|------|
| **量表数据** | Redis (L2) | 24小时 | 量表配置、因子、规则 |
| **统计查询结果** | Redis (L2) | 5分钟 | 问卷/受试者/计划统计 |
| **事件幂等性** | Redis (L2) | 7天 | 防止重复处理 |
| **热点量表** | 本地内存 (L1) | 进程生命周期 | 高频访问量表（可选） |

## 2. 缓存装饰器模式

### 2.1 Repository 层缓存装饰器

在 `infra` 层实现缓存装饰器，遵循 DDD 边界：

```go
// internal/apiserver/infra/cache/scale_cache.go
type CachedScaleRepository struct {
    repo   scale.Repository
    client redis.UniversalClient
    ttl    time.Duration
}
```

**优势**：
- 不侵入 domain 层
- 可选的缓存层（Redis 不可用时降级）
- 符合开闭原则

### 2.2 缓存键设计

```
scale:{code}:{version}          # 量表数据
stats:query:{type}:{key}         # 统计查询结果
event:processed:{event_id}       # 事件幂等性
```

## 3. 缓存预热策略

### 3.1 预热时机

**服务启动时预热**（推荐）：
- 在 `PrepareRun()` 中，容器初始化完成后
- 异步预热，不阻塞服务启动
- 失败不影响服务启动

**事件驱动预热**（可选）：
- 量表发布时立即预热
- 问卷创建时预热关联量表

### 3.2 预热数据范围

**必预热**（高频访问）：
- 已发布的常用量表（SDS、SAS、Conners 等）
- 系统配置数据

**可选预热**（按需）：
- 最近 7 天活跃的问卷
- 热门受试者的基本信息

### 3.3 预热实现位置

在 `server.go` 的 `PrepareRun()` 方法中，容器初始化后添加：

```go
// 异步预热缓存（不阻塞启动）
go func() {
    if err := s.container.WarmupCache(context.Background()); err != nil {
        logger.L(context.Background()).Warnw("Cache warmup failed", "error", err)
    }
}()
```

## 4. 缓存失效策略

### 4.1 主动失效

| 事件 | 失效范围 | 实现位置 |
|------|---------|---------|
| 量表更新 | `scale:{code}:{version}` | Worker handler |
| 量表下架 | `scale:{code}:*` | Worker handler |
| 统计数据更新 | `stats:query:*` | 统计服务层 |

### 4.2 TTL 失效

- 量表数据：24 小时（几乎不变）
- 统计查询：5 分钟（实时性要求）
- 事件幂等性：7 天（足够长）

## 5. 降级策略

### 5.1 Redis 不可用

- 缓存装饰器检测 Redis 连接失败
- 自动降级到直接查询数据库
- 记录降级日志，不影响业务

### 5.2 缓存穿透保护

- 空值缓存（防止频繁查询不存在的 key）
- 布隆过滤器（可选，大数据量场景）

## 6. 监控指标

- 缓存命中率（Hit Rate）
- 缓存预热耗时
- Redis 连接状态
- 降级次数

## 7. 实现优先级

**Phase 1（当前）**：
- ✅ 统计缓存（StatisticsCache）
- ✅ 事件幂等性缓存
- ⏳ 量表缓存装饰器
- ⏳ 启动时预热

**Phase 2（优化）**：
- L1 本地内存缓存（热点数据）
- 缓存预热监控
- 布隆过滤器防穿透

