# 缓存层设计与预热策略 - 实现总结

## 已实现功能

### 1. 缓存装饰器模式

**文件**: `internal/apiserver/infra/cache/scale_cache.go`

- ✅ 实现了 `CachedScaleRepository`，装饰原有的 `scale.Repository`
- ✅ 支持 Cache-Aside 模式（先查缓存，未命中再查数据库）
- ✅ 自动降级：Redis 不可用时直接查询数据库
- ✅ 使用 PO（持久化对象）作为缓存数据格式，通过 mapper 转换

**关键方法**：
- `FindByCode`: 优先从缓存读取，未命中时查询数据库并写入缓存
- `Create/Update/Remove`: 操作数据库后自动更新/失效缓存

### 2. 缓存预热服务

**文件**: `internal/apiserver/infra/cache/warmup.go`

- ✅ 实现了 `WarmupService`，提供缓存预热能力
- ✅ `WarmupDefaultScales`: 预热默认热点量表（SDS、SAS、Conners）
- ✅ 支持自定义量表编码列表预热

### 3. 容器集成

**文件**: `internal/apiserver/container/container.go`

- ✅ `WarmupCache`: 容器级别的缓存预热方法
- ✅ 在服务启动时异步调用，不阻塞启动流程

**文件**: `internal/apiserver/container/assembler/scale.go`

- ✅ Scale 模块初始化时支持传入 Redis 客户端
- ✅ 自动为 Repository 添加缓存装饰器（如果 Redis 可用）

### 4. 服务启动集成

**文件**: `internal/apiserver/server.go`

- ✅ 在 `PrepareRun()` 中，容器初始化完成后异步预热缓存
- ✅ 预热失败不影响服务启动，仅记录警告日志

## 使用方式

### 配置热点量表

修改 `internal/apiserver/infra/cache/warmup.go` 中的 `defaultHotScales`：

```go
defaultHotScales := []string{
    "SDS",      // 抑郁自评量表
    "SAS",      // 焦虑自评量表
    "Conners",  // Conners 量表
    // 添加更多常用量表编码
}
```

### 自定义预热

在需要的地方调用：

```go
warmupSvc := cache.NewWarmupService(scaleRepo)
hotScales := []string{"SDS", "SAS", "CustomScale"}
err := warmupSvc.WarmupScaleCache(ctx, hotScales)
```

## 缓存键设计

```
scale:{code}  # 量表数据，TTL=24小时
```

## 缓存失效

当前由 Worker 的事件处理器负责：
- `handleScaleUpdated`: 更新时删除缓存
- `handleScaleUnpublished`: 下架时删除缓存
- `handleScaleArchived`: 归档时清除所有版本缓存

## 性能优化建议

1. **监控缓存命中率**：添加 metrics 统计缓存命中/未命中次数
2. **L1 本地缓存**：对于超高频量表，可考虑添加进程内缓存（如 sync.Map）
3. **批量预热**：预热时使用 pipeline 批量写入 Redis
4. **预热策略**：根据实际访问日志动态调整热点量表列表

## 注意事项

1. **序列化格式**：缓存使用 PO（持久化对象）格式，通过 mapper 转换，确保兼容性
2. **降级策略**：Redis 不可用时自动降级，不影响业务
3. **异步预热**：预热在后台异步执行，不阻塞服务启动
4. **缓存一致性**：更新/删除操作会立即失效缓存，保证一致性

