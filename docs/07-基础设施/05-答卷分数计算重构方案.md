# 答卷分数计算重构方案

> **设计目标**：将答卷分数计算从 Evaluation 域移到 Survey 域，符合 DDD 界限上下文原则

## 1. 问题分析

### 当前架构问题

```
┌─────────────────────────────────────────────────────────────────┐
│  当前流程（存在问题）                                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. AnswerSheet.Submit() [Survey 域]                            │
│      ├─ 验证答案                                                 │
│      ├─ 创建答卷（分数为0）                                      │
│      └─ 发布 answersheet.submitted 事件                         │
│                                                                  │
│  2. Worker 接收事件                                              │
│      └─ CreateAssessmentFromAnswerSheet()                       │
│                                                                  │
│  3. Assessment.AutoSubmit() [Evaluation 域]                     │
│      └─ 触发评估流程                                             │
│                                                                  │
│  4. EvaluationPipeline [Evaluation 域]                          │
│      ├─ AnswerSheetScoreHandler ❌ 跨界限上下文                  │
│      │   └─ 计算答卷分数（应该在 Survey 域）                     │
│      ├─ AssessmentScoreHandler                                  │
│      │   └─ 计算测评分数（因子得分、风险等级）                   │
│      └─ InterpretationHandler                                   │
│          └─ 生成解读报告                                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**核心问题**：
1. **跨界限上下文**：`AnswerSheetScoreHandler` 在 Evaluation 域中计算 Survey 域的数据
2. **职责不清**：答卷分数是问卷的概念，不应该由评估流程计算
3. **时序错误**：答卷提交时就应该完成计分，而不是等到评估时

---

## 2. 优化方案

### 目标架构

```
┌─────────────────────────────────────────────────────────────────┐
│  优化后流程（符合 DDD 原则）                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. AnswerSheet.Submit() [Survey 域]                            │
│      ├─ 验证答案                                                 │
│      ├─ 创建答卷（分数为0）✅                                     │
│      └─ 发布 answersheet.submitted 事件                         │
│                                                                  │
│  2. Worker 接收 answersheet.submitted                           │
│      ├─ 调用 AnswerSheetScoringService.Calculate() ✅ 新增     │
│      │   └─ 计算每个答案的分数                                   │
│      │   └─ 计算答卷总分                                         │
│      │   └─ 更新答卷分数                                         │
│      │   └─ 发布 answersheet.scored 事件 ✅ 新增                │
│      └─ CreateAssessmentFromAnswerSheet()                       │
│                                                                  │
│  3. Assessment.AutoSubmit() [Evaluation 域]                     │
│      └─ 触发评估流程                                             │
│                                                                  │
│  4. EvaluationPipeline [Evaluation 域]                          │
│      ├─ FactorScoreHandler ✅ 重命名，使用已计算好的答卷分数     │
│      │   └─ 从答卷读取分数并聚合为因子得分                       │
│      ├─ AssessmentScoreHandler                                  │
│      │   └─ 计算测评分数（因子得分、风险等级）                   │
│      └─ InterpretationHandler                                   │
│          └─ 生成解读报告                                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 详细设计

### 3.1 Survey 域：新增答卷计分服务

#### 领域服务接口

```go
// internal/apiserver/domain/survey/answersheet/scoring.go

package answersheet

import (
	"context"
	"github.com/FangcunMount/qs-server/internal/apiserver/domain/survey/questionnaire"
)

// ScoringService 答卷计分领域服务
// 职责：根据问卷的评分规则计算答案得分
type ScoringService interface {
	// CalculateAnswerScore 计算单个答案的得分
	// 根据问题类型和选项配置计算分数
	CalculateAnswerScore(answer Answer, question questionnaire.Question) (float64, error)

	// CalculateAnswerSheetScore 计算整个答卷的得分
	// 返回每个答案的得分和总分
	CalculateAnswerSheetScore(ctx context.Context, sheet *AnswerSheet, qnr *questionnaire.Questionnaire) (*ScoredAnswerSheet, error)
}

// ScoredAnswerSheet 已计分的答卷（值对象）
type ScoredAnswerSheet struct {
	AnswerSheetID  ID
	TotalScore     float64
	ScoredAnswers  []ScoredAnswer // 每个答案的得分详情
}

// ScoredAnswer 已计分的答案
type ScoredAnswer struct {
	QuestionCode string
	Score        float64
	MaxScore     float64 // 该题满分
}

// UpdateScores 更新答卷分数（聚合根方法）
func (a *AnswerSheet) UpdateScores(scoredSheet *ScoredAnswerSheet) error {
	// 更新每个答案的分数
	answerMap := make(map[string]Answer)
	for _, ans := range a.answers {
		answerMap[ans.QuestionCode()] = ans
	}

	updatedAnswers := make([]Answer, 0, len(a.answers))
	for _, scoredAns := range scoredSheet.ScoredAnswers {
		if ans, found := answerMap[scoredAns.QuestionCode]; found {
			// 使用不可变模式更新分数
			updatedAnswers = append(updatedAnswers, ans.WithScore(scoredAns.Score))
		}
	}

	a.answers = updatedAnswers
	a.score = scoredSheet.TotalScore
	return nil
}
```

#### 领域服务实现

```go
// internal/apiserver/domain/survey/answersheet/scoring_service.go

package answersheet

import (
	"context"
	"github.com/FangcunMount/qs-server/internal/apiserver/domain/survey/questionnaire"
)

type scoringService struct{}

func NewScoringService() ScoringService {
	return &scoringService{}
}

// CalculateAnswerScore 计算单个答案的得分
func (s *scoringService) CalculateAnswerScore(answer Answer, question questionnaire.Question) (float64, error) {
	switch question.GetType() {
	case questionnaire.QuestionTypeSingleChoice:
		return s.calculateSingleChoiceScore(answer, question)
	case questionnaire.QuestionTypeMultipleChoice:
		return s.calculateMultipleChoiceScore(answer, question)
	case questionnaire.QuestionTypeLikert:
		return s.calculateLikertScore(answer, question)
	case questionnaire.QuestionTypeText:
		return 0, nil // 文本题需要人工评分
	default:
		return 0, nil
	}
}

// calculateSingleChoiceScore 计算单选题得分
func (s *scoringService) calculateSingleChoiceScore(answer Answer, question questionnaire.Question) (float64, error) {
	// 获取答案值（选项编码）
	answerValue := answer.Value()
	selectedOption, ok := answerValue.(string)
	if !ok {
		return 0, nil
	}

	// 查找选项配置
	for _, opt := range question.GetOptions() {
		if opt.GetCode() == selectedOption {
			return float64(opt.GetScore()), nil
		}
	}

	return 0, nil
}

// calculateMultipleChoiceScore 计算多选题得分
func (s *scoringService) calculateMultipleChoiceScore(answer Answer, question questionnaire.Question) (float64, error) {
	// 获取答案值（选项编码数组）
	answerValue := answer.Value()
	selectedOptions, ok := answerValue.([]string)
	if !ok {
		return 0, nil
	}

	// 累加所有选中选项的分数
	var totalScore float64
	optionMap := make(map[string]int)
	for _, opt := range question.GetOptions() {
		optionMap[opt.GetCode()] = opt.GetScore()
	}

	for _, optCode := range selectedOptions {
		if score, found := optionMap[optCode]; found {
			totalScore += float64(score)
		}
	}

	return totalScore, nil
}

// calculateLikertScore 计算李克特量表得分
func (s *scoringService) calculateLikertScore(answer Answer, question questionnaire.Question) (float64, error) {
	// 李克特量表通常是数字评分（1-5, 1-7等）
	answerValue := answer.Value()
	
	// 支持数字或字符串形式的选项
	switch v := answerValue.(type) {
	case int:
		return float64(v), nil
	case float64:
		return v, nil
	case string:
		// 查找选项配置（如果是选项编码）
		return s.calculateSingleChoiceScore(answer, question)
	default:
		return 0, nil
	}
}

// CalculateAnswerSheetScore 计算整个答卷的得分
func (s *scoringService) CalculateAnswerSheetScore(ctx context.Context, sheet *AnswerSheet, qnr *questionnaire.Questionnaire) (*ScoredAnswerSheet, error) {
	// 构建问题映射
	questionMap := make(map[string]questionnaire.Question)
	for _, q := range qnr.GetQuestions() {
		questionMap[q.GetCode().Value()] = q
	}

	// 计算每个答案的得分
	scoredAnswers := make([]ScoredAnswer, 0, len(sheet.Answers()))
	var totalScore float64

	for _, ans := range sheet.Answers() {
		question, found := questionMap[ans.QuestionCode()]
		if !found {
			continue // 跳过找不到问题定义的答案
		}

		score, err := s.CalculateAnswerScore(ans, question)
		if err != nil {
			return nil, err
		}

		scoredAnswers = append(scoredAnswers, ScoredAnswer{
			QuestionCode: ans.QuestionCode(),
			Score:        score,
			MaxScore:     float64(question.GetMaxScore()), // 假设问题有MaxScore属性
		})

		totalScore += score
	}

	return &ScoredAnswerSheet{
		AnswerSheetID: sheet.ID(),
		TotalScore:    totalScore,
		ScoredAnswers: scoredAnswers,
	}, nil
}
```

---

### 3.2 应用层：答卷计分服务

```go
// internal/apiserver/application/survey/answersheet/scoring_service.go

package answersheet

import (
	"context"
	"github.com/FangcunMount/component-base/pkg/logger"
	"github.com/FangcunMount/qs-server/internal/apiserver/domain/survey/answersheet"
	"github.com/FangcunMount/qs-server/internal/apiserver/domain/survey/questionnaire"
)

// AnswerSheetScoringService 答卷计分应用服务
type AnswerSheetScoringService interface {
	// CalculateAndSave 计算并保存答卷分数
	CalculateAndSave(ctx context.Context, answerSheetID uint64) error
}

type answerSheetScoringService struct {
	answerSheetRepo   answersheet.Repository
	questionnaireRepo questionnaire.Repository
	scoringService    answersheet.ScoringService
}

func NewAnswerSheetScoringService(
	answerSheetRepo answersheet.Repository,
	questionnaireRepo questionnaire.Repository,
	scoringService answersheet.ScoringService,
) AnswerSheetScoringService {
	return &answerSheetScoringService{
		answerSheetRepo:   answerSheetRepo,
		questionnaireRepo: questionnaireRepo,
		scoringService:    scoringService,
	}
}

func (s *answerSheetScoringService) CalculateAndSave(ctx context.Context, answerSheetID uint64) error {
	l := logger.L(ctx)

	// 1. 加载答卷
	sheet, err := s.answerSheetRepo.FindByID(ctx, meta.ID(answerSheetID))
	if err != nil {
		return err
	}

	// 2. 加载问卷
	qnr, err := s.questionnaireRepo.FindByCode(ctx, sheet.QuestionnaireRef().Code())
	if err != nil {
		return err
	}

	// 3. 计算分数
	scoredSheet, err := s.scoringService.CalculateAnswerSheetScore(ctx, sheet, qnr)
	if err != nil {
		return err
	}

	// 4. 更新答卷分数
	if err := sheet.UpdateScores(scoredSheet); err != nil {
		return err
	}

	// 5. 持久化
	if err := s.answerSheetRepo.Update(ctx, sheet); err != nil {
		return err
	}

	l.Infow("答卷计分完成",
		"answersheet_id", answerSheetID,
		"total_score", scoredSheet.TotalScore,
		"scored_answer_count", len(scoredSheet.ScoredAnswers),
	)

	return nil
}
```

---

### 3.3 gRPC 接口：内部服务

```go
// internal/apiserver/interface/grpc/proto/internalapi/internal.proto

message CalculateAnswerSheetScoreRequest {
  uint64 answersheet_id = 1;
}

message CalculateAnswerSheetScoreResponse {
  bool success = 1;
  float total_score = 2;
  string message = 3;
}

service InternalService {
  // 计算答卷分数
  rpc CalculateAnswerSheetScore(CalculateAnswerSheetScoreRequest) returns (CalculateAnswerSheetScoreResponse);
  
  // ... 其他方法
}
```

```go
// internal/apiserver/interface/grpc/service/internal.go

func (s *internalService) CalculateAnswerSheetScore(
	ctx context.Context, 
	req *pb.CalculateAnswerSheetScoreRequest,
) (*pb.CalculateAnswerSheetScoreResponse, error) {
	l := logger.L(ctx)

	l.Infow("gRPC: 收到答卷计分请求",
		"action", "calculate_answersheet_score",
		"answersheet_id", req.AnswersheetId,
	)

	err := s.answerSheetScoringService.CalculateAndSave(ctx, req.AnswersheetId)
	if err != nil {
		l.Errorw("答卷计分失败",
			"answersheet_id", req.AnswersheetId,
			"error", err.Error(),
		)
		return &pb.CalculateAnswerSheetScoreResponse{
			Success: false,
			Message: err.Error(),
		}, nil
	}

	return &pb.CalculateAnswerSheetScoreResponse{
		Success: true,
		Message: "计分成功",
	}, nil
}
```

---

### 3.4 Worker 处理器更新

```go
// internal/worker/handlers/answersheet_handler.go

func handleAnswerSheetSubmitted(deps *Dependencies) HandlerFunc {
	return func(ctx context.Context, eventType string, payload []byte) error {
		var data AnswerSheetSubmittedPayload
		env, err := ParseEventData(payload, &data)
		if err != nil {
			return fmt.Errorf("failed to parse answersheet submitted event: %w", err)
		}

		deps.Logger.Info("processing answersheet submitted",
			slog.String("event_id", env.ID),
			slog.String("answersheet_id", data.AnswerSheetID),
		)

		// 检查 InternalClient 是否可用
		if deps.InternalClient == nil {
			deps.Logger.Warn("InternalClient is not available")
			return nil
		}

		// 解析答卷 ID
		answerSheetID, err := strconv.ParseUint(data.AnswerSheetID, 10, 64)
		if err != nil {
			return fmt.Errorf("invalid answersheet_id format: %w", err)
		}

		// ✅ 新增：先计算答卷分数
		scoreReq := &pb.CalculateAnswerSheetScoreRequest{
			AnswersheetId: answerSheetID,
		}
		scoreResp, err := deps.InternalClient.CalculateAnswerSheetScore(ctx, scoreReq)
		if err != nil {
			deps.Logger.Error("failed to calculate answersheet score",
				slog.String("answersheet_id", data.AnswerSheetID),
				slog.String("error", err.Error()),
			)
			return fmt.Errorf("failed to calculate score: %w", err)
		}

		deps.Logger.Info("answersheet scored",
			slog.String("answersheet_id", data.AnswerSheetID),
			slog.Float64("total_score", scoreResp.TotalScore),
		)

		// 然后创建 Assessment
		assessmentReq := &pb.CreateAssessmentFromAnswerSheetRequest{
			AnswersheetId:        answerSheetID,
			QuestionnaireCode:    data.QuestionnaireCode,
			QuestionnaireVersion: data.QuestionnaireVersion,
			TesteeId:             data.TesteeID,
			OrgId:                data.OrgID,
			FillerId:             data.FillerID,
			FillerType:           data.FillerType,
			OriginType:           "adhoc",
		}

		assessmentResp, err := deps.InternalClient.CreateAssessmentFromAnswerSheet(ctx, assessmentReq)
		if err != nil {
			deps.Logger.Error("failed to create assessment",
				slog.String("answersheet_id", data.AnswerSheetID),
				slog.String("error", err.Error()),
			)
			return fmt.Errorf("failed to create assessment: %w", err)
		}

		deps.Logger.Info("assessment created from answersheet",
			slog.String("answersheet_id", data.AnswerSheetID),
			slog.Uint64("assessment_id", assessmentResp.AssessmentId),
		)

		return nil
	}
}
```

---

### 3.5 Evaluation 域：简化处理器

```go
// internal/apiserver/application/evaluation/engine/pipeline/factor_score.go
// 重命名：AnswerSheetScoreHandler → FactorScoreHandler

package pipeline

// FactorScoreHandler 因子分数聚合处理器
// 职责：从已计分的答卷中读取分数并按因子聚合
// 输入：Assessment、MedicalScale、AnswerSheet（已包含分数）
// 输出：填充 Context.FactorScores
type FactorScoreHandler struct {
	*BaseHandler
}

func NewFactorScoreHandler() *FactorScoreHandler {
	return &FactorScoreHandler{
		BaseHandler: NewBaseHandler("FactorScoreHandler"),
	}
}

func (h *FactorScoreHandler) Handle(ctx context.Context, evalCtx *Context) error {
	// 前置条件检查
	if evalCtx.MedicalScale == nil {
		return ErrMedicalScaleRequired
	}
	if evalCtx.AnswerSheet == nil {
		return ErrAnswerSheetRequired
	}

	// 构建答案得分映射（从答卷中读取已计算好的分数）
	scoreMap := h.buildScoreMap(evalCtx.AnswerSheet)

	// 获取量表因子
	factors := evalCtx.MedicalScale.GetFactors()
	factorScores := make([]assessment.FactorScoreResult, 0, len(factors))

	// 按因子聚合分数
	for _, factor := range factors {
		rawScore := h.aggregateFactorScore(factor, scoreMap)

		factorScore := assessment.NewFactorScoreResult(
			assessment.NewFactorCode(string(factor.GetCode())),
			factor.GetTitle(),
			rawScore,
			assessment.RiskLevelNone, // 风险等级由后续处理器计算
			"",
			"",
			factor.IsTotalScore(),
		)
		factorScores = append(factorScores, factorScore)
	}

	evalCtx.FactorScores = factorScores
	return h.Next(ctx, evalCtx)
}

// buildScoreMap 从答卷构建题目得分映射
func (h *FactorScoreHandler) buildScoreMap(sheet *answersheet.AnswerSheet) map[string]float64 {
	scoreMap := make(map[string]float64)
	for _, ans := range sheet.Answers() {
		// ✅ 直接使用答卷中已计算好的分数
		scoreMap[ans.QuestionCode()] = ans.Score()
	}
	return scoreMap
}

// aggregateFactorScore 聚合因子分数
func (h *FactorScoreHandler) aggregateFactorScore(factor *scale.Factor, scoreMap map[string]float64) float64 {
	questionCodes := factor.GetQuestionCodes()
	if len(questionCodes) == 0 {
		return 0
	}

	var scores []float64
	for _, qCode := range questionCodes {
		if score, found := scoreMap[qCode.String()]; found {
			scores = append(scores, score)
		}
	}

	if len(scores) == 0 {
		return 0
	}

	// 根据计分策略聚合
	return h.applyScoringStrategy(factor.GetScoringStrategy(), scores)
}

// applyScoringStrategy 应用计分策略（求和/平均/自定义）
func (h *FactorScoreHandler) applyScoringStrategy(strategy scale.ScoringStrategyCode, scores []float64) float64 {
	// ... 实现同原 AnswerSheetScoreHandler
}
```

---

## 4. 实施步骤

### 阶段 1：Survey 域扩展（1-2天）
1. ✅ 创建 `ScoringService` 领域服务接口
2. ✅ 实现 `scoringService` 计分逻辑
3. ✅ 在 `AnswerSheet` 聚合根添加 `UpdateScores` 方法
4. ✅ 编写单元测试

### 阶段 2：应用服务层（1天）
1. ✅ 创建 `AnswerSheetScoringService` 应用服务
2. ✅ 在 Container 中注册服务
3. ✅ 编写集成测试

### 阶段 3：gRPC 接口（1天）
1. ✅ 更新 `internal.proto`，添加 `CalculateAnswerSheetScore` 方法
2. ✅ 生成 protobuf 代码
3. ✅ 实现 `InternalService.CalculateAnswerSheetScore`

### 阶段 4：Worker 处理器更新（1天）
1. ✅ 修改 `handleAnswerSheetSubmitted`，先调用计分接口
2. ✅ 更新 gRPC 客户端，添加计分方法
3. ✅ 测试端到端流程

### 阶段 5：Evaluation 域简化（1天）
1. ✅ 重命名 `AnswerSheetScoreHandler` → `FactorScoreHandler`
2. ✅ 简化逻辑：从答卷读取已计算的分数
3. ✅ 更新 Pipeline 构建代码
4. ✅ 回归测试

### 阶段 6：清理与优化（1天）
1. ✅ 删除 Evaluation 域中的答卷计分逻辑
2. ✅ 更新相关文档
3. ✅ 性能测试

---

## 5. 测试策略

### 单元测试

```go
// internal/apiserver/domain/survey/answersheet/scoring_service_test.go

func TestScoringService_CalculateSingleChoiceScore(t *testing.T) {
	service := NewScoringService()
	
	// 创建测试问题
	question := questionnaire.NewSingleChoiceQuestion(
		meta.NewCode("Q1"),
		"你的年龄段是？",
		[]questionnaire.Option{
			questionnaire.NewOption("A", "18-25", 1),
			questionnaire.NewOption("B", "26-35", 2),
			questionnaire.NewOption("C", "36-45", 3),
		},
	)
	
	// 创建测试答案
	answer, _ := answersheet.NewAnswer(
		meta.NewCode("Q1"),
		questionnaire.QuestionTypeSingleChoice,
		"B", // 选择26-35
		0,
	)
	
	// 计算分数
	score, err := service.CalculateAnswerScore(answer, question)
	
	assert.NoError(t, err)
	assert.Equal(t, 2.0, score)
}
```

### 集成测试

```go
// internal/apiserver/application/survey/answersheet/scoring_service_test.go

func TestAnswerSheetScoringService_CalculateAndSave(t *testing.T) {
	// 准备测试数据
	ctx := context.Background()
	answerSheetID := uint64(123)
	
	// Mock 依赖
	mockRepo := answersheet.NewMockRepository()
	mockQnrRepo := questionnaire.NewMockRepository()
	
	// 创建服务
	service := NewAnswerSheetScoringService(
		mockRepo,
		mockQnrRepo,
		answersheet.NewScoringService(),
	)
	
	// 执行计分
	err := service.CalculateAndSave(ctx, answerSheetID)
	
	// 断言
	assert.NoError(t, err)
	// 验证分数是否正确更新
}
```

---

## 6. 性能影响分析

### 增加的开销
- **额外 gRPC 调用**：Worker → apiserver（计算答卷分数）
- **额外数据库操作**：更新答卷分数到 MongoDB

### 优化措施
1. **异步处理**：计分完成前不阻塞测评创建（如果业务允许）
2. **批量计分**：如果有大量答卷待计分，支持批量处理
3. **缓存优化**：问卷定义可以缓存到 Redis

### 预期影响
- 增加约 50-100ms 延迟（gRPC + MongoDB Update）
- 但符合架构原则，利于长期维护

---

## 7. 回滚计划

如果新架构有问题，可以快速回滚：

1. **禁用 Worker 中的计分调用**（注释掉）
2. **保留 AnswerSheetScoreHandler**（重命名为 FactorScoreHandler 前保留备份）
3. **数据兼容**：答卷分数字段即使为 0 也不影响评估流程

---

## 8. 总结

### 优点
✅ **符合 DDD 原则**：答卷计分在 Survey 域完成  
✅ **职责清晰**：Evaluation 域只负责测评分析  
✅ **易于扩展**：未来可以支持复杂的计分规则（加权、倒扣分等）  
✅ **数据完整性**：答卷提交后立即包含分数  
✅ **可测试性**：计分逻辑独立，易于单元测试

### 缺点
⚠️ **增加复杂度**：需要额外的服务和接口  
⚠️ **性能开销**：多一次 gRPC 调用和数据库更新  
⚠️ **实施成本**：需要约 1 周开发时间

### 建议
**推荐实施**，理由：
1. 架构更清晰，长期维护成本更低
2. 性能影响可控（50-100ms 可接受）
3. 为未来的计分规则扩展打好基础

---

**文档维护者**：开发团队  
**最后更新**：2025-12-13
