# 11-02 qs-apiserver 领域层代码结构设计（V2）

> 版本：V2.0
> 目标：将问卷&量表 BC 领域模型映射为 `qs-apiserver` / `qs-worker` 可复用的 Go 领域层代码结构。

本文档站在 **实现视角**，在《11-01-问卷&量表 BC 领域模型总览（V2）》基础上，给出：

* `internal/domain` 目录结构
* 各包核心聚合/实体/VO 的结构草图
* 仓储接口划分（MySQL / Mongo）
* qs-apiserver 与 qs-worker 共用领域模型的方式

---

## 1. 目录结构总览

### 1.1 整体结构

```text
internal/domain/
├── common/                          # 通用组件
│   ├── types.go                     # 通用 ID 类型、时间等基础类型
│   ├── errors.go                    # 领域错误定义
│   └── events.go                    # 领域事件基础接口
│
├── survey/                          # 问卷子域
│   ├── questionnaire.go             # 问卷聚合根
│   ├── question.go                  # 题目实体
│   ├── option.go                    # 选项值对象
│   ├── answer_sheet.go              # 答卷聚合根
│   ├── answer_item.go               # 答题项值对象
│   ├── validation_rule.go           # 校验规则配置
│   ├── scoring_config.go            # 计分配置（元数据）
│   ├── validator.go                 # 答卷校验器接口
│   ├── rule_factory.go              # 校验规则工厂
│   ├── repository.go                # 仓储接口定义
│   └── events.go                    # survey 子域事件
│
├── scale/                           # 量表子域
│   ├── medical_scale.go             # 量表聚合根
│   ├── factor.go                    # 因子实体
│   ├── interpretation_rule.go       # 解读规则值对象
│   ├── norm.go                      # 常模值对象
│   ├── evaluation_result.go         # 评估结果值对象
│   ├── evaluator.go                 # 评估器接口（职责链）
│   ├── scoring_strategy.go          # 题目计分策略接口
│   ├── factor_strategy.go           # 因子聚合策略接口
│   ├── scoring_factory.go           # 计分策略工厂
│   ├── eval_context.go              # 评估上下文
│   ├── eval_step.go                 # 评估步骤接口
│   ├── repository.go                # 仓储接口定义
│   └── events.go                    # scale 子域事件
│
├── assessment/                      # 测评案例子域
│   ├── assessment.go                # 测评案例聚合根
│   ├── assessment_score.go          # 因子得分实体
│   ├── interpret_report.go          # 解读报告聚合根
│   ├── dimension_report.go          # 维度报告值对象
│   ├── origin.go                    # 来源枚举（adhoc/plan/screening）
│   ├── status.go                    # 测评状态枚举
│   ├── report_factory.go            # 报告工厂接口
│   ├── repository.go                # 仓储接口定义
│   └── events.go                    # assessment 子域事件
│
├── user/                            # 用户子域（BC 内视图）
│   ├── testee.go                    # 受试者聚合根
│   ├── testee_profile.go            # 受试者档案值对象
│   ├── staff.go                     # 后台人员聚合根
│   ├── staff_role.go                # 人员角色枚举
│   ├── testee_factory.go            # 受试者工厂接口
│   ├── repository.go                # 仓储接口定义
│   └── events.go                    # user 子域事件
│
├── plan/                            # 测评计划子域
│   ├── assessment_plan.go           # 测评计划聚合根
│   ├── assessment_task.go           # 测评任务实体
│   ├── frequency_spec.go            # 频率规格值对象
│   ├── task_status.go               # 任务状态枚举
│   ├── repository.go                # 仓储接口定义
│   └── events.go                    # plan 子域事件
│
└── screening/                       # 入校筛查子域
    ├── screening_project.go         # 筛查项目聚合根
    ├── school_info.go               # 学校信息值对象
    ├── project_status.go            # 项目状态枚举
    ├── repository.go                # 仓储接口定义
    └── events.go                    # screening 子域事件
```

### 1.2 子域职责说明

#### survey（问卷子域）

* **核心职责**：管理问卷结构、答卷内容、校验规则
* **关注点**："怎么问""怎么填""答案是否合法"
* **不关心**：分数的业务含义、量表解读
* **主要聚合**：
  * `Questionnaire`：问卷模板，管理题目列表和版本
  * `AnswerSheet`：答卷实例，记录用户填写的答案
* **领域服务**：
  * `AnswerSheetValidator`：答卷校验器（策略模式）
  * `RuleFactory`：校验规则工厂

#### scale（量表子域）

* **核心职责**：管理量表定义、计分规则、解读规则
* **关注点**："量表语义""因子结构""如何算分和解读"
* **不关心**：问卷如何展示、用户如何填写
* **主要聚合**：
  * `MedicalScale`：量表定义，包含因子、常模、解读规则
* **领域服务**：
  * `Evaluator`：评估器（职责链模式）
  * `ScoringStrategy`：题目计分策略（策略模式）
  * `FactorStrategy`：因子聚合策略（策略模式）

#### assessment（测评案例子域）

* **核心职责**：管理一次具体测评行为的全生命周期
* **关注点**："谁在什么时候做了什么测评""状态流转""结果记录"
* **桥接角色**：连接 survey、scale、user、plan/screening
* **主要聚合**：
  * `Assessment`：测评案例，记录测评过程和状态
  * `InterpretReport`：解读报告，面向用户展示
* **领域服务**：
  * `ReportFactory`：报告工厂，组装解读报告

#### user（用户子域）

* **核心职责**：管理本 BC 内的用户视图
* **关注点**：受试者档案、后台人员角色
* **与 IAM 关系**：通过 ID 映射，不直接持有 IAM 聚合
* **主要聚合**：
  * `Testee`：受试者，测评的主体
  * `Staff`：后台人员，量表管理者
* **领域服务**：
  * `TesteeFactory`：受试者工厂，处理创建逻辑

#### plan（测评计划子域）

* **核心职责**：管理周期性测评计划
* **关注点**："按时间维度的测评安排"
* **主要聚合**：
  * `AssessmentPlan`：测评计划，面向单个 Testee
  * `AssessmentTask`：测评任务，某一次具体执行

#### screening（入校筛查子域）

* **核心职责**：管理批量筛查项目
* **关注点**："按项目/学校维度的批量测评"
* **主要聚合**：
  * `ScreeningProject`：筛查项目，面向班级/学校

### 1.3 依赖关系约束

为避免循环依赖，严格遵循以下依赖方向：

```text
┌────────────────────────────────────────┐
│           common（基础设施层）            │
└────────────────┬───────────────────────┘
                 │
        ┌────────┴────────┬───────────────────┬────────────┐
        │                 │                   │            │
    ┌───▼───┐      ┌─────▼─────┐      ┌─────▼─────┐  ┌──▼───┐
    │ user  │      │   plan    │      │ screening │  │survey│
    └───┬───┘      └─────┬─────┘      └─────┬─────┘  └──┬───┘
        │                │                   │           │
        └────────────────┴───────────────────┴──────────►│
                                                      ┌───▼───┐
                                                      │ scale │
                                                      └───┬───┘
                                                          │
                                              ┌───────────▼──────────┐
                                              │    assessment        │
                                              │   (桥接所有子域)      │
                                              └──────────────────────┘
```

**依赖规则**：

1. `common` 不依赖任何子域
2. `survey` 只依赖 `common`
3. `scale` 依赖 `survey`（只读访问 Question/AnswerSheet）
4. `user`、`plan`、`screening` 只依赖 `common`
5. `assessment` 依赖所有其他子域，作为桥接聚合
6. **禁止**：任何子域向 `assessment` 的反向依赖

### 1.4 跨服务共享

`qs-apiserver` 和 `qs-worker` 通过以下方式共享领域模型：

```text
qs-server (repository root)
├── internal/
│   └── domain/           # 共享领域层
│       ├── survey/
│       ├── scale/
│       ├── assessment/
│       └── ...
├── cmd/
│   ├── qs-apiserver/     # API 服务
│   │   └── main.go
│   └── qs-worker/        # 评估工作者
│       └── main.go
└── go.mod                # 统一的 module
```

或使用 `go.work`（多 module 场景）：

```text
qs-server/
├── shared/
│   └── domain/           # 共享领域层 (独立 module)
│       └── go.mod
├── qs-apiserver/
│   ├── go.mod
│   └── go.mod 引用 ../shared/domain
└── qs-worker/
    ├── go.mod
    └── go.mod 引用 ../shared/domain
```

**关键原则**：

* 领域层代码只有一份，避免重复
* 两个服务通过相同的领域对象进行通信
* 保证业务逻辑和不变量的一致性

---

## 2. common 包

ID、时间、通用枚举等定义在此，避免循环依赖。

示例：

```go
package common

type ID string
type Time = time.Time
```

各子域也可定义自己的 ID 类型（如 `type AssessmentID string`），common 包仅提供工具函数。

---

## 3. survey 包：问卷与答卷

**路径：** `internal/domain/survey`

核心聚合：

* `Questionnaire`：问卷模板
* `AnswerSheet`：答卷实例

示意：

```go
type QuestionnaireCode string
type QuestionID string

type Status string

const (
    StatusDraft     Status = "draft"
    StatusPublished Status = "published"
    StatusArchived  Status = "archived"
)

type Questionnaire struct {
    id          QuestionnaireCode
    code        string
    title       string
    description string
    version     int
    status      Status
    questions   []Question
    createdAt   time.Time
    updatedAt   time.Time
}
```

题目与选项：

```go
type QuestionType string

const (
    QuestionTypeSingleChoice QuestionType = "single_choice"
    QuestionTypeMultiChoice  QuestionType = "multi_choice"
    NumberQuestion       QuestionType = "number"
    TextQuestion         QuestionType = "text"
)

type RuleType string
type RuleConfig struct {
    Type   RuleType
    Params map[string]string
}

type ScoreStrategyCode string

type ScoringConfig struct {
    Strategy ScoreStrategyCode
    Params   map[string]string
}

type Question struct {
    id             QuestionID
    qType          QuestionType
    title          string
    required       bool
    options        []Option
    validationRule []RuleConfig
    scoringConfig  *ScoringConfig
}

type Option struct {
    code  string
    text  string
    value string
}
```

答卷：

```go
type AnswerSheetID string

type AnswerSheetStatus string

const (
    AnswerSheetStatusDraft     AnswerSheetStatus = "draft"
    AnswerSheetStatusSubmitted AnswerSheetStatus = "submitted"
)

type AnswerItem struct {
    QuestionID QuestionID
    Values     []string
}

type AnswerSheet struct {
    id                AnswerSheetID
    questionnaireCode Code
    items             []AnswerItem
    status            AnswerSheetStatus
    submittedAt       *time.Time
    createdAt         time.Time
    updatedAt         time.Time
}
```

校验接口（详见 12-01）：

```go
type AnswerSheetValidator interface {
    Validate(ctx context.Context, q *Questionnaire, s *AnswerSheet) error
}
```

仓储接口：

```go
type QuestionnaireRepository interface {
    FindByCode(ctx context.Context, code QuestionnaireCode) (*Questionnaire, error)
    FindByCode(ctx context.Context, code string) (*Questionnaire, error)
    Save(ctx context.Context, q *Questionnaire) error
}

type AnswerSheetRepository interface {
    FindByID(ctx context.Context, id AnswerSheetID) (*AnswerSheet, error)
    Save(ctx context.Context, s *AnswerSheet) error
}
```

---

## 4. scale 包：量表与评估

**路径：** `internal/domain/scale`

量表定义：

```go
type MedicalScaleID string
type FactorCode string

type Factor struct {
    Code        FactorCode
    Name        string
    QuestionIDs []survey.QuestionID
    Strategy    FactorScoreStrategyCode
    Params      map[string]string
}

type RiskLevel string

const (
    RiskLevelNone RiskLevel = "none"
    RiskLevelLow  RiskLevel = "low"
    RiskLevelMid  RiskLevel = "mid"
    RiskLevelHigh RiskLevel = "high"
)

type InterpretationRule struct {
    MinScore   float64
    MaxScore   float64
    RiskLevel  RiskLevel
    Conclusion string
    Suggestion string
}

type MedicalScale struct {
    id        MedicalScaleID
    code      string
    name      string
    version   int
    factors   []Factor
    rules     []InterpretationRule
    createdAt time.Time
    updatedAt time.Time
}
```

评估结果：

```go
type FactorScore struct {
    FactorCode FactorCode
    RawScore   float64
    RiskLevel  RiskLevel
}

type EvaluationResult struct {
    TotalScore   float64
    RiskLevel    RiskLevel
    FactorScores []FactorScore
    Conclusion   string
    Suggestion   string
}
```

Evaluator 接口（详见 12-02）：

```go
type Evaluator interface {
    Evaluate(
        ctx context.Context,
        scale *MedicalScale,
        questionnaire *survey.Questionnaire,
        sheet *survey.AnswerSheet,
    ) (*EvaluationResult, error)
}
```

---

## 5. assessment 包：测评案例

**路径：** `internal/domain/assessment`

Assessment：

```go
type AssessmentID string

type OriginType string

const (
    OriginTypeAdhoc     OriginType = "adhoc"
    OriginTypePlan      OriginType = "plan"
    OriginTypeScreening OriginType = "screening"
)

type Status string

const (
    StatusPending     Status = "pending"
    StatusSubmitted   Status = "submitted"
    StatusInterpreted Status = "interpreted"
    StatusFailed      Status = "failed"
)

type Assessment struct {
    id                AssessmentID
    testeeID          user.TesteeID
    questionnaireCode meta.Code
    answerSheetID     survey.AnswerSheetID
    medicalScaleID    *scale.MedicalScaleID
    originType        OriginType
    originID          *string
    status            Status
    totalScore        *float64
    riskLevel         *scale.RiskLevel
    createdAt         time.Time
    updatedAt         time.Time
    interpretedAt     *time.Time
}
```

维度分与报告：

```go
type AssessmentScore struct {
    AssessmentID AssessmentID
    FactorCode   scale.FactorCode
    RawScore     float64
    RiskLevel    scale.RiskLevel
}

type InterpretReportID = AssessmentID

type InterpretReport struct {
    ID          InterpretReportID
    ScaleName   string
    TotalScore  float64
    RiskLevel   scale.RiskLevel
    Dimensions  []DimensionReport
    Conclusion  string
    Suggestions []string
}

type DimensionReport struct {
    Code      scale.FactorCode
    Name      string
    Score     float64
    RiskLevel scale.RiskLevel
    Comment   string
}
```

仓储与事件接口：

```go
type AssessmentRepository interface {
    FindByID(ctx context.Context, id AssessmentID) (*Assessment, error)
    Save(ctx context.Context, a *Assessment) error
}

type InterpretReportRepository interface {
    FindByID(ctx context.Context, id InterpretReportID) (*InterpretReport, error)
    Save(ctx context.Context, r *InterpretReport) error
}

type AssessmentScoreRepository interface {
    SaveScores(ctx context.Context, scores []AssessmentScore) error
    FindByAssessmentID(ctx context.Context, id AssessmentID) ([]AssessmentScore, error)
}
```

---

## 6. user / plan / screening 包

这里只给简要草图，完整说明详见 11-03、12-05。

* `user`：Testee / Staff
* `plan`：AssessmentPlan / AssessmentTask
* `screening`：ScreeningProject

---

## 7. qs-apiserver 与 qs-worker 对领域层的使用

* **qs-apiserver**

  * 面向小程序/后台提供 API；
  * 主要职责：

    * 加载 Questionnaire / Testee / Staff；
    * 创建 & 校验 & 保存 AnswerSheet；
    * 创建 Assessment，发布 AssessmentSubmittedEvent；
    * 提供 Assessment / InterpretReport / AssessmentScore 查询；
  * 依赖：

    * `internal/domain/*` + `internal/infra`（仓储实现） + MQ Producer。

* **qs-worker**

  * 专职评估任务：

    * 消费 AssessmentSubmittedEvent；
    * 加载 Assessment / Questionnaire / AnswerSheet / MedicalScale；
    * 调用 scale.Evaluator；
    * 写回 AssessmentScore / InterpretReport / Assessment 状态；
    * 发布 AssessmentInterpretedEvent。
  * 依赖同一套 `internal/domain/*` 包。

---

## 8. 实施建议

1. 按本文档结构先搭起目录和 type stub，再逐步完善实现
2. 领域层不直接依赖 GORM/Mongo Driver，仅通过仓储接口进行 IO 操作
3. 严格控制依赖方向，禁止子域间的循环依赖
4. 优先抽象"行为"而非一次性预埋所有字段，保持聚合内不变量清晰

本结构是 V2 代码层面的蓝图，后续代码实现必须与之保持同步，重大调整时需同步更新本文档。
