name: CI/CD Pipeline

# ============================================================================
# å¿…éœ€çš„ Secrets é…ç½®
# ============================================================================
# Organization Secrets (ç»„ç»‡çº§åˆ«ï¼Œå…±äº«é…ç½®):
#   SVRA_HOST, SVRA_USERNAME, SVRA_SSH_KEY, SVRA_SSH_PORT
#   SVRA_SUDO_PASSWORD (å¯é€‰ï¼Œå¦‚æœ sudo éœ€è¦å¯†ç )
#   MONGODB_HOST, MONGODB_PORT
#   MYSQL_HOST, MYSQL_PORT (Worker ä½¿ç”¨)
#   REDIS_CACHE_HOST, REDIS_STORE_HOST
#   NSQ_NSQD_HOST, NSQ_NSQD_PORT, NSQ_LOOKUPD_HOST, NSQ_LOOKUPD_PORT
#   DOCKERHUB_USERNAME, DOCKERHUB_TOKEN
#
# Repository Secrets (ä»“åº“çº§åˆ«ï¼Œæ•æ„Ÿä¿¡æ¯):
#   MONGODB_USERNAME, MONGODB_PASSWORD, MONGODB_DBNAME
#   MYSQL_USERNAME, MYSQL_PASSWORD, MYSQL_DATABASE (Worker ä½¿ç”¨)
#   REDIS_CACHE_PORT/DB/USERNAME/PASSWORD
#   REDIS_STORE_PORT/DB/USERNAME/PASSWORD
#   JWT_SECRET
#   GRPC_APISERVER_ADDR (å¯é€‰ï¼Œé»˜è®¤ qs-apiserver:9090)
#   WWW_UID, WWW_GID (å¯é€‰ï¼Œé»˜è®¤ 1000/1000)
# ============================================================================

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      service:
        description: 'è¦éƒ¨ç½²çš„æœåŠ¡'
        required: true
        type: choice
        options:
          - all
          - apiserver
          - collection
          - worker
      docs_verify:
        description: 'è¿è¡Œæ–‡æ¡£æ ¡éªŒ (docs-verify)'
        required: false
        type: boolean
        default: false

env:
  DOCKER_REGISTRY: ghcr.io
  DOCKER_REPOSITORY: fangcunmount
  GOTOOLCHAIN: local
  DOCS_VERIFY: 'false' # éœ€è¦æ–‡æ¡£æ ¡éªŒæ—¶è®¾ä¸º 'true'ï¼ˆä¾‹å¦‚ workflow_dispatch æ‰‹åŠ¨è§¦å‘ï¼‰

jobs:
  # ==========================================================================
  # 1) æ ¡éªŒ Secretsï¼ˆåªåœ¨ main ä¸Šä¸¥æ ¼è¦æ±‚ï¼‰
  # ==========================================================================

  validate-secrets:
    name: Validate Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Check Required Secrets
        env:
          SVRA_HOST: ${{ secrets.SVRA_HOST }}
          SVRA_USERNAME: ${{ secrets.SVRA_USERNAME }}
          SVRA_SSH_KEY: ${{ secrets.SVRA_SSH_KEY }}
          MONGODB_HOST: ${{ secrets.MONGODB_HOST }}
          MONGODB_USERNAME: ${{ secrets.MONGODB_USERNAME }}
          MONGODB_PASSWORD: ${{ secrets.MONGODB_PASSWORD }}
          MONGODB_PORT: ${{ secrets.MONGODB_PORT }}
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          # å…¼å®¹ä¸¤ç§å‘½åï¼šä¼˜å…ˆ MYSQL_DATABASEï¼Œå…¶æ¬¡ MYSQL_DBNAME
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE != '' && secrets.MYSQL_DATABASE || secrets.MYSQL_DBNAME }}
          REDIS_CACHE_HOST: ${{ secrets.REDIS_CACHE_HOST }}
          REDIS_CACHE_PORT: ${{ secrets.REDIS_CACHE_PORT }}
          REDIS_CACHE_DB: ${{ secrets.REDIS_CACHE_DB }}
          REDIS_CACHE_USERNAME: ${{ secrets.REDIS_CACHE_USERNAME }}
          REDIS_CACHE_PASSWORD: ${{ secrets.REDIS_CACHE_PASSWORD }}
          REDIS_STORE_HOST: ${{ secrets.REDIS_STORE_HOST }}
          REDIS_STORE_PORT: ${{ secrets.REDIS_STORE_PORT }}
          REDIS_STORE_DB: ${{ secrets.REDIS_STORE_DB }}
          REDIS_STORE_USERNAME: ${{ secrets.REDIS_STORE_USERNAME }}
          REDIS_STORE_PASSWORD: ${{ secrets.REDIS_STORE_PASSWORD }}
          NSQ_NSQD_HOST: ${{ secrets.NSQ_NSQD_HOST }}
          NSQ_NSQD_PORT: ${{ secrets.NSQ_NSQD_PORT }}
          SVRA_SSH_PORT: ${{ secrets.SVRA_SSH_PORT }}
          SVRA_SUDO_PASSWORD: ${{ secrets.SVRA_SUDO_PASSWORD }}
          WWW_UID: ${{ secrets.WWW_UID }}
          WWW_GID: ${{ secrets.WWW_GID }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          echo "ğŸ” Validating GitHub Action secrets..."
          VALIDATION_FAILED=0
          ENFORCE_REQUIRED=0

          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENFORCE_REQUIRED=1
            echo "ğŸ“‹ Checking required secrets for main branch deployment..."
          else
            echo "â„¹ï¸ Not on main branch â€“ required secrets reported for awareness only."
          fi

          REQUIRED_SECRETS=(SVRA_HOST SVRA_USERNAME SVRA_SSH_KEY MONGODB_HOST MONGODB_USERNAME MONGODB_PASSWORD MYSQL_HOST MYSQL_USERNAME MYSQL_PASSWORD MYSQL_DATABASE REDIS_CACHE_HOST REDIS_STORE_HOST JWT_SECRET DOCKERHUB_USERNAME DOCKERHUB_TOKEN)
          OPTIONAL_SECRETS=(SVRA_SSH_PORT SVRA_SUDO_PASSWORD MONGODB_PORT MYSQL_PORT REDIS_CACHE_PORT REDIS_CACHE_DB REDIS_CACHE_USERNAME REDIS_CACHE_PASSWORD REDIS_STORE_PORT REDIS_STORE_DB REDIS_STORE_USERNAME REDIS_STORE_PASSWORD NSQ_NSQD_HOST NSQ_NSQD_PORT WWW_UID WWW_GID)

          for SECRET_NAME in "${REQUIRED_SECRETS[@]}"; do
            VALUE=${!SECRET_NAME}
            if [ -n "$VALUE" ]; then
              echo "âœ… $SECRET_NAME is set"
            else
              if [ $ENFORCE_REQUIRED -eq 1 ]; then
                echo "âŒ $SECRET_NAME is not set"
                VALIDATION_FAILED=1
              else
                echo "âš ï¸ $SECRET_NAME is not set (required when deploying main)"
              fi
            fi
          done

          echo ""
          echo "ğŸ“ Checking optional secrets (warnings only)..."
          for SECRET_NAME in "${OPTIONAL_SECRETS[@]}"; do
            VALUE=${!SECRET_NAME}
            if [ -n "$VALUE" ]; then
              echo "âœ… $SECRET_NAME is set"
            else
              case "$SECRET_NAME" in
                SVRA_SUDO_PASSWORD)
                  echo "âš ï¸ $SECRET_NAME is not set (needed only if sudo prompts for a password)"
                  ;;
                WWW_UID|WWW_GID)
                  echo "âš ï¸ $SECRET_NAME is not set (defaults to 1000/1000)"
                  ;;
                MONGODB_PORT)
                  echo "âš ï¸ $SECRET_NAME is not set (defaults to 27017)"
                  ;;
                REDIS_CACHE_PORT)
                  echo "âš ï¸ $SECRET_NAME is not set (cache defaults to 6379)"
                  ;;
                REDIS_CACHE_DB)
                  echo "âš ï¸ $SECRET_NAME is not set (cache defaults to DB 0)"
                  ;;
                REDIS_CACHE_USERNAME)
                  echo "âš ï¸ $SECRET_NAME is not set (cache uses default Redis user)"
                  ;;
                REDIS_CACHE_PASSWORD)
                  echo "âš ï¸ $SECRET_NAME is not set (cache auth disabled)"
                  ;;
                REDIS_STORE_PORT)
                  echo "âš ï¸ $SECRET_NAME is not set (store defaults to 6380)"
                  ;;
                REDIS_STORE_DB)
                  echo "âš ï¸ $SECRET_NAME is not set (store defaults to DB 1)"
                  ;;
                REDIS_STORE_USERNAME)
                  echo "âš ï¸ $SECRET_NAME is not set (store uses default Redis user)"
                  ;;
                REDIS_STORE_PASSWORD)
                  echo "âš ï¸ $SECRET_NAME is not set (store auth disabled)"
                  ;;
                NSQ_NSQD_HOST|NSQ_NSQD_PORT)
                  echo "âš ï¸ $SECRET_NAME is not set (NSQ may be optional)"
                  ;;
                *)
                  echo "âš ï¸ $SECRET_NAME is not set (optional)"
                  ;;
              esac
            fi
          done

          echo ""
          if [ $ENFORCE_REQUIRED -eq 1 ] && [ $VALIDATION_FAILED -eq 1 ]; then
            echo "âŒ Secrets validation failed for main branch! Please configure the missing required secrets."
            exit 1
          else
            echo "âœ… Required secrets look good (or not enforced for this branch)."
          fi

  # ==========================================================================
  # 2) Test / Lint / Build â€”â€” è·‘åœ¨ GitHub æ‰˜ç®¡ runner ä¸Š
  # ==========================================================================

  test:
    name: Run Tests
    needs: [validate-secrets]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          check-latest: false
          cache: true
      
      - name: Get dependencies
        run: |
          go mod download
          go mod verify
      
      - name: Run tests
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
      
      - name: Generate coverage report
        run: |
          go tool cover -func=coverage.out
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella

  lint:
    name: Lint Code
    needs: [validate-secrets]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          check-latest: false
          cache: true
      
      - name: Install dependencies
        run: |
          go mod download
      
      - name: Run make lint
        run: |
          make lint

  docs:
    name: Docs & API Sync
    needs: [validate-secrets]
    if: ${{ (github.event_name == 'workflow_dispatch' && inputs.docs_verify) || (github.event_name != 'workflow_dispatch' && vars.DOCS_VERIFY == 'true') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          check-latest: false
          cache: true

      - name: Install PyYAML
        run: |
          python -m pip install --quiet pyyaml

      - name: Install swagger toolchain
        run: |
          go install github.com/swaggo/swag/cmd/swag@v1.16.4

      - name: Download dependencies
        run: |
          go mod download

      - name: Verify docs locally (make docs-verify)
        run: |
          make docs-verify

      - name: Ensure no doc drift
        run: |
          git diff --exit-code

  build:
    name: Build Applications
    needs: [test, lint]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [apiserver, collection, worker]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          check-latest: false
          cache: true
      
      - name: Build ${{ matrix.service }}
        run: |
          make build-${{ matrix.service }}
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: qs-${{ matrix.service }}
          path: bin/*
          retention-days: 7

  # ==========================================================================
  # 3) æ„å»º Docker é•œåƒ â€”â€” ç»§ç»­ç”¨ Linux runnerï¼Œå› ä¸ºç”¨äº† docker/* action
  # ==========================================================================

  docker:
    name: Build Docker Images
    needs: [build]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch')
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service: [apiserver, collection, worker]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Set image metadata
        id: meta
        run: |
          if [ "${{ matrix.service }}" = "apiserver" ]; then
            echo "image_name=qs-apiserver" >> $GITHUB_OUTPUT
            echo "dockerfile=build/docker/Dockerfile.qs-apiserver" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.service }}" = "worker" ]; then
            echo "image_name=qs-worker" >> $GITHUB_OUTPUT
            echo "dockerfile=build/docker/Dockerfile.qs-worker" >> $GITHUB_OUTPUT
          else
            echo "image_name=qs-collection-server" >> $GITHUB_OUTPUT
            echo "dockerfile=build/docker/Dockerfile.collection-server" >> $GITHUB_OUTPUT
          fi
      
      - name: Build and push to GHCR
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ steps.meta.outputs.dockerfile }}
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPOSITORY }}/${{ steps.meta.outputs.image_name }}:latest
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPOSITORY }}/${{ steps.meta.outputs.image_name }}:${{ github.sha }}
          build-args: |
            VERSION=${{ github.ref_name }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            GIT_BRANCH=${{ github.ref_name }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Tag and push to Docker Hub
        run: |
          IMAGE_NAME=${{ steps.meta.outputs.image_name }}
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPOSITORY }}/${IMAGE_NAME}:latest
          docker tag ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPOSITORY }}/${IMAGE_NAME}:latest \
            ${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:latest
          docker tag ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPOSITORY }}/${IMAGE_NAME}:latest \
            ${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:${{ github.sha }}
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:${{ github.sha }}
          echo "âœ… é•œåƒå·²æ¨é€åˆ° Docker Hub:"
          echo "   - ${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:latest"
          echo "   - ${{ secrets.DOCKERHUB_USERNAME }}/${IMAGE_NAME}:${{ github.sha }}"

  # ==========================================================================
  # 4) éƒ¨ç½² API Server / Collection Server / Worker â€”â€” ä»ç„¶åœ¨ Linux ä¸Šè·‘
  #    æ”¯æŒï¼špush main å…¨é‡éƒ¨ç½²ï¼›workflow_dispatch åªéƒ¨ç½²æŒ‡å®š service
  # ==========================================================================

  deploy-apiserver:
    name: Deploy API Server
    needs: [docker]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.service == 'all' || github.event.inputs.service == 'apiserver'))
    env:
      WWW_UID: ${{ secrets.WWW_UID || '1000' }}
      WWW_GID: ${{ secrets.WWW_GID || '1000' }}
      SERVICE_NAME: qs-apiserver
      IMAGE_NAME: qs-apiserver
      CONTAINER_NAME: qs-apiserver
      HTTP_PORT: 8081
      HTTPS_PORT: 9445
      INTERNAL_HTTP_PORT: 9080
      INTERNAL_HTTPS_PORT: 9444
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare deployment files
        env:
          MONGODB_HOST: ${{ secrets.MONGODB_HOST }}
          MONGODB_PORT: ${{ secrets.MONGODB_PORT || 27017 }}
          MONGODB_USERNAME: ${{ secrets.MONGODB_USERNAME }}
          MONGODB_PASSWORD: ${{ secrets.MONGODB_PASSWORD }}
          MONGODB_DBNAME: ${{ secrets.MONGODB_DBNAME }}
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT || 3306 }}
          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          # å…¼å®¹ä¸¤ç§å‘½åï¼šä¼˜å…ˆ MYSQL_DATABASEï¼Œå…¶æ¬¡ MYSQL_DBNAME
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE != '' && secrets.MYSQL_DATABASE || secrets.MYSQL_DBNAME }}
          REDIS_CACHE_HOST: ${{ secrets.REDIS_CACHE_HOST }}
          REDIS_CACHE_PORT: ${{ secrets.REDIS_CACHE_PORT || 6379 }}
          REDIS_CACHE_DB: ${{ secrets.REDIS_CACHE_DB || 0 }}
          REDIS_CACHE_USERNAME: ${{ secrets.REDIS_CACHE_USERNAME }}
          REDIS_CACHE_PASSWORD: ${{ secrets.REDIS_CACHE_PASSWORD }}
          REDIS_STORE_HOST: ${{ secrets.REDIS_STORE_HOST }}
          REDIS_STORE_PORT: ${{ secrets.REDIS_STORE_PORT || 6380 }}
          REDIS_STORE_DB: ${{ secrets.REDIS_STORE_DB || 1 }}
          REDIS_STORE_USERNAME: ${{ secrets.REDIS_STORE_USERNAME }}
          REDIS_STORE_PASSWORD: ${{ secrets.REDIS_STORE_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          NSQ_NSQD_HOST: ${{ secrets.NSQ_NSQD_HOST }}
          NSQ_NSQD_PORT: ${{ secrets.NSQ_NSQD_PORT || 4150 }}
        run: |
          require_env() {
            local missing=0
            for var in "$@"; do
              if [ -z "${!var}" ]; then
                echo "âŒ Missing required env: $var"
                missing=1
              fi
            done
            if [ $missing -ne 0 ]; then
              echo "âŒ Required deployment envs are not set, abort."
              exit 1
            fi
          }

          require_env \
            MONGODB_HOST MONGODB_PORT MONGODB_USERNAME MONGODB_PASSWORD MONGODB_DBNAME \
            MYSQL_HOST MYSQL_PORT MYSQL_USERNAME MYSQL_PASSWORD MYSQL_DATABASE \
            REDIS_CACHE_HOST REDIS_CACHE_PORT REDIS_STORE_HOST REDIS_STORE_PORT \
            JWT_SECRET NSQ_NSQD_HOST NSQ_NSQD_PORT

          mkdir -p deploy-package/configs/env
          cp -r configs deploy-package/
          cp build/docker/docker-compose.prod.yml deploy-package/docker-compose.prod.yml

          cat > deploy-package/configs/env/config.prod.env <<EOF
          # Auto-generated production environment configuration for QS API Server
          QS_APISERVER_MONGODB_HOST=${MONGODB_HOST}:${MONGODB_PORT}
          QS_APISERVER_MONGODB_USERNAME=${MONGODB_USERNAME}
          QS_APISERVER_MONGODB_PASSWORD=${MONGODB_PASSWORD}
          QS_APISERVER_MONGODB_DATABASE=${MONGODB_DBNAME}

          QS_APISERVER_MYSQL_HOST=${MYSQL_HOST}:${MYSQL_PORT}
          QS_APISERVER_MYSQL_USERNAME=${MYSQL_USERNAME}
          QS_APISERVER_MYSQL_PASSWORD=${MYSQL_PASSWORD}
          QS_APISERVER_MYSQL_DATABASE=${MYSQL_DATABASE}
          
          # Redis Cache (ServerA æœ¬åœ°ç¼“å­˜)
          QS_APISERVER_REDIS_CACHE_HOST=${REDIS_CACHE_HOST}
          QS_APISERVER_REDIS_CACHE_PORT=${REDIS_CACHE_PORT}
          QS_APISERVER_REDIS_CACHE_USERNAME=${REDIS_CACHE_USERNAME}
          QS_APISERVER_REDIS_CACHE_PASSWORD=${REDIS_CACHE_PASSWORD}
          QS_APISERVER_REDIS_CACHE_DB=${REDIS_CACHE_DB}
          
          # Redis Store (äº‘æŒä¹…åŒ– Redis)
          QS_APISERVER_REDIS_STORE_HOST=${REDIS_STORE_HOST}
          QS_APISERVER_REDIS_STORE_PORT=${REDIS_STORE_PORT}
          QS_APISERVER_REDIS_STORE_USERNAME=${REDIS_STORE_USERNAME}
          QS_APISERVER_REDIS_STORE_PASSWORD=${REDIS_STORE_PASSWORD}
          QS_APISERVER_REDIS_STORE_DB=${REDIS_STORE_DB}
          
          QS_APISERVER_JWT_SECRET=${JWT_SECRET}
          
          QS_APISERVER_NSQ_NSQD_HOST=${NSQ_NSQD_HOST}
          QS_APISERVER_NSQ_NSQD_PORT=${NSQ_NSQD_PORT}
          EOF

          echo "=========================================="
          echo "ğŸ“‹ Generated config.prod.env for API Server"
          echo "=========================================="
          cat deploy-package/configs/env/config.prod.env | sed 's/PASSWORD=.*/PASSWORD=***REDACTED***/g' | sed 's/SECRET=.*/SECRET=***REDACTED***/g'
          echo "=========================================="

          # ä»¥ç›®å½•å½¢å¼ä¸Šä¼ ï¼Œé¿å…åŒé‡ tar ä¸¢å¤±æ–‡ä»¶
          tar -czf deploy-package.tar.gz -C deploy-package .

      - name: Upload deployment package
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          source: "deploy-package.tar.gz"
          target: "/tmp"

      - name: Deploy to Production Server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_REPOSITORY: ${{ env.DOCKER_REPOSITORY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          HTTP_PORT: ${{ env.HTTP_PORT }}
          HTTPS_PORT: ${{ env.HTTPS_PORT }}
          INTERNAL_HTTP_PORT: ${{ env.INTERNAL_HTTP_PORT }}
          INTERNAL_HTTPS_PORT: ${{ env.INTERNAL_HTTPS_PORT }}
          GHCR_USERNAME: ${{ github.actor }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUDO_PASSWORD: ${{ secrets.SVRA_SUDO_PASSWORD }}
          WWW_UID: ${{ env.WWW_UID }}
          WWW_GID: ${{ env.WWW_GID }}
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          envs: DOCKER_REGISTRY,DOCKER_REPOSITORY,IMAGE_NAME,CONTAINER_NAME,HTTP_PORT,HTTPS_PORT,INTERNAL_HTTP_PORT,INTERNAL_HTTPS_PORT,GHCR_USERNAME,GHCR_TOKEN,SUDO_PASSWORD,WWW_UID,WWW_GID
          script: |
            set -Eeuo pipefail

            APP_UID="${WWW_UID:-1000}"
            APP_GID="${WWW_GID:-1000}"

            # SUDO åŠ©æ‰‹
            if sudo -n true 2>/dev/null; then
              SUDO="sudo"
              echo "â„¹ï¸ Using passwordless sudo."
            else
              if [ -z "${SUDO_PASSWORD:-}" ]; then
                echo "âŒ sudo needs password. Provide SVRA_SUDO_PASSWORD or configure NOPASSWD." >&2
                exit 1
              fi
              sudo_pw() { sudo -S "$@" <<<"$SUDO_PASSWORD"; }
              export -f sudo_pw
              SUDO="sudo_pw"
              $SUDO -v || true
              echo "â„¹ï¸ Using sudo with password."
            fi

            echo "=========================================="
            echo "Deploying ${CONTAINER_NAME} to Production Server"
            echo "=========================================="

            # ç›®å½•å‡†å¤‡
            $SUDO mkdir -p /opt/qs-server/${CONTAINER_NAME}/configs/env
            $SUDO mkdir -p /data/logs/qs-server/${CONTAINER_NAME}
            $SUDO mkdir -p /opt/backups/qs-server/${CONTAINER_NAME}

            # å¤‡ä»½
            BACKUP_DIR="/opt/backups/qs-server/${CONTAINER_NAME}"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            if [ -d "/opt/qs-server/${CONTAINER_NAME}/configs" ] && [ "$(ls -A /opt/qs-server/${CONTAINER_NAME}/configs 2>/dev/null)" != "" ]; then
              $SUDO tar -czf "$BACKUP_DIR/backup_${TIMESTAMP}.tar.gz" \
                /opt/qs-server/${CONTAINER_NAME}/configs \
                2>/dev/null || echo "No previous version to backup"
            fi

            # è§£åŒ…ï¼ˆå…¼å®¹ä¸åŒè½ç›˜è·¯å¾„ï¼Œä¼˜å…ˆæŸ¥æ‰¾ /tmp ä¸‹çš„ deploy-package.tar.gzï¼‰
            PKG_PATH=$(find /tmp -maxdepth 1 -name "deploy-package.tar.gz" 2>/dev/null | head -n1 || true)
            if [ -z "$PKG_PATH" ]; then
              echo "âŒ deploy-package.tar.gz not found under /tmp" >&2
              ls -al /tmp || true
              exit 1
            fi

            DEPLOY_TMP="/tmp/qs-deploy-$$"
            mkdir -p "$DEPLOY_TMP"
            tar -xzf "$PKG_PATH" -C "$DEPLOY_TMP"

            $SUDO rsync -a "$DEPLOY_TMP/configs/" /opt/qs-server/${CONTAINER_NAME}/configs/
            $SUDO chown -R "$APP_UID:$APP_GID" /opt/qs-server/${CONTAINER_NAME}/configs
            $SUDO chown -R "$APP_UID:$APP_GID" /data/logs/qs-server/${CONTAINER_NAME}

            # ç½‘ç»œ
            if ! $SUDO docker network ls --format '{{.Name}}' | grep -w qs-network > /dev/null 2>&1; then
              echo "Creating Docker network qs-network..."
              $SUDO docker network create qs-network
            fi

            # è¯ä¹¦è·¯å¾„
            CERT_HOST_PATH="/data/ssl/certs/yangshujie.com.crt"
            KEY_HOST_PATH="/data/ssl/private/yangshujie.com.key"

            if ! $SUDO test -r "$CERT_HOST_PATH"; then
              echo "âŒ CERT not readable: $CERT_HOST_PATH"
              exit 1
            fi
            if ! $SUDO test -r "$KEY_HOST_PATH"; then
              echo "âŒ KEY not readable: $KEY_HOST_PATH"
              exit 1
            fi

            TLS_MOUNTS="-v $CERT_HOST_PATH:/etc/qs-server/ssl/yangshujie.com.crt:ro \
                        -v $KEY_HOST_PATH:/etc/qs-server/ssl/yangshujie.com.key:ro"

            # GHCR ç™»å½•
            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "Logging into GitHub Container Registry..."
              echo "$GHCR_TOKEN" | $SUDO docker login "$DOCKER_REGISTRY" -u "$GHCR_USERNAME" --password-stdin >/dev/null || true
            fi

            # æ‹‰å–é•œåƒ
            echo "Pulling latest Docker image..."
            if ! $SUDO docker pull "$DOCKER_REGISTRY/$DOCKER_REPOSITORY/$IMAGE_NAME:latest"; then
              echo "âš ï¸ Pull with auth failed, trying anonymous..."
              $SUDO docker pull "$DOCKER_REGISTRY/$DOCKER_REPOSITORY/$IMAGE_NAME:latest" || true
            fi

            # åœæ—§å®¹å™¨
            if $SUDO docker ps -a --format '{{.Names}}' | grep -w ${CONTAINER_NAME} > /dev/null 2>&1; then
              echo "Stopping existing container..."
              $SUDO docker stop ${CONTAINER_NAME} || true
              $SUDO docker rm ${CONTAINER_NAME} || true
            fi

            # å¯åŠ¨å®¹å™¨ï¼ˆä½¿ç”¨ composeï¼‰
            cd /opt/qs-server/${CONTAINER_NAME}
            $SUDO docker compose -f "$DEPLOY_TMP/docker-compose.prod.yml" pull qs-apiserver || true
            $SUDO docker compose -f "$DEPLOY_TMP/docker-compose.prod.yml" up -d qs-apiserver

            # å¥åº·æ£€æŸ¥ï¼ˆapiserver å…¬å¼€çš„æ˜¯ /healthï¼‰
            echo "Waiting for service to be ready..."
            ATTEMPTS=0
            MAX_ATTEMPTS=30
            while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
              if curl -sf http://localhost:${HTTP_PORT}/health > /dev/null 2>&1; then
                echo "âœ… Health check passed (attempt $ATTEMPTS)"
                $SUDO docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}"
                break
              fi
              ATTEMPTS=$((ATTEMPTS + 1))
              if [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; then
                echo "â³ Health check attempt $ATTEMPTS/$MAX_ATTEMPTS, retrying..."
                sleep 5
              fi
            done

            if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
              echo "âŒ Service failed to start after $MAX_ATTEMPTS attempts"
              $SUDO docker logs --tail 100 ${CONTAINER_NAME} || true
              exit 1
            fi

            # æ¸…ç†æ—§å¤‡ä»½
            $SUDO bash -c 'ls -t '"$BACKUP_DIR"'/backup_*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm -f 2>/dev/null || true'

            rm -rf "$DEPLOY_TMP"
            rm -f /tmp/deploy-package.tar.gz

            echo "=========================================="
            echo "âœ… ${CONTAINER_NAME} deployment completed"
            echo "=========================================="

  deploy-collection:
    name: Deploy Collection Server
    needs: [docker]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.service == 'all' || github.event.inputs.service == 'collection'))
    env:
      WWW_UID: ${{ secrets.WWW_UID || '1000' }}
      WWW_GID: ${{ secrets.WWW_GID || '1000' }}
      SERVICE_NAME: collection-server
      IMAGE_NAME: qs-collection-server
      CONTAINER_NAME: qs-collection-server
      HTTP_PORT: 8082
      HTTPS_PORT: 9446
      INTERNAL_HTTP_PORT: 9080
      INTERNAL_HTTPS_PORT: 9444
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare deployment files
        env:
          REDIS_CACHE_HOST: ${{ secrets.REDIS_CACHE_HOST }}
          REDIS_CACHE_PORT: ${{ secrets.REDIS_CACHE_PORT || 6379 }}
          REDIS_CACHE_DB: ${{ secrets.REDIS_CACHE_DB || 0 }}
          REDIS_CACHE_USERNAME: ${{ secrets.REDIS_CACHE_USERNAME }}
          REDIS_CACHE_PASSWORD: ${{ secrets.REDIS_CACHE_PASSWORD }}
          REDIS_STORE_HOST: ${{ secrets.REDIS_STORE_HOST }}
          REDIS_STORE_PORT: ${{ secrets.REDIS_STORE_PORT || 6380 }}
          REDIS_STORE_DB: ${{ secrets.REDIS_STORE_DB || 1 }}
          REDIS_STORE_USERNAME: ${{ secrets.REDIS_STORE_USERNAME }}
          REDIS_STORE_PASSWORD: ${{ secrets.REDIS_STORE_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          require_env() {
            local missing=0
            for var in "$@"; do
              if [ -z "${!var}" ]; then
                echo "âŒ Missing required env: $var"
                missing=1
              fi
            done
            if [ $missing -ne 0 ]; then
              echo "âŒ Required deployment envs are not set, abort."
              exit 1
            fi
          }

          require_env \
            REDIS_CACHE_HOST REDIS_CACHE_PORT REDIS_STORE_HOST REDIS_STORE_PORT JWT_SECRET

          mkdir -p deploy-package/configs/env
          cp -r configs deploy-package/
          cp build/docker/docker-compose.prod.yml deploy-package/docker-compose.prod.yml

          cat > deploy-package/configs/env/config.prod.env <<EOF
          # Auto-generated production environment configuration for Collection Server
          # Redis Cache (ServerA æœ¬åœ°ç¼“å­˜)
          COLLECTION_SERVER_REDIS_CACHE_HOST=${REDIS_CACHE_HOST}
          COLLECTION_SERVER_REDIS_CACHE_PORT=${REDIS_CACHE_PORT}
          COLLECTION_SERVER_REDIS_CACHE_USERNAME=${REDIS_CACHE_USERNAME}
          COLLECTION_SERVER_REDIS_CACHE_PASSWORD=${REDIS_CACHE_PASSWORD}
          COLLECTION_SERVER_REDIS_CACHE_DB=${REDIS_CACHE_DB}
          
          # Redis Store (äº‘æŒä¹…åŒ– Redis)
          COLLECTION_SERVER_REDIS_STORE_HOST=${REDIS_STORE_HOST}
          COLLECTION_SERVER_REDIS_STORE_PORT=${REDIS_STORE_PORT}
          COLLECTION_SERVER_REDIS_STORE_USERNAME=${REDIS_STORE_USERNAME}
          COLLECTION_SERVER_REDIS_STORE_PASSWORD=${REDIS_STORE_PASSWORD}
          COLLECTION_SERVER_REDIS_STORE_DB=${REDIS_STORE_DB}
          
          COLLECTION_SERVER_JWT_SECRET=${JWT_SECRET}
          EOF

          echo "=========================================="
          echo "ğŸ“‹ Generated config.prod.env for Collection Server"
          echo "=========================================="
          cat deploy-package/configs/env/config.prod.env | sed 's/PASSWORD=.*/PASSWORD=***REDACTED***/g' | sed 's/SECRET=.*/SECRET=***REDACTED***/g'
          echo "=========================================="

          tar -czf deploy-package.tar.gz -C deploy-package .

      - name: Upload deployment package
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          source: "deploy-package.tar.gz"
          target: "/tmp"

      - name: Deploy to Production Server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_REPOSITORY: ${{ env.DOCKER_REPOSITORY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          HTTP_PORT: ${{ env.HTTP_PORT }}
          HTTPS_PORT: ${{ env.HTTPS_PORT }}
          INTERNAL_HTTP_PORT: ${{ env.INTERNAL_HTTP_PORT }}
          INTERNAL_HTTPS_PORT: ${{ env.INTERNAL_HTTPS_PORT }}
          GHCR_USERNAME: ${{ github.actor }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUDO_PASSWORD: ${{ secrets.SVRA_SUDO_PASSWORD }}
          WWW_UID: ${{ env.WWW_UID }}
          WWW_GID: ${{ env.WWW_GID }}
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          envs: DOCKER_REGISTRY,DOCKER_REPOSITORY,IMAGE_NAME,CONTAINER_NAME,HTTP_PORT,HTTPS_PORT,INTERNAL_HTTP_PORT,INTERNAL_HTTPS_PORT,GHCR_USERNAME,GHCR_TOKEN,SUDO_PASSWORD,WWW_UID,WWW_GID
          script: |
            set -Eeuo pipefail

            APP_UID="${WWW_UID:-1000}"
            APP_GID="${WWW_GID:-1000}"

            # SUDO åŠ©æ‰‹
            if sudo -n true 2>/dev/null; then
              SUDO="sudo"
            else
              if [ -z "${SUDO_PASSWORD:-}" ]; then
                echo "âŒ sudo needs password." >&2
                exit 1
              fi
              sudo_pw() { sudo -S "$@" <<<"$SUDO_PASSWORD"; }
              export -f sudo_pw
              SUDO="sudo_pw"
              $SUDO -v || true
            fi

            echo "=========================================="
            echo "Deploying ${CONTAINER_NAME}"
            echo "=========================================="

            # ç›®å½•å‡†å¤‡
            $SUDO mkdir -p /opt/qs-server/${CONTAINER_NAME}/configs/env
            $SUDO mkdir -p /data/logs/qs-server/${CONTAINER_NAME}
            $SUDO mkdir -p /opt/backups/qs-server/${CONTAINER_NAME}

            # å¤‡ä»½
            BACKUP_DIR="/opt/backups/qs-server/${CONTAINER_NAME}"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            if [ -d "/opt/qs-server/${CONTAINER_NAME}/configs" ] && [ "$(ls -A /opt/qs-server/${CONTAINER_NAME}/configs 2>/dev/null)" != "" ]; then
              $SUDO tar -czf "$BACKUP_DIR/backup_${TIMESTAMP}.tar.gz" \
                /opt/qs-server/${CONTAINER_NAME}/configs \
                2>/dev/null || echo "No previous backup"
            fi

            # è§£åŒ…
            DEPLOY_TMP="/tmp/qs-deploy-$$"
            mkdir -p "$DEPLOY_TMP"
            PKG_PATH=$(find /tmp -maxdepth 1 -name "deploy-package.tar.gz" 2>/dev/null | head -n1 || true)
            if [ -z "$PKG_PATH" ]; then
              echo "âŒ deploy-package.tar.gz not found under /tmp" >&2
              ls -al /tmp || true
              exit 1
            fi
            tar -xzf "$PKG_PATH" -C "$DEPLOY_TMP"

            $SUDO rsync -a "$DEPLOY_TMP/configs/" /opt/qs-server/${CONTAINER_NAME}/configs/
            $SUDO chown -R "$APP_UID:$APP_GID" /opt/qs-server/${CONTAINER_NAME}/configs
            $SUDO chown -R "$APP_UID:$APP_GID" /data/logs/qs-server/${CONTAINER_NAME}

            # ç½‘ç»œ
            if ! $SUDO docker network ls --format '{{.Name}}' | grep -w qs-network > /dev/null 2>&1; then
              $SUDO docker network create qs-network
            fi

            # è¯ä¹¦
            CERT_HOST_PATH="/data/ssl/certs/yangshujie.com.crt"
            KEY_HOST_PATH="/data/ssl/private/yangshujie.com.key"

            if ! $SUDO test -r "$CERT_HOST_PATH" || ! $SUDO test -r "$KEY_HOST_PATH"; then
              echo "âŒ TLS certificates not found"
              exit 1
            fi

            TLS_MOUNTS="-v $CERT_HOST_PATH:/etc/qs-server/ssl/yangshujie.com.crt:ro \
                        -v $KEY_HOST_PATH:/etc/qs-server/ssl/yangshujie.com.key:ro"

            # ç™»å½• GHCR
            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "$GHCR_TOKEN" | $SUDO docker login "$DOCKER_REGISTRY" -u "$GHCR_USERNAME" --password-stdin >/dev/null || true
            fi

            # æ‹‰å–é•œåƒ
            $SUDO docker pull "$DOCKER_REGISTRY/$DOCKER_REPOSITORY/$IMAGE_NAME:latest" || true

            # åœæ—§å®¹å™¨
            if $SUDO docker ps -a --format '{{.Names}}' | grep -w ${CONTAINER_NAME} > /dev/null 2>&1; then
              $SUDO docker stop ${CONTAINER_NAME} || true
              $SUDO docker rm ${CONTAINER_NAME} || true
            fi

            # å¯åŠ¨ï¼ˆä½¿ç”¨ composeï¼‰
            cd /opt/qs-server/${CONTAINER_NAME}
            $SUDO docker compose -f "$DEPLOY_TMP/docker-compose.prod.yml" pull qs-collection-server || true
            $SUDO docker compose -f "$DEPLOY_TMP/docker-compose.prod.yml" up -d qs-collection-server

            # å¥åº·æ£€æŸ¥ï¼ˆcollection-server å…¬å¼€çš„æ˜¯ /healthï¼‰
            ATTEMPTS=0
            MAX_ATTEMPTS=30
            while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
              if curl -sf http://localhost:${HTTP_PORT}/health > /dev/null 2>&1; then
                echo "âœ… Health check passed"
                break
              fi
              ATTEMPTS=$((ATTEMPTS + 1))
              if [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; then
                sleep 5
              fi
            done

            if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
              echo "âŒ Service failed to start"
              $SUDO docker logs --tail 100 ${CONTAINER_NAME} || true
              exit 1
            fi

            # æ¸…ç†æ—§å¤‡ä»½
            $SUDO bash -c 'ls -t '"$BACKUP_DIR"'/backup_*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm -f || true'

            rm -rf "$DEPLOY_TMP"
            rm -f /tmp/deploy-package.tar.gz

            echo "âœ… ${CONTAINER_NAME} deployed"

  deploy-worker:
    name: Deploy Worker
    needs: [docker]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.service == 'all' || github.event.inputs.service == 'worker'))
    env:
      WWW_UID: ${{ secrets.WWW_UID || '1000' }}
      WWW_GID: ${{ secrets.WWW_GID || '1000' }}
      SERVICE_NAME: qs-worker
      IMAGE_NAME: qs-worker
      CONTAINER_NAME: qs-worker
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare deployment files
        env:
          MONGODB_HOST: ${{ secrets.MONGODB_HOST }}
          MONGODB_PORT: ${{ secrets.MONGODB_PORT || 27017 }}
          MONGODB_USERNAME: ${{ secrets.MONGODB_USERNAME }}
          MONGODB_PASSWORD: ${{ secrets.MONGODB_PASSWORD }}
          MONGODB_DBNAME: ${{ secrets.MONGODB_DBNAME }}
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT || 3306 }}
          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE }}
          NSQ_NSQD_HOST: ${{ secrets.NSQ_NSQD_HOST }}
          NSQ_NSQD_PORT: ${{ secrets.NSQ_NSQD_PORT || 4150 }}
          NSQ_LOOKUPD_HOST: ${{ secrets.NSQ_LOOKUPD_HOST }}
          NSQ_LOOKUPD_PORT: ${{ secrets.NSQ_LOOKUPD_PORT || 4161 }}
          GRPC_APISERVER_ADDR: ${{ secrets.GRPC_APISERVER_ADDR || 'qs-apiserver:9090' }}
          REDIS_CACHE_HOST: ${{ secrets.REDIS_CACHE_HOST }}
          REDIS_CACHE_PORT: ${{ secrets.REDIS_CACHE_PORT || 6379 }}
          REDIS_CACHE_DB: ${{ secrets.REDIS_CACHE_DB || 0 }}
          REDIS_CACHE_USERNAME: ${{ secrets.REDIS_CACHE_USERNAME }}
          REDIS_CACHE_PASSWORD: ${{ secrets.REDIS_CACHE_PASSWORD }}
          REDIS_STORE_HOST: ${{ secrets.REDIS_STORE_HOST }}
          REDIS_STORE_PORT: ${{ secrets.REDIS_STORE_PORT || 6380 }}
          REDIS_STORE_DB: ${{ secrets.REDIS_STORE_DB || 1 }}
          REDIS_STORE_USERNAME: ${{ secrets.REDIS_STORE_USERNAME }}
          REDIS_STORE_PASSWORD: ${{ secrets.REDIS_STORE_PASSWORD }}
        run: |
          require_env() {
            local missing=0
            for var in "$@"; do
              if [ -z "${!var}" ]; then
                echo "âŒ Missing required env: $var"
                missing=1
              fi
            done
            if [ $missing -ne 0 ]; then
              echo "âŒ Required deployment envs are not set, abort."
              exit 1
            fi
          }

          require_env \
            MONGODB_HOST MONGODB_PORT MONGODB_USERNAME MONGODB_PASSWORD MONGODB_DBNAME \
            MYSQL_HOST MYSQL_PORT MYSQL_USERNAME MYSQL_PASSWORD MYSQL_DATABASE \
            NSQ_NSQD_HOST NSQ_NSQD_PORT NSQ_LOOKUPD_HOST NSQ_LOOKUPD_PORT \
            REDIS_CACHE_HOST REDIS_CACHE_PORT REDIS_STORE_HOST REDIS_STORE_PORT

          mkdir -p deploy-package/configs/env
          cp -r configs deploy-package/
          cp build/docker/docker-compose.prod.yml deploy-package/docker-compose.prod.yml

          cat > deploy-package/configs/env/config.prod.env <<EOF
          # Auto-generated production environment configuration for QS Worker
          QS_WORKER_MONGODB_URL=mongodb://${MONGODB_USERNAME}:${MONGODB_PASSWORD}@${MONGODB_HOST}:${MONGODB_PORT}/${MONGODB_DBNAME}?authSource=admin
          
          QS_WORKER_MYSQL_HOST=${MYSQL_HOST}:${MYSQL_PORT}
          QS_WORKER_MYSQL_USERNAME=${MYSQL_USERNAME}
          QS_WORKER_MYSQL_PASSWORD=${MYSQL_PASSWORD}
          QS_WORKER_MYSQL_DATABASE=${MYSQL_DATABASE}
          
          QS_WORKER_MESSAGING_PROVIDER=nsq
          QS_WORKER_NSQ_ADDR=${NSQ_NSQD_HOST}:${NSQ_NSQD_PORT}
          QS_WORKER_NSQ_LOOKUPD_ADDR=${NSQ_LOOKUPD_HOST}:${NSQ_LOOKUPD_PORT}
          
          QS_WORKER_GRPC_APISERVER_ADDR=${GRPC_APISERVER_ADDR}
          
          # Redis Cache (ServerA æœ¬åœ°ç¼“å­˜)
          QS_WORKER_REDIS_CACHE_HOST=${REDIS_CACHE_HOST}
          QS_WORKER_REDIS_CACHE_PORT=${REDIS_CACHE_PORT}
          QS_WORKER_REDIS_CACHE_USERNAME=${REDIS_CACHE_USERNAME}
          QS_WORKER_REDIS_CACHE_PASSWORD=${REDIS_CACHE_PASSWORD}
          QS_WORKER_REDIS_CACHE_DB=${REDIS_CACHE_DB}
          
          # Redis Store (äº‘æŒä¹…åŒ– Redis)
          QS_WORKER_REDIS_STORE_HOST=${REDIS_STORE_HOST}
          QS_WORKER_REDIS_STORE_PORT=${REDIS_STORE_PORT}
          QS_WORKER_REDIS_STORE_USERNAME=${REDIS_STORE_USERNAME}
          QS_WORKER_REDIS_STORE_PASSWORD=${REDIS_STORE_PASSWORD}
          QS_WORKER_REDIS_STORE_DB=${REDIS_STORE_DB}
          EOF

          echo "=========================================="
          echo "ğŸ“‹ Generated config.prod.env for Worker"
          echo "=========================================="
          cat deploy-package/configs/env/config.prod.env | sed 's/PASSWORD=.*/PASSWORD=***REDACTED***/g'
          echo "=========================================="

          tar -czf deploy-package.tar.gz -C deploy-package .

      - name: Upload deployment package
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          source: "deploy-package.tar.gz"
          target: "/tmp"

      - name: Deploy to Production Server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_REPOSITORY: ${{ env.DOCKER_REPOSITORY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          GHCR_USERNAME: ${{ github.actor }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUDO_PASSWORD: ${{ secrets.SVRA_SUDO_PASSWORD }}
          WWW_UID: ${{ env.WWW_UID }}
          WWW_GID: ${{ env.WWW_GID }}
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          envs: DOCKER_REGISTRY,DOCKER_REPOSITORY,IMAGE_NAME,CONTAINER_NAME,GHCR_USERNAME,GHCR_TOKEN,SUDO_PASSWORD,WWW_UID,WWW_GID
          script: |
            set -Eeuo pipefail

            APP_UID="${WWW_UID:-1000}"
            APP_GID="${WWW_GID:-1000}"

            # SUDO åŠ©æ‰‹
            if sudo -n true 2>/dev/null; then
              SUDO="sudo"
            else
              if [ -z "${SUDO_PASSWORD:-}" ]; then
                echo "âŒ sudo needs password." >&2
                exit 1
              fi
              sudo_pw() { sudo -S "$@" <<<"$SUDO_PASSWORD"; }
              export -f sudo_pw
              SUDO="sudo_pw"
              $SUDO -v || true
            fi

            echo "=========================================="
            echo "Deploying ${CONTAINER_NAME}"
            echo "=========================================="

            # ç›®å½•å‡†å¤‡
            $SUDO mkdir -p /opt/qs-server/${CONTAINER_NAME}/configs/env
            $SUDO mkdir -p /data/logs/qs-server/${CONTAINER_NAME}
            $SUDO mkdir -p /opt/backups/qs-server/${CONTAINER_NAME}

            # å¤‡ä»½
            BACKUP_DIR="/opt/backups/qs-server/${CONTAINER_NAME}"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            if [ -d "/opt/qs-server/${CONTAINER_NAME}/configs" ] && [ "$(ls -A /opt/qs-server/${CONTAINER_NAME}/configs 2>/dev/null)" != "" ]; then
              $SUDO tar -czf "$BACKUP_DIR/backup_${TIMESTAMP}.tar.gz" \
                /opt/qs-server/${CONTAINER_NAME}/configs \
                2>/dev/null || echo "No previous backup"
            fi

            # è§£åŒ…
            DEPLOY_TMP="/tmp/qs-deploy-$$"
            mkdir -p "$DEPLOY_TMP"
            PKG_PATH=$(find /tmp -maxdepth 1 -name "deploy-package.tar.gz" 2>/dev/null | head -n1 || true)
            if [ -z "$PKG_PATH" ]; then
              echo "âŒ deploy-package.tar.gz not found under /tmp" >&2
              ls -al /tmp || true
              exit 1
            fi
            tar -xzf "$PKG_PATH" -C "$DEPLOY_TMP"

            $SUDO rsync -a "$DEPLOY_TMP/configs/" /opt/qs-server/${CONTAINER_NAME}/configs/
            $SUDO chown -R "$APP_UID:$APP_GID" /opt/qs-server/${CONTAINER_NAME}/configs
            $SUDO chown -R "$APP_UID:$APP_GID" /data/logs/qs-server/${CONTAINER_NAME}

            # ç½‘ç»œ
            if ! $SUDO docker network ls --format '{{.Name}}' | grep -w qs-network > /dev/null 2>&1; then
              $SUDO docker network create qs-network
            fi

            # ç™»å½• GHCR
            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "$GHCR_TOKEN" | $SUDO docker login "$DOCKER_REGISTRY" -u "$GHCR_USERNAME" --password-stdin >/dev/null || true
            fi

            # æ‹‰å–é•œåƒ
            $SUDO docker pull "$DOCKER_REGISTRY/$DOCKER_REPOSITORY/$IMAGE_NAME:latest" || true

            # åœæ—§å®¹å™¨
            if $SUDO docker ps -a --format '{{.Names}}' | grep -w ${CONTAINER_NAME} > /dev/null 2>&1; then
              $SUDO docker stop ${CONTAINER_NAME} || true
              $SUDO docker rm ${CONTAINER_NAME} || true
            fi

            # å¯åŠ¨ (ä½¿ç”¨ composeï¼ŒWorker æ— ç«¯å£/TLS)
            cd /opt/qs-server/${CONTAINER_NAME}
            $SUDO docker compose -f "$DEPLOY_TMP/docker-compose.prod.yml" pull qs-worker || true
            $SUDO docker compose -f "$DEPLOY_TMP/docker-compose.prod.yml" up -d qs-worker

            # Worker æ—  HTTP å¥åº·æ£€æŸ¥ï¼Œæ£€æŸ¥å®¹å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ
            echo "Waiting for container to start..."
            sleep 10
            
            if $SUDO docker ps --filter "name=${CONTAINER_NAME}" --filter "status=running" | grep -q ${CONTAINER_NAME}; then
              echo "âœ… Container is running"
              $SUDO docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}"
              echo "ğŸ“‹ Recent logs:"
              $SUDO docker logs --tail 20 ${CONTAINER_NAME}
            else
              echo "âŒ Container failed to start"
              $SUDO docker logs --tail 100 ${CONTAINER_NAME} || true
              exit 1
            fi

            # æ¸…ç†æ—§å¤‡ä»½
            $SUDO bash -c 'ls -t '"$BACKUP_DIR"'/backup_*.tar.gz 2>/dev/null | tail -n +6 | xargs -r rm -f || true'

            echo "âœ… ${CONTAINER_NAME} deployed"

            rm -rf "$DEPLOY_TMP"
            rm -f /tmp/deploy-package.tar.gz

  # ==========================================================================
  # 5) æ€»ä½“é€šçŸ¥ â€”â€” æŠŠ skipped ä¹Ÿè§†ä¸º OKï¼Œæ”¯æŒã€Œåªéƒ¨ç½²éƒ¨åˆ†æœåŠ¡ã€
  # ==========================================================================

  notify:
    name: Send Notification
    needs: [deploy-apiserver, deploy-collection, deploy-worker]
    runs-on: ubuntu-latest
    if: |
      always() && (
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        github.event_name == 'workflow_dispatch'
      )
    steps:
      - name: Log deployment status
        run: |
          echo "=========================================="
          echo "Deployment Summary"
          echo "=========================================="
          echo "API Server: ${{ needs.deploy-apiserver.result }}"
          echo "Collection Server: ${{ needs.deploy-collection.result }}"
          echo "Worker: ${{ needs.deploy-worker.result }}"

          ok() {
            [ "$1" = "success" ] || [ "$1" = "skipped" ]
          }

          if ok "${{ needs.deploy-apiserver.result }}" &&
             ok "${{ needs.deploy-collection.result }}" &&
             ok "${{ needs.deploy-worker.result }}"; then
            echo "âœ… All deployments succeeded or were skipped by design"
          else
            echo "âŒ Some deployments failed"
            exit 1
          fi
